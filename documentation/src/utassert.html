<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   
   
   
   <title>utPLSQL - utAssert Package</title>
</head>
<body>
 
<table cols="1" width="100%">
<tr>
<td bgcolor="#800080"><a href="index.html"><img height="56" src="utplsql.jpg" width="373"></a></td>
</tr>
</table>

<blockquote>
Authors: Steven Feuerstein,
Chris Rimmer

Copyright 2000-2001, all rights
reserved
</blockquote>
[ <a href="index.html">Home</a> | <a href="started.html">Getting
Started</a> | <a href="buildpack.html">Build Test Packages</a>
| <a href="examples.html">Examples</a> | <b><a href="userguide.html">User
Guide</a></b> | <a href="release.html">Release Notes</a> | <a href="map.html">Document
Map</a> ]
<p><a href="utresult.html">&lt; Previous Section: utResult Package</a> |
<a href="utgen.html">Next
Section: utGen Package ></a>
<br> 
<!-- Begin utPLSQL Body -->
<h1>
utAssert Package</h1>

<p>This package contains the following procedures and functions:
<br> 
<table cellspacing="5">
<tr>
<td width="25%"><a href="#utassert.this">utAssert.showresults</a>
<br><a href="#Showresults">utAssert.noshowresults</a>
<br><a href="#utassert.this">utAssert.showingresults</a></td>

<td><a href="#Showresults">Set the showing of results immediately</a></td>
</tr>

<tr>
<td><a href="#utassert.this">utAssert.this</a></td>

<td><a href="#utassert.this">Generic "Assert This" Procedure</a></td>
</tr>

<tr>
<td><a href="#utassert.isnull">utAssert.isnull</a>
<br><a href="#utassert.isnull">utAssert.isnotnull</a></td>

<td><a href="#utassert.isnull">Check for NULL and NOT NULL values</a></td>
</tr>

<tr>
<td><a href="#utassert.eq">utAssert.eq</a></td>

<td><a href="#utassert.eq">Check Equality of Scalar Values</a></td>
</tr>

<tr>
<td><a href="#utassert.eqtable">utAssert.eqtable</a></td>

<td><a href="#utassert.eqtable">Check Equality of Database Tables</a></td>
</tr>

<tr>
<td><a href="#utassert.eqtabcount">utAssert.eqtabcount</a></td>

<td><a href="#utassert.eqtabcount">Check Equality of Table Counts</a></td>
</tr>

<tr>
<td><a href="#eqquery">utAssert.eqquery</a></td>

<td><a href="#eqquery">Check Equality of Queries</a></td>
</tr>

<tr>
<td><a href="#eqqueryvalue">utAssert.eqqueryvalue</a></td>

<td><a href="#eqqueryvalue">Check Equality of Query against single value</a></td>
</tr>

<tr>
<td><a href="#utassert.eqfile">utAssert.eqfile</a></td>

<td><a href="#utassert.eqfile">Check Equality of Files</a></td>
</tr>

<tr>
<td><a href="#utassert.eqpipe">utAssert.eqpipe</a></td>

<td><a href="#utassert.eqpipe">Check Equality of Database Pipes</a></td>
</tr>

<tr>
<td><a href="#utassert.eqcoll">utAssert.eqcoll</a>
<br><a href="#utassert.eqcoll">utAssert.eqcollapi</a></td>

<td><a href="#utassert.eqcoll">Check Equality of Collections</a></td>
</tr>

<tr>
<td><a href="#throws">utAssert.throws</a></td>

<td><a href="#throws">Check a procedure or function throws an exception</a></td>
</tr>
</table>

 

The utAssert package provides a set of assertion
routines ("assert that the following condition is true") that you will
use to register the outcome of a test case. You must call a utAssert assertion
program after (or containing) a test case so that the results of that test
can be recorded and then reported. See <a href="buildpack.html">Build
Test Packages</a> for many examples and more details on this process. Here
is a very simple example, though, to give you an idea of the code you would
write:

<pre>   PROCEDURE ut_BETWNSTR IS
   BEGIN
      utAssert.eq (
         'Typical valid usage',
         BETWNSTR(
            STRING_IN => 'abcdefg'
            ,
            START_IN => 3
            ,
            END_IN => 5
            ),
         'cde'
         );
   END;</pre>

utAssert offers a wide (and ever expanding) set
of assertion programs that allow you to efficiently (a) test the outcome
of your unit test and (b) report the results of that test to utPLSQL. You
should review <a href="#utassert-common">Common Assertion Parameters and
Behavior</a> before using any specific assertion program. It is also possible
to <a href="#utassert-BYOA">build your own assertion routine.</a>

Note: all utAssert assertions are defined in the
ut_assertion table, as well as actually coded in the utAssert package.

<h2>
<a name="utassert-common"></a>Common Assertion Parameters and Behavior</h2>

Each type of assertion routine accepts different
kinds of data, but there are lots of similarities between the assertions,
as well.

Here is an explanation of the common assertion parameters:

<table cellpadding="0" border="BORDER" width="714" cellspacing="0">
<tr>
<td width="151" valign="TOP">
msg_in
</td>

<td width="532" valign="TOP">
A message
to be displayed if the assertion fails. This is the first argument and
is mandatory, because the tests need to be self documenting.
</td>
</tr>

<tr>
<td width="151" valign="TOP">
check_this_in
</td>

<td width="532" valign="TOP">
The value
to be checked.. If a Boolean expression, this will usually include the
invocation of the method being tested, resulting in a single line of code
for the entire test case.
</td>
</tr>

<tr>
<td width="151" valign="TOP">
against_this_in
</td>

<td width="532" valign="TOP">
For assert_eq,
the assertion routine will check the check_this_in value against the against_this_in
value. This parameter should be the certifiably correct value.
</td>
</tr>

<tr>
<td width="151" valign="TOP">
null_ok_in
</td>

<td width="532" valign="TOP">
TRUE if
a NULL value should be interpreted as a successful test, FALSE if NULL
indicates failure.
</td>
</tr>

<tr>
<td width="151" valign="TOP">
raise_exc_in
</td>

<td width="532" valign="TOP">
TRUE if
it is OK for the assertion routine to allow an exception to be propagated
out unhandled.
</td>
</tr>
</table>

<h2>
<a name="Showresults"></a>Showing Results Immediately</h2>
You can request that utPLSQL display results immediately after running
the assertion program. The default behavior is that utAssert will simply
pass the results to utResult for later processing. You might want to see
results immediately if you are building your own small testing script and
are not calling utPLSQL.test.
<p>To request results immediately, call the showResults procedure:
<pre>   PROCEDURE utAssert.showresults;</pre>
This a session-level setting, and must be reset each time you connect to
Oracle. You can turn off showing of results by calling the noShowResults
program:
<pre>   PROCEDURE utAssert.noshowresults;</pre>
To determine the current status of this setting, you can call the following
function:
<pre>   FUNCTION utAssert.showing_results return boolean;</pre>
Here is an example of a simple script that calls an assertion routine and
immediately shows the results:
<pre>set serveroutput on size 1000000
BEGIN
   utAssert.showresults;
   utAssert.eq (
      'Test of betwn',      
      str.betwn ('this is a string', 3, 7),      
      'this is a pipe'      );
END;
/</pre>
And here is the result of running this script:
<pre>FAILURE: "Unnamed Test"
: Test of betwn; expected "this is a pipe", got "is is"</pre>

<h2>
<a name="utassert.this"></a>Generic "Assert This" Assertion Procedure</h2>

This most generic assertion program simply says
"assert this" and passes a Boolean expression. It is used by all the other
assertion routines, which <i>construct</i> a Boolean expression from their
specific values and logic.

<pre>   PROCEDURE utAssert.this (</pre>

<pre>      msg_in IN VARCHAR2,</pre>

<pre>      check_this_in IN BOOLEAN,</pre>

<pre>      null_ok_in IN BOOLEAN := FALSE,</pre>

<pre>      raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>   );</pre>

Use utAssert.this when you have a Boolean expression
that you want to check, as in:.

<pre>BEGIN</pre>

<pre>   ...</pre>

<pre>   utAssert.this (</pre>

<pre>      'Boolean function result',</pre>

<pre>      is_valid_account (my_account)</pre>

<pre>      );</pre>

You can also use this assertion to register a failure,
most usually in an exception section, as in:

<pre>EXCEPTION</pre>

<pre>   WHEN OTHERS</pre>

<pre>   THEN
      utAssert.this (</pre>

<pre>         SQLERRM,</pre>

<pre>         FALSE);</pre>

Generally, you should avoid utAssert.this and instead
use a specialized assertion routine, documented below. Most of the assertions
give you the ability check for equality (of scalars, such as strings, or
more complex data structures like tables, pipes and files): does the data
generated by my code match the expected value(s)?

<h2>
<a name="utassert.isnull"></a>Check for NULL and NOT NULL Values</h2>

You can check to see if a value is NULL or is NOT
NULL with the following assertions:

<pre>PROCEDURE utAssert.isnotnull (
   msg_in IN VARCHAR2,
   check_this_in IN VARCHAR2,
   null_ok_in IN BOOLEAN := FALSE,
   raise_exc_in IN BOOLEAN := FALSE
);

PROCEDURE utAssert.isnull (
   msg_in IN VARCHAR2,
   check_this_in IN VARCHAR2,
   null_ok_in IN BOOLEAN := FALSE,
   raise_exc_in IN BOOLEAN := FALSE
);

PROCEDURE utAssert.isnotnull (
   msg_in IN VARCHAR2,
   check_this_in IN BOOLEAN,
   null_ok_in IN BOOLEAN := FALSE,
   raise_exc_in IN BOOLEAN := FALSE
);

PROCEDURE utAssert.isnull (
   msg_in IN VARCHAR2,
   check_this_in IN BOOLEAN,

   null_ok_in IN BOOLEAN := FALSE,
   raise_exc_in IN BOOLEAN := FALSE
);</pre>

Use these assertions when
you simply want to check if a scalar expression (string, date, number and
Boolean are supported) is NULL or NOT NULL, as in:

<br> 
<br> 
<pre>BEGIN</pre>

<pre>   ...</pre>

<pre>   utAssert.isNULL (</pre>

<pre>      'Should be nothing left',</pre>

<pre>      TRANSLATE (digits_in_string, 'A1234567890', 'A')</pre>

<pre>      );</pre>

<h2>
<a name="utassert.eq"></a>Check Equality of Scalar Values</h2>
If you need to compare two dates or two strings or two numbers or two Booleans,
use the utAssert.eq assertion program.

<p>Here is the header for the scalar equality check assertion:
<pre>PROCEDURE utAssert.eq (</pre>

<pre>   msg_in IN VARCHAR2,</pre>

<pre>   check_this_in IN VARCHAR2|BOOLEAN|DATE|NUMBER,</pre>

<pre>   against_this_in IN VARCHAR2|BOOLEAN|DATE|NUMBER,</pre>

<pre>   null_ok_in IN BOOLEAN := FALSE,</pre>

<pre>   raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>);</pre>

If the two values are equal, your code gets a green
light. Otherwise, utAssert writes the test results to the utResult package,
resulting in a red light for the test.

If NULL values are considered value for this test,
pass TRUE for null_ok_in. If you want the assertion to raise an exception
on failure and stop the test from proceeding, pass TRUE for raise_exc_in.

Here is an example of using the utAssert.eq program:

<pre>   PROCEDURE ut_emp_dept_lookuprowcount
   IS</pre>

<pre>      l_rowcount1 PLS_INTEGER;
      l_rowcount2 PLS_INTEGER;
   BEGIN
      -- Run baseline code.
      SELECT COUNT (*)
        INTO l_rowcount1
        FROM employee
       WHERE department_id = 30;</pre>

<pre> </pre>

<pre>      -- Compare to program call:
      l_rowcount2 :=
         te_employee.emp_dept_lookuprowcount (30);</pre>

<pre> </pre>

<pre>      -- Test results
      utassert.eq (
         'Successful EMP_DEPT_LOOKUPROWCOUNT',
         l_rowcount2,
         l_rowcount1
      );
   END;</pre>

<h2>
<a name="utassert.eqtable"></a>Check Equality of DatabaseTables</h2>

If your test performs DML operations (update, insert
or delete), you will need to check your results in a database table. You
could do this by querying the results into local variables and then calling
utAssert.eq to check those values against your expected data. That can
be a very laborious process, so utAssert offers the eqtable and equerry
assertion routines to streamline the process.

Both these procedures use the MINUS SQL operator
to essentially "subtract" the contents of one table (query) from the other.
If anything is left, then the two tables (queries) are not the same and
the test is given a red light. As you can probably see, the structure of
the two tables (queries) must be identical for this assertion to work properly.

The utAssert.eqtable allows you to compare the contents
of your data table (changed by your code) against another table, which
you can preset with the data you expect to see after the test. Here is
the header for eqtable:

<pre>PROCEDURE utAssert.eqtable (</pre>

<pre>   msg_in IN VARCHAR2,</pre>

<pre>   check_this_in IN VARCHAR2,</pre>

<pre>   against_this_in IN VARCHAR2,</pre>

<pre>   check_where_in IN VARCHAR2 := NULL,</pre>

<pre>   against_where_in IN VARCHAR2 := NULL,</pre>

<pre>   raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>);</pre>

where check_this_in and against_this_in are the
names of tables or views. You can supply an optional WHERE clause to restrict
the rows you wish to compare. Here is an example that calls eqTable twice,
to test two different conditions.

<pre>PROCEDURE ut_del1
IS
   fdbk PLS_INTEGER;
BEGIN
   /* Delete that finds now rows. */

   EXECUTE IMMEDIATE '
   DELETE FROM ut_DEL1
    WHERE employee_id = -1
   ';
   te_employee.del (-1, rowcount_out => fdbk);</pre>

<pre>   -- Test results
   utassert.eqtable ('Delete rows', 'EMPLOYEE', 'ut_DEL1');
   /* Successful delete */

   EXECUTE IMMEDIATE '
      DELETE FROM ut_DEL1
       WHERE employee_id between 7800 and 7899
      ';

   FOR rec IN (SELECT *
                 FROM employee
                WHERE employee_id BETWEEN 7800 AND 7899)
   LOOP
      te_employee.del (
         rec.employee_id,
         rowcount_out => fdbk
      );
   END LOOP;

   -- Test results
   utassert.eqtable ('Delete rows', 'EMPLOYEE', 'ut_DEL1');
   ROLLBACK;
EXCEPTION
   WHEN OTHERS
   THEN
      utassert.this (
         'DEL1 exception ' || SQLERRM,
         SQLCODE = 0
      );
END;</pre>

<h2>
<a name="utassert.eqtabcount"></a>Check Equality of Table Counts</h2>
If your tests simply produce the right number of rows in a table but not
a fixed set of values, you will not be able to use <a href="#utassert.eqtable">utAssert.eqtable</a>
above.  However, utAssert.eqtabcount allows you to simply test that
the numbers of rows are equal.  The declaration of the procedure is
as follows:
<pre>PROCEDURE utAssert.eqtabcount (</pre>

<pre>   msg_in IN VARCHAR2,</pre>

<pre>   check_this_in IN VARCHAR2,</pre>

<pre>   against_this_in IN VARCHAR2,</pre>

<pre>   check_where_in IN VARCHAR2 := NULL,</pre>

<pre>   against_where_in IN VARCHAR2 := NULL,</pre>

<pre>   raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>);</pre>

where check_this_in and against_this_in are the
names of tables or views. As in utAssert.eqtable, you can supply an optional
WHERE clause to restrict the rows you wish to compare. The following test
will compare the number of rows in the CD_COLLECTION and UT_TEST_5_1 tables
where the given condition holds:
<pre>utassert.eqtabcount('Test 5.1: Insert new rows',</pre>

<pre>                    'CD_COLLECTION',</pre>

<pre>                    'UT_TEST_5_1',</pre>

<pre>                    'ARTIST = ''The Fall''',</pre>

<pre>                    'ARTIST = ''The Fall''');</pre>


<h2>
<a name="eqquery"></a>Asserting Query Equality</h2>

The utAssert.eqquery allows you to compare the data
returned by two queries (strings that are contained in the check_this_in
and against_this_in parameters). In this case, you specify the full SELECT
statements for each query as the parameters. By using equery, you may be
able to avoid constructing a separate table with preset data.

<pre>PROCEDURE utAssert.eqquery (</pre>

<pre>   msg_in IN VARCHAR2,</pre>

<pre>   check_this_in IN VARCHAR2,</pre>

<pre>   against_this_in IN VARCHAR2,</pre>

<pre>   raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>);</pre>

If you want the assertion to raise an exception
on failure and stop the test from proceeding, pass TRUE for raise_exc_in.

Here is an example of using eqQuery:

<pre>PROCEDURE ut_upd1
IS
BEGIN
   /* Update 3 columns by ID */

   EXECUTE IMMEDIATE '
   UPDATE ut_UPD1 SET
      FIRST_NAME = ''SILLY'',
      HIRE_DATE = trunc (SYSDATE+100),
      COMMISSION = 5000
    WHERE
       EMPLOYEE_ID = 7600
   ';
   te_employee.upd (
      7600,
      first_name_in => 'SILLY',
      commission_in => 5000,
      hire_date_in => TRUNC (SYSDATE + 100),
      rowcount_out => fdbk
   );
   -- Test results (audit fields are different so do a query)
   utassert.eqquery (
      'Update three columns',
      'select first_name, commission, hire_date from EMPLOYEE',
      'select first_name, commission, hire_date from ut_upd1'
   );
   ROLLBACK;
END;</pre>

<h2>
<a name="eqqueryvalue"></a>Check Query Equality against a Single Value</h2>
Often we will wish to test the result of a query against a single value
rather than another query as in <a href="#eqquery">utAssert.eqquery</a>
above.  It is possible to get around this problem by using a trivial
query of the form:
<pre>SELECT <i>fixed_value
</i>FROM DUAL;</pre>
Unfortunately, if the query returns multiple values or the wrong value
we will only be told that the test has failed with no details.  This
is where utAssert.eqqueryvalue comes to the rescue.  The procedure
is declared as follows:
<pre>PROCEDURE utAssert.eqqueryvalue (</pre>

<pre>      msg_in IN VARCHAR2,</pre>

<pre>      check_query_in IN VARCHAR2,</pre>

<pre>      against_value_in IN VARCHAR2|NUMBER|DATE,</pre>

<pre>      raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>);</pre>
Where check_query_in is the query in question and against_value_in is the
value to check it against.  If the query returns more than one value,
the resulting error message will tell you this.  Similarly, if the
query returns the wrong value, the message will state the expected and
obtained values.  The following call compares the maximum value found
in a table against a given number value:
<pre>utAssert.eqqueryvalue('Maximum value test',</pre>

<pre>                      'SELECT MAX(MEMORY)</pre>

<pre>                       FROM COMPUTERS</pre>

<pre>                       WHERE OS IN (''Linux'', ''Unix'')',</pre>

<pre>                       256);</pre>
Obviously this should only return a single value, but if it returns something
other than 256, we'll know about it.
<h2>
<a name="utassert.eqfile"></a>Check Equality of Files</h2>

Many programs generate output to operating system
files; alternatively, you might write data to a file simply to test results.
Use the eqfile assertion for either of these scenarios. This procedure
uses PL/SQL's UTL_FILE package to compare the contents of two different
files.

Note: If you have not used UTL_FILE in the past,
you must <a href="admin.html#UTL_FILE">configure</a> it before it can be
used -- by utPLSQL or by your own code. UTL_FILE must be allowed accss
to either or both of the directories you specify (this involves setting
the utl_file_dir database parameter).

<pre>PROCEDURE utAssert.eqfile (</pre>

<pre>   msg_in IN VARCHAR2,</pre>

<pre>   check_this_in IN VARCHAR2,</pre>

<pre>   check_this_dir_in IN VARCHAR2,</pre>

<pre>   against_this_in IN VARCHAR2,</pre>

<pre>   against_this_dir_in IN VARCHAR2 := NULL,</pre>

<pre>   raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>);</pre>

If you want the assertion to raise an exception
on failure and stop the test from proceeding, pass TRUE for raise_exc_in.

You must specify the directory containing the "check
this" file; if you do not specify a directory for the "against this" file,
the "check this" directory will be used.

Here is an example of using eqFile (see ut_DEPARTMENT2file.pkg
in the Examples directory for the full implementation):

<pre>PROCEDURE ut_DEPARTMENT2FILE IS
BEGIN
   DEPARTMENT2FILE (
      LOC => 'c:\temp',
      FILE => 'department.dat',
      DELIM => '***'
    );

   utAssert.eqfile (
      'Test of DEPARTMENT2FILE',
      'department.dat',
      'c:\temp',
      'department.tst',
      'c:\temp'
      );      
END ut_DEPARTMENT2FILE;</pre>

<h2>
<a name="utassert.eqpipe"></a>Check Equality of Database Pipes</h2>

Database pipes offer a handy mechanism for passing
data between different sessions connected to the RDBMS. It is important
to know that pipes are being filled properly; use the eqpipe to check this
condition.

With the eqpipe procedure, you compare the contents
of two different pipes.

<pre>PROCEDURE utAssert.eqpipe (</pre>

<pre>   msg_in IN VARCHAR2,</pre>

<pre>   check_this_in IN VARCHAR2,</pre>

<pre>   against_this_in IN VARCHAR2,</pre>

<pre>   raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>);</pre>

If you want the assertion to raise an exception
on failure and stop the test from proceeding, pass TRUE for raise_exc_in.

To check the contents of a pipe based on the execution
of code, you will need to populate a pipe against which to test equality.
The employee_pipe.pkg file in the Examples directory contains a demonstration
of the kind of code you might write to do this.

This package contains all of the unit test code
within the same package. Here is my unit test program, which relies on
the utAssert.eqpipe program:

<pre>PROCEDURE ut_fillpipe IS
   stat PLS_INTEGER;
BEGIN
   emptypipe ('emps');
   emptypipe ('emps2');
   
   fillpipe ('emps');
   
   /* Direct filling of pipe. */
   
   FOR rec IN (SELECT *
                 FROM employee)
   LOOP
      DBMS_PIPE.RESET_BUFFER;
      DBMS_PIPE.PACK_MESSAGE (rec.EMPLOYEE_ID);
      DBMS_PIPE.PACK_MESSAGE (rec.LAST_NAME);
      DBMS_PIPE.PACK_MESSAGE (rec.FIRST_NAME);
      DBMS_PIPE.PACK_MESSAGE (rec.MIDDLE_INITIAL);
      DBMS_PIPE.PACK_MESSAGE (rec.JOB_ID);
      DBMS_PIPE.PACK_MESSAGE (rec.MANAGER_ID);
      DBMS_PIPE.PACK_MESSAGE (rec.HIRE_DATE);
      DBMS_PIPE.PACK_MESSAGE (rec.SALARY);
      DBMS_PIPE.PACK_MESSAGE (rec.COMMISSION);
      DBMS_PIPE.PACK_MESSAGE (rec.DEPARTMENT_ID);
      DBMS_PIPE.PACK_MESSAGE (rec.CHANGED_BY);
      DBMS_PIPE.PACK_MESSAGE (rec.CHANGED_ON);

      stat := DBMS_PIPE.SEND_MESSAGE ('emps2', 0);
   END LOOP;
   
<b>   /* Compare the two */
   utassert.eqpipe (
      'Two employee pipes', 'emps', 'emps2');
</b>      
END ut_fillpipe;</pre>

Since I have stored my unit
test logic with my source code package, I would run my test as follows:

<pre>SQL> exec utplsql.test ('employee_pipe', samepackage_in=>TRUE)
FAILURE: "employee_pipe"
fillpipe: Pipes equal? Compared "emps" against "emps2"</pre>

<h2>
<a name="utassert.eqcoll"></a>Check Equality of Collections</h2>

Collections are as close as you come to arrays in
PL/SQL. They are very useful for managing lists of information, but can
be difficult to debug and maintain.

With the eqcoll and eqcollAPI procedures, you can
compare the contents of two different arrays. Use the eqColl procedure
when you want to compare two collections that are defined in the specification
of a package. Use the eqCollAPI procedure when you want to compare two
collections that are defined in the body of a package, with programs defined
in the specification (an API) to access and manipulate the collections.

The collection equality check headers are:

<pre>   /* Direct access to collections */</pre>

<pre>   PROCEDURE utAssert.eqcoll (</pre>

<pre>      msg_in IN VARCHAR2,</pre>

<pre>      check_this_in IN VARCHAR2, /* pkg1.coll */</pre>

<pre>      against_this_in IN VARCHAR2, /* pkg2.coll */</pre>

<pre>      eqfunc_in IN VARCHAR2 := NULL,</pre>

<pre>      check_startrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      check_endrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      against_startrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      against_endrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      match_rownum_in IN BOOLEAN := FALSE,</pre>

<pre>      null_ok_in IN BOOLEAN := TRUE,</pre>

<pre>      raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>   );</pre>

<pre>  </pre>

<pre>   /* API based access to collections */</pre>

<pre>   PROCEDURE utAssert.eqcollapi (</pre>

<pre>      msg_in IN VARCHAR2,</pre>

<pre>      check_this_pkg_in IN VARCHAR2,</pre>

<pre>      against_this_pkg_in IN VARCHAR2,</pre>

<pre>      eqfunc_in IN VARCHAR2 := NULL,</pre>

<pre>      countfunc_in IN VARCHAR2 := 'COUNT',</pre>

<pre>      firstrowfunc_in IN VARCHAR2 := 'FIRST',</pre>

<pre>      lastrowfunc_in IN VARCHAR2 := 'LAST',</pre>

<pre>      nextrowfunc_in IN VARCHAR2 := 'NEXT',</pre>

<pre>      getvalfunc_in IN VARCHAR2 := 'NTHVAL',</pre>

<pre>      check_startrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      check_endrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      against_startrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      against_endrow_in IN PLS_INTEGER := NULL,</pre>

<pre>      match_rownum_in IN BOOLEAN := FALSE,</pre>

<pre>      null_ok_in IN BOOLEAN := TRUE,</pre>

<pre>      raise_exc_in IN BOOLEAN := FALSE</pre>

<pre>   );</pre>

where the eqcoll-specific parameters are as follows:

<table cellpadding="0" border="BORDER" cellspacing="0">
<tr>
<td><b>Parameter</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td width="102" valign="TOP">
msg_in
</td>

<td width="561" valign="TOP">
The message to be displayed if the test failes
</td>
</tr>

<tr>
<td width="102" valign="TOP">
check_this_in
</td>

<td width="561" valign="TOP">
The name of the collection to be checked. Format:
package.collection. In other words, the collection must be defined in a
package specification. Use eqCollAPI (and check_this_pkg_in) if you want
to hide the declaration of your collection in your package body (recommended).
</td>
</tr>

<tr>
<td width="102" valign="TOP">
against_this_in
</td>

<td width="561" valign="TOP">
The name of the collection to be checked against.
Format: package.collection. In other words, the collection must be defined
in a package specification. Use eqCollAPI (and check_this_pkg_in) if you
want to hide the declaration of your collection in your package body (recommended).
</td>
</tr>
</table>


<p>and the eqcollAPI-specific parameters are as follows:
<br> 
<table cellpadding="0" border="BORDER" cellspacing="0">
<tr>
<td><b>Parameter</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td width="122" valign="TOP">
msg_in
</td>

<td width="541" valign="TOP">
The message to be displayed if the test failes
</td>
</tr>

<tr>
<td width="122" valign="TOP">
check_this_pkg_in
</td>

<td width="541" valign="TOP">
The name of the package that contains the collection
to be checked.
</td>
</tr>

<tr>
<td width="122" valign="TOP">
against_this_pkg_in
</td>

<td width="541" valign="TOP">
The name of the package that contains the collection
to be checked against.
</td>
</tr>

<tr>
<td width="122" valign="TOP">
countfunc_in
</td>

<td width="541" valign="TOP">
The name of the function in the package that returns
the number of rows defined in the collection.
</td>
</tr>

<tr>
<td width="122" valign="TOP">
firstrowfunc_in
</td>

<td width="541" valign="TOP">
The name of the function in the package that returns
the first definedrow in the collection.
</td>
</tr>

<tr>
<td width="122" valign="TOP">
lastrowfunc_in
</td>

<td width="541" valign="TOP">
The name of the function in the package that returns
the last definedrow in the collection.
</td>
</tr>

<tr>
<td width="122" valign="TOP">
nextrowfunc_in
</td>

<td width="541" valign="TOP">
The name of the function in the package that returns
the next definedrow in the collection
from the specified row.
</td>
</tr>

<tr>
<td width="122" valign="TOP">
getvalfunc_in
</td>

<td width="541" valign="TOP">
The name of the function in the package that returns
the contents of the specified row.
</td>
</tr>
</table>


<p>The parameters common to both eqColl and eqCollAPI
are as follows
<br> 
<table cellpadding="0" border="BORDER" cellspacing="0">
<tr>
<td><b>Parameter</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td width="158" valign="TOP">
eqfunc_in
</td>

<td width="504" valign="TOP">
The function used to determine if the contents of
each row of the two collections are the same. If you pass NULL for this
argument, then a standard equality check will be used. This is fine for
scalar values, but will not work, for example, with tables of records.
</td>
</tr>

<tr>
<td width="158" valign="TOP">
check_startrow_in
</td>

<td width="504" valign="TOP">
The starting row in the check collection for comparison.
If NULL, then first row is used.
</td>
</tr>

<tr>
<td width="158" valign="TOP">
check_endrow_in
</td>

<td width="504" valign="TOP">
The ending row in the check collection for comparison.
If NULL, then last row is used.
</td>
</tr>

<tr>
<td width="158" valign="TOP">
against_startrow_in
</td>

<td width="504" valign="TOP">
The starting row in the against collection for comparison.
If NULL, then first row is used.
</td>
</tr>

<tr>
<td width="158" valign="TOP">
against_endrow_in
</td>

<td width="504" valign="TOP">
The ending row in the against collection for comparison.
If NULL, then last row is used.
</td>
</tr>

<tr>
<td width="158" valign="TOP">
match_rownum_in
</td>

<td width="504" valign="TOP">
Pass TRUE if you want to make sure that the same
row numbers are used in each collection. If FALSE, then the row numbers
can be different, but the contents of each corresponding row must be the
same.
</td>
</tr>

<tr>
<td width="158" valign="TOP">
null_ok_in
</td>

<td width="504" valign="TOP">
Pass TRUE if the assertion routine should consider
two NULL collections to be equal.
</td>
</tr>

<tr>
<td width="158" valign="TOP">
raise_exc_in
</td>

<td width="504" valign="TOP">
If you want the assertion to raise an exception
on failure and stop the test from proceeding, pass TRUE for raise_exc_in.
</td>
</tr>
</table>


<p>Here is an example of a script that uses utAssert.eqColl
(taken from filepath1.pkg in the Examples directory):
<pre>PROCEDURE ut_setpath
IS
BEGIN
   /* Populate base collection */
   ut_dirs.DELETE;
   ut_dirs.EXTEND(2);
   ut_dirs(1) := 'c:\temp';
   ut_dirs(2) := 'e:\demo';
   
   /* Call setpath to do the work */
   setpath ('c:\temp;e:\demo');
   
   utAssert.eqColl (
      'Valid double entry',
      'fileio.dirs',
      'fileio.ut_dirs'
      );
END;</pre>

<h2>
<a name="throws"></a>Checking a Procedure or Function throws an exception</h2>
Sometimes we design a procedure or function to throw an exception under
certain circumstances.  This is something we'd like to be able to
test for.  Obviously this is not particularly easy due to the way
exceptions propagate through the call stack.  If we simply call the
procedure in our test code, the exception will have no chance of being
caught within the utAssert package!  Therefore, we need to pass the
tested call in to the package as a string.  The procedure utAssert.throws
allows us to do this:
<pre>PROCEDURE throws (</pre>

<pre>      msg_in VARCHAR2,</pre>

<pre>      check_call_in IN VARCHAR2,</pre>

<pre>      against_exc_in IN VARCHAR2|NUMBER</pre>

<pre>   );</pre>
Where check_call_in is the call to be made, complete with parameters and
terminating semicolon.  The argument against_exc_in is the exception
we expect to be thrown.  This can be specified either as a named exception,
or a SQLCODE value.
<p>The following example shows both usages:
<pre>/* Test the Except Function */
PROCEDURE ut_except
IS
BEGIN

   /* Call the procedure with a negative number */
   /* We expect a NO_DATA_FOUND exception       */
   utAssert.throws('Negative Number',
      'Except(-1);',
      'NO_DATA_FOUND'
   );
   
   /* Call the procedure with zero and a string    */
   /* over 2 in length - We expect a SQLCODE of -1 */  
   utAssert.throws('Zero and String',
      'Except(0, ''Hello'');',
      -1
     );
END;</pre>

Note how we have to quote
the string parameters to the call and terminate the string with a semicolon.

<h2>
<a name="utassert-BYOA"></a>Building Your Own Assertion</h2>

You may want to build assertion routines that fit
your specific needs. If PL/SQL supported inheritance, you could extend
the utAssert assertion routines and then customize them through polymorphism.
Lacking this feature, however, you will write your own procedures that
follow the same steps as the pre-build assertions.

In order to integrate the results of your assertion
test into the utResult package, you will want to mimic the utAssert.this
procedure. Here is its current implementation (Release 1.3.2); check the
body of the utAssert package for any changes.

<pre>PROCEDURE this (
   msg_in IN VARCHAR2,
   check_this_in IN BOOLEAN,
   null_ok_in IN BOOLEAN := FALSE,
   raise_exc_in IN BOOLEAN := FALSE,
   register_in IN BOOLEAN := TRUE
   )
IS
BEGIN
   IF    NOT check_this_in
      OR (    check_this_in IS NULL
          AND NOT null_ok_in)
   THEN
      IF register_in
      THEN</pre>

<pre>         -- Registers the results in the utResult databank.
         utresult.report (msg_in);
      ELSE
         utplsql.pl (msg_in);
      END IF;
      
      IF showing_results AND register_in
      THEN</pre>

<pre>         -- Show the results of the test more recently run.
         utresult.showlast;
      END IF;

      IF raise_exc_in
      THEN
         RAISE test_failure;
      END IF;
   END IF;
END;</pre>

The most important statement to include in your
assertion routine is the call to utResult.report, which will log the results
of the test.

<!-- End utPLSQL Body -->
</body>
</html>
