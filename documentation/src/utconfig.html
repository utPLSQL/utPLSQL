<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head><title></title></head><body>
<!-- Begin utPLSQL Body -->
<!-- $Id$ -->
<h1>
utConfig Package</h1>

<p>This package contains the following functions and procedures:
<br> 
<table cellspacing="5">
<tr>
<td width="25%"><a href="#Whoseconfig">utConfig.tester</a></td>

<td><a href="#Whoseconfig">Return whose configuration is used</a></td>
</tr>

<tr>
<td><a href="#setconfig">utConfig.settester</a></td>

<td><a href="#setconfig">Set whose configuration is used</a></td>
</tr>

<tr>
<td><a href="utconfig.html#Showconfig">utConfig.showconfig</a></td>

<td><a href="utconfig.html#Showconfig">View a schema's configuration</a></td>
</tr>

<tr>
<td><a href="#Setdir">utConfig.setdir</a></td>

<td><a href="#Setdir">Set the directory containing the test package code</a></td>
</tr>

<tr>
<td><a href="#dir">utConfig.dir</a></td>

<td><a href="#dir">Return the directory containing the test package code</a></td>
</tr>

<tr>
<td><a href="#Setprefix">utConfig.setprefix</a></td>

<td><a href="#Setprefix">Set the default unit test prefix for your code</a></td>
</tr>

<tr>
<td><a href="#prefix">utConfig.prefix</a></td>

<td><a href="#prefix">Return the default unit test prefix for your code</a></td>
</tr>

<tr>
<td><a href="#Manualregister">utConfig.registertest</a></td>

<td><a href="#Manualregister">Set the registration mode (manual or automatic)</a></td>
</tr>

<tr>
   <td><a href="#Manualregister">utConfig.registering</a></td>

<td><a href="#Manualregister">Return the registration mode</a></td>
</tr>

<tr>
<td><a href="#Autocompile">utConfig.autocompile</a></td>

<td><a href="#Autocompile">Set autocompile feature</a></td>
</tr>

<tr>
   <td><a href="#Autocompile">utConfig.autocompiling</a></td>

   <td><a href="#Autocompile">Return the autocompile flag</a></td>
</tr>

<tr>
<td><a href="#Delimiter">utConfig.setdelimiter</a></td>

<td><a href="#Delimiter">Set the V2 delimiter</a></td>
</tr>

<tr>
   <td><a href="#Delimiter">utConfig.delimiter</a></td>

   <td><a href="#Delimiter">Return the V2 delimiter</a></td>
</tr>

<tr>
   <td><a href="fileout.html#setgetfile">utConfig.setfile </a></td>
   <td><a href="fileout.html#setgetfile">Sets file output TRUE or FALSE</a></td>
</tr>

<tr>
   <td><a href="fileout.html#setgetfile">utConfig.getfile </a></td>
   <td><a href="fileout.html#setgetfile">Return whether file output is being used</a></td>
</tr>


<tr>
   <td><a href="fileout.html#setfiledir">utConfig.setfiledir</a></td>
   <td><a href="fileout.html#setfiledir">Set the directory for the file output</a></td>
</tr>   

<tr>
   <td><a href="fileout.html#setfiledir">utConfig.filedir</a></td>
   <td><a href="fileout.html#setfiledir">Return which directory is used for file output</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename1">utConfig.setuserprefix</a></td>
   <td><a href="fileout.html#filename1">Set the user prefix for the output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename1">utConfig.userprefix</a></td>
   <td><a href="fileout.html#filename1">Return the user prefix for the output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename2">utConfig.setincludeprogname</a></td>
   <td><a href="fileout.html#filename2">Set whether to include the name of the program being tested in the output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename2">utConfig.includeprogname</a></td>
   <td><a href="fileout.html#filename2">Return whether to include the name of the program being tested in the output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename3">utConfig.setdateformat</a></td>
   <td><a href="fileout.html#filename3">Set the date format for the date portion of the output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename3">utConfig.dateformat</a></td>
   <td><a href="fileout.html#filename3">Return the date format used to construct output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename4">utConfig.setfileextension</a></td>
   <td><a href="fileout.html#filename4">Set the file extension for the output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#filename4">utConfig.fileextension</a></td>
   <td><a href="fileout.html#filename4">Return the file extension used for the output file name</a></td>
</tr>

<tr>
   <td><a href="fileout.html#allinone">utConfig.setfileinfo</a></td>
   <td><a href="fileout.html#allinone">Set all of the above file output related items </a></td>
</tr>

<tr>
   <td><a href="fileout.html#allinone">utConfig.fileinfo</a></td>
   <td><a href="fileout.html#allinone">Return all of the above file output related items</a></td>
</tr>

</table>

<p>To make it as easy as possible for you to run your tests, utPLSQL stores
various pieces of configuration data in the ut_config table. This data
is stored by schema name and is automatically loaded into utPLSQL the first
time you use this utility in your session. This configuration information
is also automatically updated whenever you call utPLSQL.test -- or any
of the utPLSQL programs specifically designed to change the configuration
settings.
<p>You can at any time view the utPLSQL configuration for the currently-connected
schema or for another schema (there is not at this point any schema-level
security; all utPLSQL users can view the configurations of all other users).
<p>The data that is currently maintained for a utPLSQL user are:
<p><b>Test package directory</b> - the location of the test package code
you want to run. You must specify a directory in order to allow utPLSQL
to automatically compile your test packages before each test run.
<p><b>Unit test prefix</b> - the prefix used for test package names and
the program names within the package. If you do not specify a prefix, the
default of "ut_" is automatically applied.
<p><b>Unit test registration mod</b>e - This setting determines whether
utPLSQL will automatically identify the unit tests to be run (strongly
recommended) or if you have chosen to manually register your unit tests
in the test package setup procedure.
<p><b>Auto-compilation of test packages</b> - By default, utPLSQL will
recompile your test package before execution. You can turn off this feature
and manually recompile only when you desire (a fine idea if your test package
has gotten very large!).
<h2>
<a name="Whoseconfig"></a>Return whose configuration is being used</h2>
By default, the configuration stored for the currently-connected user will
be used.  However, it is possible to use configurations stored against
other usernames.  To show whose configuration is currently being used
the following function is used:
<pre>FUNCTION utConfig.tester RETURN VARCHAR2;</pre>

<h2>
<a name="setconfig"></a>Set whose configuration is being used</h2>
This returns the configuration that will be used whenever a username is
not specified.  To set this, the following procedure is used:
<pre>PROCEDURE utConfig.settester (username_in IN VARCHAR2 := USER);</pre>

<h2>
<a name="Showconfig"></a>View a schema's configuration</h2>
Call the utconfig.showconfig procedure to view the configuration for a specified
schema. The header is:
<pre>PROCEDURE utConfig.showconfig (username_in IN VARCHAR2 := NULL);</pre>
If you do not specify a schema, then the <a href="#Whoseconfig">currently
used</a> configuration is returned. Here is an example of output from this
procedure:
<pre>SQL&gt; exec utconfig.showconfig
=============================================================
utPLSQL Configuration for SCOTT
   Directory: /apps/utplsql/code
   Autcompile? Y
   Manual test registration? N
   Prefix = test_
=============================================================</pre>
And here is an example of calling showConfig for a different schema:
<pre>SQL&gt; exec utconfig.showconfig ('COMP')
=============================================================
utPLSQL Configuration for COMP
   Directory: M:\shared_apps\utplsql\comp
   Autcompile? N
   Manual test registration? N
   Prefix = ut_
=============================================================</pre>
You might want to put a call to showConfig in your SQL*Plus login file
so that you are reminded on startup as to what the current settings are.
Here is such a script (to be found in Examples\login_sample.sql):
<pre>exec utconfig.setdir ('e:\openoracle\utplsql\utinstall\examples')
SET SERVEROUTPUT ON SIZE 1000000 FORMAT WRAPPED
exec utconfig.showconfig</pre>

<h2>
<a name="Setdir"></a>Set the directory containing the test package code</h2>
If you want utPLSQL to compile your test package, you must tell it the
directory in which your code is found. You can do this either when you
<a href="defsuite.html">define
your test suite</a> and packages within the suite, or you can call the
utConfig.setdir procedure to set the directory for your current session.
<p>Note: as of v1.5.1, the value you pass in any of these programs is saved
in the configuration table and will be used in the future -- until you
change it by passing a different value.
<p>The header for this procedure is:
<pre>PROCEDURE utConfig.setdir (dir_in IN VARCHAR2, username_in IN VARCHAR2 := NULL);</pre>
where dir_in is the directory and username_in is the name of the schema
to which this directory applies (NULL means the <a href="#Whoseconfig">currently
used</a> configuration is set), as in:
<pre>SQL&gt; exec utconfig.setdir ('e:\demo\utplsql');</pre>
or, with the specification of a non-current schema:
<pre>SQL&gt; exec utconfig.setdir ('e:\demo\utplsql', 'ANALYSIS');</pre>
Note that this directory must be accessible through UTL_FILE.
<p>You might consider putting the the call to utConfig.setdir into your
login.sql so that it is run automatically, each time your start up SQL*Plus
-- if you are always working from the same directory.
<h2>
<a name="dir"></a>Return the directory containing the test package code</h2>
You can obtain the current directory with a call to utConfig.dir:
<pre>FUNCTION utConfig.dir (username_in IN VARCHAR2 := NULL)
      RETURN VARCHAR2;</pre>

<h2>
<a name="Setprefix"></a>Set the default unit test prefix for your code.</h2>
The unit test prefix is very important in utPLSQL; the utility uses the
prefix to associate source code to be tested with the test package. The
prefix also allows utPLSQL to automatically identify the programs within
a test package that are to be executed as unit tests.
<p>The default prefix in utPLSQL is "ut_", but you can override this when
you call utPLSQL.test or by calling the utConfig.setprefix procedure:
<pre>PROCEDURE utConfig.setPrefix (
   prefix_in IN VARCHAR2, username_in IN VARCHAR2 := NULL)</pre>
where prefix_in is the prefix and username_in is the name of the schema
to which this prefix applies (NULL means the <a href="#Whoseconfig">currently
used</a> configuration is set), as in:
<pre>SQL&gt; exec utconfig.setPrefix ('tst#');</pre>
or, with the specification of a non-current schema:
<pre>SQL&gt; exec utconfig.setPrefix ('t_', 'ANALYSIS');</pre>

<h2>
<a name="prefix"></a>Return the default unit test prefix for your code.</h2>
You can obtain the current prefix with a call to utConfig.prefix:
<pre>FUNCTION utConfig.prefix (username_in IN VARCHAR2 := NULL)
      RETURN VARCHAR2;</pre>
uPLSQL currently does not support the use of a suffix, or combination of
suffix and prefix, to identify test packages and unit test procedures.
<h2>
<a name="Manualregister"></a>Set the registration mode (manual or automatic).</h2>
As of utPLSQL v1.5.1, you no longer have to register your unit test procedures
in the setup procedure of your test package. Instead, utPLSQL will scan
the data dictionary (via theALL_ARGUMENTS view) for the names of all the
unit test procedures you have defined, and then run them. utPLSQL identifies
these programs by looking for all programs whose names start with the specified
prefix.
<p>If you so choose, you can request that utPLSQL turn off automatic detection
of unit test procedures and only run those programs listed in the setup
procedure. To do this, you call the utConfig.registerTest procedure:
<pre>PROCEDURE utConfig.registerTest (
      onoff_in IN BOOLEAN,
      username_in IN VARCHAR2 := NULL
   );</pre>
as in:
<pre>SQL&gt; exec utConfig.registerTest (TRUE)</pre>
Note: if you are using automatic unit test detection, any calls to utPLSQL.addtest
in the setup procedure <i><b>will be ignored</b>.</i>

<p>You can return the current registration mode using the following function:
<pre>FUNCTION registeringtest (username_in IN VARCHAR2 := NULL)
   RETURN BOOLEAN;</pre>
This returns TRUE if the registration mode has been set to manual and FALSE otherwise.
</p>

<h2>
<a name="Autocompile"></a>Set autocompile feature</h2>

The default settings for utPLSQL is to re-compile
your base package before each unit test. This guarantees that any recent
changes will be tested. It also saves you the step of doing an explicit
compile.

In order to perform automatic compilation:

<ul type="disc">
Your schema will need to
have either CREATE PROCEDURE or CREATE ANY PROCEDURE privileges granted
<i>directly</i>;
you cannot grant these privileges through roles.

You will need to set or
pass the location of the source code. You can do this by calling <a href="#Setdir">utConfig.setdir</a>
or by including the directory location in your call to <a href="utplsql.html#utplsql.test">utPLSQL.test</a>
or <a href="utplsql.html#utplsql.testsuite">utPLSQL.testsuite</a> (the dir_in
parameter).

The package specification
must be contained in a file named &lt;package&gt;.pks; the body must be stored
in &lt;package&gt;.pkb.

You must have configured
the
<a href="admin.html#UTL_FILE">UTL_FILE</a> built-in package for use
on your database instance.
</ul>

In general (and the default), you should allow your
test package to be recompiled with each execution. You might want to avoid
recompilation if:

<ul>
You have made a copy of the package body with some
temporary changes and already compiled that. If you recompile automatically,
you will wipe out those changes.

You have not set up UTL_FILE
and you don't want to deal with it.

You are running the tests
on a server to which you have no access other than via a database connection.
</ul>

<h3>
Turning off Auto-compile</h3>

If you are working with products like SQL*Navigator,
you may be always editing from code stored in the database. In this case,
you will never want to have utPLSQL recompile your code for you – it will
already be compiled and you do not need to hassle with UTL_FILE.

You can avoid auto-recompilation in two ways:

1. Pass a value of FALSE for the recompile_in argument
to utPLSQL.test or utPLSQL.testsuite. Here is an example:

<pre>BEGIN</pre>

<pre>   -- Define a test suite for PL/Vision</pre>

<pre>   utsuite.add ('PLVision');</pre>

<pre>  </pre>

<pre>   -- Add two packages for testing</pre>

<pre>   utsuite.addpkg (</pre>

<pre>      'PLVision', 'PLVstr', dir_in =&gt; 'e:\utplsql');</pre>

<pre>   utsuite.addpkg (</pre>

<pre>      'PLVision', 'PLVdate', dir_in =&gt; 'e:\utplsql');</pre>

<pre>  </pre>

<pre>   -- Run the test suite</pre>

<pre>   utplsql.testsuite (</pre>

<pre>      'PLVision', recompile_in =&gt; FALSE);</pre>

<pre>END;</pre>

<pre>/</pre>

If you know that you will <i>never</i> want to recompilation,
however, you can set the default behavior at the schema level by calling
the autocompile procedure

<pre>   PROCEDURE utConfig.autocompile (</pre>

<pre>      onoff_in IN BOOLEAN,</pre>

<pre>      username_in IN VARCHAR2 := NULL</pre>

<pre>   );</pre>

<pre> </pre>

So I can make the following
call to turn off autocompilation for the SCOTT schema:

<br> 
<br> 
<pre>SQL&gt; exec utconfig.autocompile (FALSE, 'SCOTT') </pre>
This program updates the ut_config table with your information and then
commits the setting.

<p>You can determine the current
setting for auto-compilation at any time by calling the following function:
<pre></pre>

<pre>   FUNCTION utConfig.autocompiling (username_in IN VARCHAR2 := NULL)</pre>

<pre>      RETURN BOOLEAN;</pre>

Note: When you set the schema-level recompilation
value to FALSE, that will override anything you pass in a call to utPLSQL.test
or utPLSQL.testsuite.

<h2>
   <a name="Delimiter"></a>V2 Delimiter</h2>
<p> You can set the delimiter to be used in V2 procedure names using the following procedure:
<pre>PROCEDURE setdelimiter (
  delimiter_in IN VARCHAR2, 
  username_in IN VARCHAR2 := NULL
); </pre>
while the current delimiter can be obtained by the function:
<pre>FUNCTION delimiter (username_in IN VARCHAR2 := NULL)
  RETURN VARCHAR2;</pre>
</p>
<!-- End utPLSQL Body -->
</body>
</html>
