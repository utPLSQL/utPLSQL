{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction to utPLSQL\n\n\nutPLSQL is a Unit Testing framework for Oracle PL/SQL.\nThe framework follows industry standards and best patterns of modern Unit Testing frameworks like \nJUnit\n and \nRSpec\n\n\n\n\nUser Guide\n\n\nInstallation\n\n\nGetting Started\n\n\nAnnotations\n\n\nExpectations\n\n\nRunning unit tests\n\n\nUsing the ut_run script\n\n\nTesting best pracitces\n\n\nUpgrade utPLSQL\n\n\n\n\n\n\nReporting\n\n\nUsing reporters\n\n\nReporting errors\n\n\nCode coverage\n\n\n\n\n\n\nAbout\n\n\nProject Details\n\n\nLicense\n\n\nSupport\n\n\nAuthors\n\n\nContributing\n\n\n\n\n\n\n\n\nThree steps\n\n\nWith just three simple steps you can define and run your unit tests for PLSQL code.\n\n\n\n\nInstall the utPLSQL framework \n\n\nCreate Unit Tests to for the code\n\n\nRun the tests\n\n\n\n\nHere is how you can simply create tested code, unit tests and execute the tests using SQL Developer\n\n\n\n\nCheck out the sections on \nannotations\n and \nexpectations\n to see how to define your tests.  \n\n\nCommand line\n\n\nThe \nut_run.sql\n script is a powerful thing - it can provide output from the tests on the fly.\nYou can also use it to have coloured output from the test, and if you try to test code that was dropper, all of unit tests related to that code will fail.\n\n\n\n\nLook into \nut_run.sql script options\n to see more.\n\n\nCoverage\n\n\nIf you want to have code coverage gathered on your code , it's best to use \nut_run.sql\n to execute your tests with multiple reporters and have both test execution report as well as coverage report saved to a file.\nCheck out the \ncoverage documentation\n for options of coverage reporting", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#introduction-to-utplsql", 
            "text": "utPLSQL is a Unit Testing framework for Oracle PL/SQL.\nThe framework follows industry standards and best patterns of modern Unit Testing frameworks like  JUnit  and  RSpec   User Guide  Installation  Getting Started  Annotations  Expectations  Running unit tests  Using the ut_run script  Testing best pracitces  Upgrade utPLSQL    Reporting  Using reporters  Reporting errors  Code coverage    About  Project Details  License  Support  Authors  Contributing", 
            "title": "Introduction to utPLSQL"
        }, 
        {
            "location": "/index.html#three-steps", 
            "text": "With just three simple steps you can define and run your unit tests for PLSQL code.   Install the utPLSQL framework   Create Unit Tests to for the code  Run the tests   Here is how you can simply create tested code, unit tests and execute the tests using SQL Developer   Check out the sections on  annotations  and  expectations  to see how to define your tests.", 
            "title": "Three steps"
        }, 
        {
            "location": "/index.html#command-line", 
            "text": "The  ut_run.sql  script is a powerful thing - it can provide output from the tests on the fly.\nYou can also use it to have coloured output from the test, and if you try to test code that was dropper, all of unit tests related to that code will fail.   Look into  ut_run.sql script options  to see more.", 
            "title": "Command line"
        }, 
        {
            "location": "/index.html#coverage", 
            "text": "If you want to have code coverage gathered on your code , it's best to use  ut_run.sql  to execute your tests with multiple reporters and have both test execution report as well as coverage report saved to a file.\nCheck out the  coverage documentation  for options of coverage reporting", 
            "title": "Coverage"
        }, 
        {
            "location": "/userguide/install/index.html", 
            "text": "Installation\n\n\nTo simply install the utPLSQL into a new database schema and grant it to public, execute the script \ninstall_headless.sql\n.\n\n\nThis will create a new user \nUT3\n with password \nUT3\n, grant all needed privileges to that user and create PUBLIC synonyms needed to sue the utPLSQL framework.\n\n\nExample invocation of the script from command line:\n\n\ncd source\nsqlplus admin/admins_password@xe @@install_headless.sql  \n\n\n\n\nRecommended Schema\n\n\nIt is recommended to install utPLSQL in it's own schema. You are free to choose any name for this schema.\n\n\nThe installation user/schema must have the following Oracle system permissions during the installation.\n  - CREATE SESSION\n  - CREATE PROCEDURE\n  - CREATE TYPE\n  - CREATE TABLE\n  - CREATE VIEW\n  - CREATE SYNONYM\n  - ALTER SESSION\n\n\nIn addition it must be granted execute to the following system packages.\n\n\n\n\nDBMS_LOCK\n\n\n\n\nThe utPLSQL is using Oracle \nDBMS_PROFILER tables\n. The tables will be created in the installation schema if they do not exist.\nThe uninstall process however will not drop those tables, as they can potentially be shared and reused for profiling PLSQL code.\nIt is up to DBA to maintain the storage of the profiler tables.\n\n\nInstallation Procedure\n\n\nCreating schema for utPLSQL\n\n\nTo create the utPLSQL schema and grant all the needed privileges execute script \ncreate_utplsql_owner.sql\n from the \nsource\n directory with parameters:\n- \nuser name\n - the name of the user that will own of utPLSQL object\n- \npassword\n  - the password to be set for that user\n- \ntablespace name\n - the tablespace name to hold data created during test execution\n\n\nExample invocation of the script from command line:\n\n\ncd source\nsqlplus admin/admins_password@xe @@create_utPLSQL_owner.sql ut3 ut3 users  \n\n\n\n\nInstalling utPLSQL\n\n\nTo install the utPLSQL sources into your database run the \n/source/install.sql\n script and provide the \nschema name\n where utPLSQL is to be installed\n\nYou need to install the utPLSQL sources into a already existing database schema.\nYou may install it from any account that has sufficient privileges to create objects in other users schema.\nYou may also choose to install it directly into the schema owning the package.  \n\n\nExample invocation of the script from command line:\n\n\ncd source\nsqlplus admin/admins_password@xe @@install.sql ut3  \n\n\n\n\nAllowing other users to access utPLSQL framework\n\n\nIn order to allow other users to access utPLSQL, synonyms must be created and grants need to be added.\nYou have two options:\n- use public grants and synonyms, to allow any user to access the framework\n- use synonyms and grants for individual users to limit the access the the framework\n\n\nTo grant utPLSQL to public execute the script \nsource/create_synonyms_and_grants_for_public.sql\n and provide the provide \nschema name\n where utPLSQL is installed \n\n\nExample invocation of the script from command line:\n\n\ncd source\nsqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_public.sql ut3  \n\n\n\n\nTo grant utPLSQL to individual user execute the script \nsource/create_synonyms_and_grants_for_user.sql\n and provide provide the \nschema name\n where utPLSQL is installed and \nuser name\n to be granted\n\n\nExample invocation of the script from command line:\n\n\ncd source\nsqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_user.sql ut3 hr  \n\n\n\n\nThe following tools that support the SQL\nPlus commands can be used to run the installation script\n  - SQL\nPlus\n  - \nSQLcl\n\n  - \nOracle SQL Developer\n\n\nUninstalling utPLSQL\n\n\nTo uninstall run \n/source/uninstall.sql\n and provide the provide \nschema name\n where utPLSQL is installed.\n\n\nThe uninstall script will remove all the objects installed by the install script.\nAdditionally, all the public and private synonyms pointing to the objects in utPLSQL schema will be removed.\n\n\nIf you have you have extended any utPLSQL types such as a custom reporter, these will need to be dropped before the uninstall, otherwise the uninstall script might fail.\n\n\nIn order for the uninstall to be successful, you need to use the uninstall script, that was provided wht the exact version that was installed on your database.", 
            "title": "Installation"
        }, 
        {
            "location": "/userguide/install/index.html#installation", 
            "text": "To simply install the utPLSQL into a new database schema and grant it to public, execute the script  install_headless.sql .  This will create a new user  UT3  with password  UT3 , grant all needed privileges to that user and create PUBLIC synonyms needed to sue the utPLSQL framework.  Example invocation of the script from command line:  cd source\nsqlplus admin/admins_password@xe @@install_headless.sql", 
            "title": "Installation"
        }, 
        {
            "location": "/userguide/install/index.html#recommended-schema", 
            "text": "It is recommended to install utPLSQL in it's own schema. You are free to choose any name for this schema.  The installation user/schema must have the following Oracle system permissions during the installation.\n  - CREATE SESSION\n  - CREATE PROCEDURE\n  - CREATE TYPE\n  - CREATE TABLE\n  - CREATE VIEW\n  - CREATE SYNONYM\n  - ALTER SESSION  In addition it must be granted execute to the following system packages.   DBMS_LOCK   The utPLSQL is using Oracle  DBMS_PROFILER tables . The tables will be created in the installation schema if they do not exist.\nThe uninstall process however will not drop those tables, as they can potentially be shared and reused for profiling PLSQL code.\nIt is up to DBA to maintain the storage of the profiler tables.", 
            "title": "Recommended Schema"
        }, 
        {
            "location": "/userguide/install/index.html#installation-procedure", 
            "text": "", 
            "title": "Installation Procedure"
        }, 
        {
            "location": "/userguide/install/index.html#creating-schema-for-utplsql", 
            "text": "To create the utPLSQL schema and grant all the needed privileges execute script  create_utplsql_owner.sql  from the  source  directory with parameters:\n-  user name  - the name of the user that will own of utPLSQL object\n-  password   - the password to be set for that user\n-  tablespace name  - the tablespace name to hold data created during test execution  Example invocation of the script from command line:  cd source\nsqlplus admin/admins_password@xe @@create_utPLSQL_owner.sql ut3 ut3 users", 
            "title": "Creating schema for utPLSQL"
        }, 
        {
            "location": "/userguide/install/index.html#installing-utplsql", 
            "text": "To install the utPLSQL sources into your database run the  /source/install.sql  script and provide the  schema name  where utPLSQL is to be installed \nYou need to install the utPLSQL sources into a already existing database schema.\nYou may install it from any account that has sufficient privileges to create objects in other users schema.\nYou may also choose to install it directly into the schema owning the package.    Example invocation of the script from command line:  cd source\nsqlplus admin/admins_password@xe @@install.sql ut3", 
            "title": "Installing utPLSQL"
        }, 
        {
            "location": "/userguide/install/index.html#allowing-other-users-to-access-utplsql-framework", 
            "text": "In order to allow other users to access utPLSQL, synonyms must be created and grants need to be added.\nYou have two options:\n- use public grants and synonyms, to allow any user to access the framework\n- use synonyms and grants for individual users to limit the access the the framework  To grant utPLSQL to public execute the script  source/create_synonyms_and_grants_for_public.sql  and provide the provide  schema name  where utPLSQL is installed   Example invocation of the script from command line:  cd source\nsqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_public.sql ut3    To grant utPLSQL to individual user execute the script  source/create_synonyms_and_grants_for_user.sql  and provide provide the  schema name  where utPLSQL is installed and  user name  to be granted  Example invocation of the script from command line:  cd source\nsqlplus admin/admins_password@xe @@create_synonyms_and_grants_for_user.sql ut3 hr    The following tools that support the SQL Plus commands can be used to run the installation script\n  - SQL Plus\n  -  SQLcl \n  -  Oracle SQL Developer", 
            "title": "Allowing other users to access utPLSQL framework"
        }, 
        {
            "location": "/userguide/install/index.html#uninstalling-utplsql", 
            "text": "To uninstall run  /source/uninstall.sql  and provide the provide  schema name  where utPLSQL is installed.  The uninstall script will remove all the objects installed by the install script.\nAdditionally, all the public and private synonyms pointing to the objects in utPLSQL schema will be removed.  If you have you have extended any utPLSQL types such as a custom reporter, these will need to be dropped before the uninstall, otherwise the uninstall script might fail.  In order for the uninstall to be successful, you need to use the uninstall script, that was provided wht the exact version that was installed on your database.", 
            "title": "Uninstalling utPLSQL"
        }, 
        {
            "location": "/userguide/getting-started/index.html", 
            "text": "Getting Started\n\n\nTODO: A quick guide to writing your first unit test.  This should not get into all the options available instead it should link to that documentation where it is appropriate.    This really should be a high level look at the product.   It should take the point of view of someone who has never written a unit test in any language.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/userguide/getting-started/index.html#getting-started", 
            "text": "TODO: A quick guide to writing your first unit test.  This should not get into all the options available instead it should link to that documentation where it is appropriate.    This really should be a high level look at the product.   It should take the point of view of someone who has never written a unit test in any language.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/userguide/annotations/index.html", 
            "text": "Annotations\n\n\nAnnotations provide a way to configure tests and suites in a declarative way similar to modern OOP languages. This way th behavior of tests stored along with the test logic, versioned using VCS with the code under test. No configuration files or tables are needed. The annotation list is based on popular testing frameworks such as jUnit 5 and RSpec.\nThe framework runner searches for all the suitable annotated packages, automatically configures suites, forms suites hierarchy, executes it and reports results in differet formats.\n\n\nAnnotations are case-insensitive. But it is recommended to use the lower-case standard as described in the documentation.\n\n\nThere are two places where annotations may appear: at the beginning of the package specification (\n%suite\n, \n%suitepath\n etc) and right before a procedure (\n%test\n, \n%beforeall\n, \n%beforeeach\n etc). Package level annotations are separated by at least one empty line from the following procedure annotations. Procedure annotetions are defined right before the procedure they reference, no empty lines allowed.\n\n\nIf a package conatins \n%suite\n annotation in its specification part it is treated as a test package and processed by the framework.\n\n\nSome annotations accept parameters like \n%suite\n, \n%test\n \n%displayname\n, then the values are provided without any quatation marks, parameters are separated by commas.\n\n\nExample of annotated test package\n\n\ncreate or replace package test_pkg is\n\n  -- %suite(Name of suite)\n  -- %suitepath(all.globaltests)\n\n  -- %beforeall\n  procedure globalsetup;\n\n  -- %afterall\n  procedure global_teardown;\n\n  /* Such comments are allowed */\n\n  -- %test\n  -- %displayname(Name of test1)\n  procedure test1;\n\n  -- %test(Name of test2)\n  -- %beforetest(setup_test1)\n  -- %aftertest(teardown_test1)\n  procedure test2;\n\n  -- %test\n  -- %displayname(Name of test3)\n  -- %disabled\n  procedure test3;\n\n  -- %test(Name of test4)\n  -- %rollback(manual)\n  procedure test4;\n\n  procedure setup_test1;\n\n  procedure teardown_test1;\n\n  -- %beforeeach\n  procedure setup;\n\n  -- %aftereach\n  procedure teardown;\n\nend test_pkg;\n\n\n\n\nAnnotations description\n\n\n\n\n\n\n\n\nAnnotation\n\n\nLevel\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n%suite(\ndescription\n)\n\n\nPackage\n\n\nMarks package to be a suite of tests This way all testing packages might be found in a schema. Optional schema discription can by provided, similar to \n%displayname\n annotation.\n\n\n\n\n\n\n%suitepath(\npath\n)\n\n\nPackage\n\n\nSimilar to java package. The annotation allows logical grouping of suites into hierarchies.\n\n\n\n\n\n\n%displayname(\ndescription\n)\n\n\nPackage/procedure\n\n\nHuman-familiar description of the suite/test. Syntax is based on jUnit annotation: \n%displayname(Name of the suite/test)\n\n\n\n\n\n\n%test(\ndescription\n)\n\n\nProcedure\n\n\nDenotes that a method is a test method.  Optional test description can by provided, similar to \n%displayname\n annotation.\n\n\n\n\n\n\n%beforeall\n\n\nProcedure\n\n\nDenotes that the annotated procedure should be executed once before all elements of the current suite.\n\n\n\n\n\n\n%afterall\n\n\nProcedure\n\n\nDenotes that the annotated procedure should be executed once after all elements of the current suite.\n\n\n\n\n\n\n%beforeeach\n\n\nProcedure\n\n\nDenotes that the annotated procedure should be executed before each \n%test\n method in the current suite.\n\n\n\n\n\n\n%aftereach\n\n\nProcedure\n\n\nDenotes that the annotated procedure should be executed after each \n%test\n method in the current suite.\n\n\n\n\n\n\n%beforetest(\nprocedure_name\n)\n\n\nProcedure\n\n\nDenotes that mentioned procedure should be executed before the annotated \n%test\n procedure.\n\n\n\n\n\n\n%aftertest(\nprocedure_name\n)\n\n\nProcedure\n\n\nDenotes that mentioned procedure should be executed after the annotated \n%test\n procedure.\n\n\n\n\n\n\n%rollback(\ntype\n)\n\n\nPackage/procedure\n\n\nConfigure transaction control behaviour (type). Supported values: \nauto\n(default) - A savepoint is created before invocation of each \"before block\" is and a rollback to specific savepoint is issued after each \"after\" block; \nmanual\n - rollback is never issued automatically. Property can be overridden for child element (test in suite)\n\n\n\n\n\n\n%disabled\n\n\nPackage/procedure\n\n\nUsed to disable a suite or a test\n\n\n\n\n\n\n\n\nUsing automatic rollbacks in tests\n\n\nBy default, every test is isolated from other tests using savepoint.\nThis solution is suitable for use-cases, where the code that is getting tested as well as the unit tests themselves do not use transaction control commands (commit/rollback).\nIn general, your unit tests should not use transaction control as long as the core you are testing is not using it too.\nKeeping the transactions uncommitted allows your changes to be isolated and the execution of tests is not impacting others that might be using a shared (integration) development database.\n\n\nIf however you're in situation, where the code you are testing, is using transaction control (like ETL code is usually doing), then your tests should not use the default rollback(auto)\nYou should make sure that thr entire suitepath all the way to the root is using manual transaction control in that case.\n\n\nIn some cases it is needed to perform DDL in setup/teardown. It is recommended to move such DDL statements to a procedure with pragma autonomous_transaction to eliminate implicit commit of the main session.\n\n\nSuitepath concept\n\n\nIt is very likely that the application for which you are going to introduce tests consists of many different packages or procedures/functions. Usually procedures can be logically grouped inside a package, there also might be several logical groups of procedure in a single package or even packages themselves might relate to a common module.\n\n\nLets say you have a complex insurance application the operates with policies, claims and payments. The payment module contains several packages for payment recognition, charging, planning etc. The payment recognition module among others contains a complex \nrecognize_payment\n procedure that associates received money to the policies.\n\n\nIf you want to create tests for your application it is recommended to structure your tests similarly to the logical structure of you application. So you end up with something like:\n* Integration tests\n  *   Policy tests\n  *   Claim tests\n  *   Payment tests\n    * Payments recognition \n    * Payments set off\n    * Payouts \n\n\nThe \n%suitepath\n annotation is used for such grouping. Even though test packages are defined in a flat structure the \n%suitepath\n is used by the framework to form a hierarchical structure of them. Your payments recognition test package might look like:\n\n\ncreate or replace package test_payment_recognition as\n\n  -- %suite(Payment recognition tests)\n  -- %suitepath(payments)\n\n  -- %test(Recognize payment by policy number)\n  procedure test_recognize_by_num;\n\n  -- %test\n  -- %displayname(Recognize payment by payment purpose)\n  procedure test_recognize_by_purpose;\n\n  -- %test(Recognize payment by customer)\n  procedure test_recognize_by_customer;\n\nend test_payment_recognition;\n\n\n\n\nAnd payments set off test package:\n\n\ncreate or replace package test_payment_set_off as\n\n  -- %suite(Payment set off tests)\n  -- %suitepath(payments)\n\n  -- %test(Set off creation test)\n  procedure test_create_set_off;\n\n  -- %test\n  -- %displayname(Set off annulation test)\n  procedure test_annulate_set_off;\n\nend test_payment_set_off;\n\n\n\n\nWhen you execute tests for your application, the framework constructs test suite for each test package. Then in combines suites into grouping suites by the \n%suitepath\n annotation value so that the fully qualified path to the \nrecognize_by_num\n procedure is \nUSER:payments.test_payment_recognition.test_recognize_by_num\n. If any of its expectations fails then the test is marked as failed, also the \ntest_payment_recognition\n suite, the parent suite \npayments\n and the whole run is marked as failed.\nThe test report indicates which expectation has failed on the payments module. The payments recognition submodule is causing the failure as \nrecognize_by_num\n has is not meeting the expectations of the test. Grouping tests into modules and submodules using the \n%suitepath\n annotation allows you to logically organize your projects flat structure of packages int functional groups. \n\n\nAdditional advantage of such grouping is the fact that every element level of the grouping can be an actual unit test package containing module level common setup for all of the submodules. So in addition to the packages mentioned above you could have following package.\n\n\ncreate or replace package payments as\n\n  -- %suite(Payments)\n\n  -- %beforeall\n  procedure set_common_payments_data;\n\n  -- %afterall\n  procedure reset_common_paymnets_data;\n\nend payments;\n\n\n\n\nA \n%suitepath\n can be provided in tree ways:\n\n schema - execute all test in the schema\n\n [schema]:suite1[.suite2][.suite3]...[.procedure] - execute all tests in all suites from suite1[.suite2][.suite3]...[.procedure] path. If schema is not provided, then current schema is used. Example: \n:all.rooms_tests\n.\n* [schema.]package[.procedure] - execute all tests in the test package provided. The whole hierarchy of suites in the schema is build before, all before/after hooks of partn suites for th provided suite package are executed as well. Example: \ntests.test_contact.test_last_name_validator\n or simply \ntest_contact.test_last_name_validator\n if \ntests\n is the current schema.", 
            "title": "Annotations"
        }, 
        {
            "location": "/userguide/annotations/index.html#annotations", 
            "text": "Annotations provide a way to configure tests and suites in a declarative way similar to modern OOP languages. This way th behavior of tests stored along with the test logic, versioned using VCS with the code under test. No configuration files or tables are needed. The annotation list is based on popular testing frameworks such as jUnit 5 and RSpec.\nThe framework runner searches for all the suitable annotated packages, automatically configures suites, forms suites hierarchy, executes it and reports results in differet formats.  Annotations are case-insensitive. But it is recommended to use the lower-case standard as described in the documentation.  There are two places where annotations may appear: at the beginning of the package specification ( %suite ,  %suitepath  etc) and right before a procedure ( %test ,  %beforeall ,  %beforeeach  etc). Package level annotations are separated by at least one empty line from the following procedure annotations. Procedure annotetions are defined right before the procedure they reference, no empty lines allowed.  If a package conatins  %suite  annotation in its specification part it is treated as a test package and processed by the framework.  Some annotations accept parameters like  %suite ,  %test   %displayname , then the values are provided without any quatation marks, parameters are separated by commas.", 
            "title": "Annotations"
        }, 
        {
            "location": "/userguide/annotations/index.html#example-of-annotated-test-package", 
            "text": "create or replace package test_pkg is\n\n  -- %suite(Name of suite)\n  -- %suitepath(all.globaltests)\n\n  -- %beforeall\n  procedure globalsetup;\n\n  -- %afterall\n  procedure global_teardown;\n\n  /* Such comments are allowed */\n\n  -- %test\n  -- %displayname(Name of test1)\n  procedure test1;\n\n  -- %test(Name of test2)\n  -- %beforetest(setup_test1)\n  -- %aftertest(teardown_test1)\n  procedure test2;\n\n  -- %test\n  -- %displayname(Name of test3)\n  -- %disabled\n  procedure test3;\n\n  -- %test(Name of test4)\n  -- %rollback(manual)\n  procedure test4;\n\n  procedure setup_test1;\n\n  procedure teardown_test1;\n\n  -- %beforeeach\n  procedure setup;\n\n  -- %aftereach\n  procedure teardown;\n\nend test_pkg;", 
            "title": "Example of annotated test package"
        }, 
        {
            "location": "/userguide/annotations/index.html#annotations-description", 
            "text": "Annotation  Level  Description      %suite( description )  Package  Marks package to be a suite of tests This way all testing packages might be found in a schema. Optional schema discription can by provided, similar to  %displayname  annotation.    %suitepath( path )  Package  Similar to java package. The annotation allows logical grouping of suites into hierarchies.    %displayname( description )  Package/procedure  Human-familiar description of the suite/test. Syntax is based on jUnit annotation:  %displayname(Name of the suite/test)    %test( description )  Procedure  Denotes that a method is a test method.  Optional test description can by provided, similar to  %displayname  annotation.    %beforeall  Procedure  Denotes that the annotated procedure should be executed once before all elements of the current suite.    %afterall  Procedure  Denotes that the annotated procedure should be executed once after all elements of the current suite.    %beforeeach  Procedure  Denotes that the annotated procedure should be executed before each  %test  method in the current suite.    %aftereach  Procedure  Denotes that the annotated procedure should be executed after each  %test  method in the current suite.    %beforetest( procedure_name )  Procedure  Denotes that mentioned procedure should be executed before the annotated  %test  procedure.    %aftertest( procedure_name )  Procedure  Denotes that mentioned procedure should be executed after the annotated  %test  procedure.    %rollback( type )  Package/procedure  Configure transaction control behaviour (type). Supported values:  auto (default) - A savepoint is created before invocation of each \"before block\" is and a rollback to specific savepoint is issued after each \"after\" block;  manual  - rollback is never issued automatically. Property can be overridden for child element (test in suite)    %disabled  Package/procedure  Used to disable a suite or a test", 
            "title": "Annotations description"
        }, 
        {
            "location": "/userguide/annotations/index.html#using-automatic-rollbacks-in-tests", 
            "text": "By default, every test is isolated from other tests using savepoint.\nThis solution is suitable for use-cases, where the code that is getting tested as well as the unit tests themselves do not use transaction control commands (commit/rollback).\nIn general, your unit tests should not use transaction control as long as the core you are testing is not using it too.\nKeeping the transactions uncommitted allows your changes to be isolated and the execution of tests is not impacting others that might be using a shared (integration) development database.  If however you're in situation, where the code you are testing, is using transaction control (like ETL code is usually doing), then your tests should not use the default rollback(auto)\nYou should make sure that thr entire suitepath all the way to the root is using manual transaction control in that case.  In some cases it is needed to perform DDL in setup/teardown. It is recommended to move such DDL statements to a procedure with pragma autonomous_transaction to eliminate implicit commit of the main session.", 
            "title": "Using automatic rollbacks in tests"
        }, 
        {
            "location": "/userguide/annotations/index.html#suitepath-concept", 
            "text": "It is very likely that the application for which you are going to introduce tests consists of many different packages or procedures/functions. Usually procedures can be logically grouped inside a package, there also might be several logical groups of procedure in a single package or even packages themselves might relate to a common module.  Lets say you have a complex insurance application the operates with policies, claims and payments. The payment module contains several packages for payment recognition, charging, planning etc. The payment recognition module among others contains a complex  recognize_payment  procedure that associates received money to the policies.  If you want to create tests for your application it is recommended to structure your tests similarly to the logical structure of you application. So you end up with something like:\n* Integration tests\n  *   Policy tests\n  *   Claim tests\n  *   Payment tests\n    * Payments recognition \n    * Payments set off\n    * Payouts   The  %suitepath  annotation is used for such grouping. Even though test packages are defined in a flat structure the  %suitepath  is used by the framework to form a hierarchical structure of them. Your payments recognition test package might look like:  create or replace package test_payment_recognition as\n\n  -- %suite(Payment recognition tests)\n  -- %suitepath(payments)\n\n  -- %test(Recognize payment by policy number)\n  procedure test_recognize_by_num;\n\n  -- %test\n  -- %displayname(Recognize payment by payment purpose)\n  procedure test_recognize_by_purpose;\n\n  -- %test(Recognize payment by customer)\n  procedure test_recognize_by_customer;\n\nend test_payment_recognition;  And payments set off test package:  create or replace package test_payment_set_off as\n\n  -- %suite(Payment set off tests)\n  -- %suitepath(payments)\n\n  -- %test(Set off creation test)\n  procedure test_create_set_off;\n\n  -- %test\n  -- %displayname(Set off annulation test)\n  procedure test_annulate_set_off;\n\nend test_payment_set_off;  When you execute tests for your application, the framework constructs test suite for each test package. Then in combines suites into grouping suites by the  %suitepath  annotation value so that the fully qualified path to the  recognize_by_num  procedure is  USER:payments.test_payment_recognition.test_recognize_by_num . If any of its expectations fails then the test is marked as failed, also the  test_payment_recognition  suite, the parent suite  payments  and the whole run is marked as failed.\nThe test report indicates which expectation has failed on the payments module. The payments recognition submodule is causing the failure as  recognize_by_num  has is not meeting the expectations of the test. Grouping tests into modules and submodules using the  %suitepath  annotation allows you to logically organize your projects flat structure of packages int functional groups.   Additional advantage of such grouping is the fact that every element level of the grouping can be an actual unit test package containing module level common setup for all of the submodules. So in addition to the packages mentioned above you could have following package.  create or replace package payments as\n\n  -- %suite(Payments)\n\n  -- %beforeall\n  procedure set_common_payments_data;\n\n  -- %afterall\n  procedure reset_common_paymnets_data;\n\nend payments;  A  %suitepath  can be provided in tree ways:  schema - execute all test in the schema  [schema]:suite1[.suite2][.suite3]...[.procedure] - execute all tests in all suites from suite1[.suite2][.suite3]...[.procedure] path. If schema is not provided, then current schema is used. Example:  :all.rooms_tests .\n* [schema.]package[.procedure] - execute all tests in the test package provided. The whole hierarchy of suites in the schema is build before, all before/after hooks of partn suites for th provided suite package are executed as well. Example:  tests.test_contact.test_last_name_validator  or simply  test_contact.test_last_name_validator  if  tests  is the current schema.", 
            "title": "Suitepath concept"
        }, 
        {
            "location": "/userguide/expectations/index.html", 
            "text": "Concepts\n\n\nValidation of the code under test (the tested logic of procedure/function etc.) is performed by comparing the actual data against the expected data.\nTo do that we use concept of expectation and a matcher to perform the check on the data.\n\n\nIt's best to give an example to get an idea what is what\n\n\nbegin\n  ut.expect( 'the tested value' ).to_( equal('the expected value') );\nend;\n\n\n\n\nExpectation is a set of the expected value(s), actual values(s) and the matcher(s) to run on those values.\n\n\nMatcher is defining the comparison operation to be performed on expected and actual values.\nPseudo-code:\n\n\n  ut.expect( a_actual {data-type} ).to_( {matcher} );\n  ut.expect( a_actual {data-type} ).not_to( {matcher} );\n\n\n\n\nMatchers\n\n\nutPLSQL provides following matchers to perform checks on the expected and actual values.\n\n- \nbe_between\n\n- \nbe_empty\n\n- \nbe_false\n\n- \nbe_greater_than\n\n- \nbe_greater_or_equal\n\n- \nbe_less_or_equal\n\n- \nbe_less_than\n\n- \nbe_like\n\n- \nbe_not_null\n\n- \nbe_null\n\n- \nbe_true\n\n- \nequal\n\n- \nmatch\n\n\nbe_between\n\n\nValidates that the actual value is between the lower and upper bound.\n\n\nExample:\n\n\n  exec ut.expect( a_actual =\n 3 ).to_( be_between( a_lower_bound =\n 1, a_upper_bound =\n 3 ) );\n  exec ut.expect( 3 ).to_( be_between( 1, 3 ) );\n\n\n\n\nbe_empty\n\n\nUnary matcher that validates if the provided data-set is empty.\n\n\nUsage:\n\n\ndeclare\n  l_cursor sys_refcursor;\nbegin\n  open l_cursor for select * from dual where 1 = 0;\n  ut.expect( l_cursor ).to_( be_empty() );\nend;\n\n\n\n\nWhen used with anydata, it is only valid for collection data types.\n\n\nbe_false\n\n\nUnary matcher that validates if the provided value is false.\n\n\nUsage:\n\n\n  exec ut.expect( ( 1 = 0 ) ).to_( be_false() );\n\n\n\n\nbe_greater_or_equal\n\n\nAllows to check if the actual value is greater or equal than the expected.\n\n\nUsage:\n\n\n  exec ut.expect( sysdate ).to_( be_greater_or_equal( sysdate - 1 ) );\n\n\n\n\nbe_greater_than\n\n\nAllows to check if the actual value is greater than the expected.\n\n\nUsage:\n\n\n  exec ut.expect( 2 ).to_( be_greater_than( 1 ) );\n\n\n\n\nbe_less_or_equal\n\n\nAllows to check if the actual value is less or equal than the expected.\n\n\nUsage:\n\n\n  exec ut.expect( 3 ).to_( be_less_or_equal( 3 ) );\n\n\n\n\nbe_less_than\n\n\nAllows to check if the actual value is less than the expected.\n\n\nUsage:\n\n\n  exec ut.expect( 3 ).to_( be_less_than( 2 ) );\n\n\n\n\nbe_like\n\n\nValidates that the actual value is like the expected expression.\n\n\nUsage:\n\n\n  exec ut.expect( 'Lorem_impsum' ).to_( be_like( a_mask =\n '%rem\\_%', a_escape_char =\n '\\' ) );\n  exec ut.expect( 'Lorem_impsum' ).to_( be_like( '%rem\\_%', '\\' ) );\n\n\n\n\nParameters \na_mask\n and \na_escape_char\n represent a valid parameters of the \nOracle like function\n\n\nbe_not_null\n\n\nUnary matcher that validates if the actual value is not null.\n\n\nUsage:\n\n\n  exec ut.expect( to_clob('ABC') ).to_( be_not_null() );\n\n\n\n\nbe_null\n\n\nUnary matcher that validates if the actual value is null.\n\n\nUsage:\n\n\n  exec ut.expect( cast(null as varchar2(100)) ).to_( be_null() );\n\n\n\n\nbe_true\n\n\nUnary matcher that validates if the provided value is false.\n- \nboolean\n\n\nUsage:\n\n\n  exec ut.expect( ( 1 = 1 ) ).to_( be_true() );\n\n\n\n\nequal\n\n\nThe equal matcher is a very restrictive matcher. It only returns true, if compared data-types.\nThat means, that comparing varchar2 to a number will fail even if the varchar2 contains the same number.\nThis matcher is designed to capture changes of data-type, so that if you expect your variable to be number and is now something else,\n the test will fail and give you early indication of potential problem.\n\n\nUsage:\n\n\ndeclare\n  x ref_cursor;\n  y ref_cursor;\nbegin\n  ut.expect( 'a dog' ).to_( equal( 'a dog' ) );\n  ut.expect( a_actual =\n y ).to_( equal( a_expected =\n x, a_nulls_are_equal =\n true ) );\nend;\n\n\n\n\nThe \na_nulls_are_equal\n parameter decides on the behavior of \nnull=null\n comparison (\nthis comparison by default is true!\n)\n\n\nThe \nanydata\n data type is used to compare user defined object and collections.\n\n\nExample usage of anydata to compare user defined types.\n\n\ncreate type department as object(name varchar2(30));\n/\ncreate or replace package demo_dept as \n  -- %suite(demo)\n\n  --%test(demo_dept)\n  procedure test_department; \nend;\n/\n\ncreate or replace package body demo_dept as \n  procedure test_department is\n    v_expected department;\n    v_actual   department;\n  begin\n    v_expected := department('HR');\n    ut.expect( anydata.convertObject(v_expected) ).to_( equal( anydata.convertObject(v_actual) ) );\n  end;\nend;\n/\n\n\n\n\nThis test will fail as the \nv_acutal\n is not equal \nv_expected\n. \n\n\nmatch\n\n\nValidates that the actual value is matching the expected regular expression.\n\n\nUsage:\n\n\n  exec ut.expect( a_actual =\n '123-456-ABcd' ).to_( match( a_pattern =\n '\\d{3}-\\d{3}-[a-z]', a_modifiers =\n 'i' ) );\n  exec ut.expect( 'some value' ).to_( match( '^some.*' ) );\n\n\n\n\nParameters \na_pattern\n and \na_modifiers\n represent a valid regexp pattern accepted by \nOracle regexp_like function\n\n\nSupported data types\n\n\nBelow matrix illustrates the data types supported by different matchers.\n\n\n\n\n\n\n\n\n\n\nbe_between\n\n\nbe_empty\n\n\nbe_false\n\n\nbe_greater_than\n\n\nbe_greater_or_equal\n\n\nbe_less_or_equal\n\n\nbe_less_than\n\n\nbe_like\n\n\nbe_not_null\n\n\nbe_null\n\n\nbe_true\n\n\nequal\n\n\nmatch\n\n\n\n\n\n\n\n\n\n\nanydata\n\n\n\n\nX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\nblob\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\nboolean\n\n\n\n\n\n\nX\n\n\n\n\n\n\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n\n\nclob\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\n\n\ndate\n\n\nX\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\nnumber\n\n\nX\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\nrefcursor\n\n\n\n\nX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\ntimestamp\n\n\nX\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\ntimestamp with timezone\n\n\nX\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\ntimestamp with local timezone\n\n\nX\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\nvarchar2\n\n\nX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\n\n\ninterval year to month\n\n\nX\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\ninterval day to second\n\n\nX\n\n\n\n\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\nX\n\n\n\n\nX\n\n\n\n\n\n\n\n\n\n\nNegating the matcher\n\n\nExpectations provide a very convenient way to check for a negative of the expectation.\n\n\nSyntax of check for matcher evaluating to true:\n\n\n  exec ut.expect( a_actual {data-type} ).to_( {matcher} );\n\n\n\n\nSyntax of check for matcher evaluating to false:\n\n\n  exec ut.expect( a_actual {data-type} ).not_to( {matcher} );\n\n\n\n\nIf a matcher evaluated to NULL, then both \nto_\n and \nnot_to\n will cause the expectation to report failure.\n\n\nExample:\n\n\nbegin\n  ut.expect( null ).to_( be_true() );\n  ut.expect( null ).not_to( be_true() );\nend;\n\n\n\n\nSince NULL is neither true not it is not true, both expectations will report failure.", 
            "title": "Expectations"
        }, 
        {
            "location": "/userguide/expectations/index.html#concepts", 
            "text": "Validation of the code under test (the tested logic of procedure/function etc.) is performed by comparing the actual data against the expected data.\nTo do that we use concept of expectation and a matcher to perform the check on the data.  It's best to give an example to get an idea what is what  begin\n  ut.expect( 'the tested value' ).to_( equal('the expected value') );\nend;  Expectation is a set of the expected value(s), actual values(s) and the matcher(s) to run on those values.  Matcher is defining the comparison operation to be performed on expected and actual values.\nPseudo-code:    ut.expect( a_actual {data-type} ).to_( {matcher} );\n  ut.expect( a_actual {data-type} ).not_to( {matcher} );", 
            "title": "Concepts"
        }, 
        {
            "location": "/userguide/expectations/index.html#matchers", 
            "text": "utPLSQL provides following matchers to perform checks on the expected and actual values. \n-  be_between \n-  be_empty \n-  be_false \n-  be_greater_than \n-  be_greater_or_equal \n-  be_less_or_equal \n-  be_less_than \n-  be_like \n-  be_not_null \n-  be_null \n-  be_true \n-  equal \n-  match", 
            "title": "Matchers"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_between", 
            "text": "Validates that the actual value is between the lower and upper bound.  Example:    exec ut.expect( a_actual =  3 ).to_( be_between( a_lower_bound =  1, a_upper_bound =  3 ) );\n  exec ut.expect( 3 ).to_( be_between( 1, 3 ) );", 
            "title": "be_between"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_empty", 
            "text": "Unary matcher that validates if the provided data-set is empty.  Usage:  declare\n  l_cursor sys_refcursor;\nbegin\n  open l_cursor for select * from dual where 1 = 0;\n  ut.expect( l_cursor ).to_( be_empty() );\nend;  When used with anydata, it is only valid for collection data types.", 
            "title": "be_empty"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_false", 
            "text": "Unary matcher that validates if the provided value is false.  Usage:    exec ut.expect( ( 1 = 0 ) ).to_( be_false() );", 
            "title": "be_false"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_greater_or_equal", 
            "text": "Allows to check if the actual value is greater or equal than the expected.  Usage:    exec ut.expect( sysdate ).to_( be_greater_or_equal( sysdate - 1 ) );", 
            "title": "be_greater_or_equal"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_greater_than", 
            "text": "Allows to check if the actual value is greater than the expected.  Usage:    exec ut.expect( 2 ).to_( be_greater_than( 1 ) );", 
            "title": "be_greater_than"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_less_or_equal", 
            "text": "Allows to check if the actual value is less or equal than the expected.  Usage:    exec ut.expect( 3 ).to_( be_less_or_equal( 3 ) );", 
            "title": "be_less_or_equal"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_less_than", 
            "text": "Allows to check if the actual value is less than the expected.  Usage:    exec ut.expect( 3 ).to_( be_less_than( 2 ) );", 
            "title": "be_less_than"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_like", 
            "text": "Validates that the actual value is like the expected expression.  Usage:    exec ut.expect( 'Lorem_impsum' ).to_( be_like( a_mask =  '%rem\\_%', a_escape_char =  '\\' ) );\n  exec ut.expect( 'Lorem_impsum' ).to_( be_like( '%rem\\_%', '\\' ) );  Parameters  a_mask  and  a_escape_char  represent a valid parameters of the  Oracle like function", 
            "title": "be_like"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_not_null", 
            "text": "Unary matcher that validates if the actual value is not null.  Usage:    exec ut.expect( to_clob('ABC') ).to_( be_not_null() );", 
            "title": "be_not_null"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_null", 
            "text": "Unary matcher that validates if the actual value is null.  Usage:    exec ut.expect( cast(null as varchar2(100)) ).to_( be_null() );", 
            "title": "be_null"
        }, 
        {
            "location": "/userguide/expectations/index.html#be_true", 
            "text": "Unary matcher that validates if the provided value is false.\n-  boolean  Usage:    exec ut.expect( ( 1 = 1 ) ).to_( be_true() );", 
            "title": "be_true"
        }, 
        {
            "location": "/userguide/expectations/index.html#equal", 
            "text": "The equal matcher is a very restrictive matcher. It only returns true, if compared data-types.\nThat means, that comparing varchar2 to a number will fail even if the varchar2 contains the same number.\nThis matcher is designed to capture changes of data-type, so that if you expect your variable to be number and is now something else,\n the test will fail and give you early indication of potential problem.  Usage:  declare\n  x ref_cursor;\n  y ref_cursor;\nbegin\n  ut.expect( 'a dog' ).to_( equal( 'a dog' ) );\n  ut.expect( a_actual =  y ).to_( equal( a_expected =  x, a_nulls_are_equal =  true ) );\nend;  The  a_nulls_are_equal  parameter decides on the behavior of  null=null  comparison ( this comparison by default is true! )  The  anydata  data type is used to compare user defined object and collections.  Example usage of anydata to compare user defined types.  create type department as object(name varchar2(30));\n/\ncreate or replace package demo_dept as \n  -- %suite(demo)\n\n  --%test(demo_dept)\n  procedure test_department; \nend;\n/\n\ncreate or replace package body demo_dept as \n  procedure test_department is\n    v_expected department;\n    v_actual   department;\n  begin\n    v_expected := department('HR');\n    ut.expect( anydata.convertObject(v_expected) ).to_( equal( anydata.convertObject(v_actual) ) );\n  end;\nend;\n/  This test will fail as the  v_acutal  is not equal  v_expected .", 
            "title": "equal"
        }, 
        {
            "location": "/userguide/expectations/index.html#match", 
            "text": "Validates that the actual value is matching the expected regular expression.  Usage:    exec ut.expect( a_actual =  '123-456-ABcd' ).to_( match( a_pattern =  '\\d{3}-\\d{3}-[a-z]', a_modifiers =  'i' ) );\n  exec ut.expect( 'some value' ).to_( match( '^some.*' ) );  Parameters  a_pattern  and  a_modifiers  represent a valid regexp pattern accepted by  Oracle regexp_like function", 
            "title": "match"
        }, 
        {
            "location": "/userguide/expectations/index.html#supported-data-types", 
            "text": "Below matrix illustrates the data types supported by different matchers.      be_between  be_empty  be_false  be_greater_than  be_greater_or_equal  be_less_or_equal  be_less_than  be_like  be_not_null  be_null  be_true  equal  match      anydata   X        X  X   X     blob          X  X   X     boolean    X       X  X  X  X     clob         X  X  X   X  X    date  X    X  X  X  X   X  X   X     number  X    X  X  X  X   X  X   X     refcursor   X        X  X   X     timestamp  X    X  X  X  X   X  X   X     timestamp with timezone  X    X  X  X  X   X  X   X     timestamp with local timezone  X    X  X  X  X   X  X   X     varchar2  X        X  X  X   X  X    interval year to month  X    X  X  X  X   X  X   X     interval day to second  X    X  X  X  X   X  X   X", 
            "title": "Supported data types"
        }, 
        {
            "location": "/userguide/expectations/index.html#negating-the-matcher", 
            "text": "Expectations provide a very convenient way to check for a negative of the expectation.  Syntax of check for matcher evaluating to true:    exec ut.expect( a_actual {data-type} ).to_( {matcher} );  Syntax of check for matcher evaluating to false:    exec ut.expect( a_actual {data-type} ).not_to( {matcher} );  If a matcher evaluated to NULL, then both  to_  and  not_to  will cause the expectation to report failure.  Example:  begin\n  ut.expect( null ).to_( be_true() );\n  ut.expect( null ).not_to( be_true() );\nend;  Since NULL is neither true not it is not true, both expectations will report failure.", 
            "title": "Negating the matcher"
        }, 
        {
            "location": "/userguide/running-unit-tests/index.html", 
            "text": "utPLSQL framework provides two main entry points to run unit tests from within database: \n- \nut.run\n procedures and functions\n- \nut_runner.run\n procedures\n\n\nThose two entry points differ in purpose and behavior.\n\n\nut.run\n\n\nPackage \nut\n contains overloaded procedures and functions \nrun\n.\nThe \nrun\n API is designed to be called directly by developer, when using IDE/SQL console to execute unit tests.\nThe main benefit of using this API is it's simplicity.\nOne-line call is enough to execute a set of tests form one or multiple schemes.\n\n\nThe \nprocedures\n execute specified tests and produces outputs to DBMS_OUTPUT using specified reporter\nThe \nfunctions\n can only be used in SELECT statements. They execute specified tests and produce outputs as a pipelined data stream to be consumed by select satement.\n\n\nut.run procedures\n\n\nExamples:\n\n\nalter session set current_schema=hr;\nbegin\n  ut.run();\nend;\n\n\n\n\nExecute all tests in current schema (\nHR\n).\n\n\nbegin\n  ut.run('HR');\nend;\n\n\n\n\nExecute all tests in specified schema (\nHR\n).\n\n\nbegin\n  ut.run('hr:com.my_org.my_project');\nend;\n\n\n\n\nExecute all tests from all packages that are on the \nCOM.MY_ORG.MY_PROJECT\n suitepath.\nCheck the \nannotations documentation\n to find out about suitepaths and how they can be used to group test packages.\n\n\nbegin\n  ut.run('hr.test_apply_bonus');\nend;\n\n\n\n\nExecute all tests from package \nHR.TEST_APPLY_BONUS\n. \n\n\nbegin\n  ut.run('hr.test_apply_bonus.bonus_cannot_be_negative');\nend;\n\n\n\n\nExecute single test procedure \nHR.TEST_APPLY_BONUS.BONUS_CANNOT_BE_NEGATIVE\n.\n\n\nbegin\n  ut.run(ut_varcahr2_list('hr.test_apply_bonus','cust'));\nend;\n\n\n\n\nExecute all tests from package \nHR.TEST_APPLY_BONUS\n and all tests from schema \nCUST\n.\nUsing a list of items to execute allows you to execute a fine-grained set of tests.\n\n\nNote:\n\n\nut_documentation_reporter\n is default reporter for all API's defined for running unit tests.\n\n\nThe \nut.run\n procedures and functions accept \na_reporter\n attribute that defines the reporter to be used in the run.\nYou can execute any set of tests with any of the predefined reporters.\n\n\nbegin\n  ut.run('hr.test_apply_bonus', ut_xunit_reporter());\nend;\n\n\n\n\nExecute all tests from package \nHR.TEST_APPLY_BONUS\n and provide outputs to DBMS_OUTPUT using the XUnit reporter. \n\n\nFor details on build-in reporters look at \nreporters documentation\n.\n\n\nut.run functions\n\n\nThe \nut.run\n functions provide exactly the same functionality as the procedures. You may use the same sets of parameters with both functions and procedures. The only difference is the output of the results.\nFunctions provide outputs as pipelined stream and therefore need to be executed as select statements.\n\n\nExample.\n\n\nselect * from table(ut.run('hr.test_apply_bonus', ut_xunit_reporter()));\n\n\n\n\nut_runner.run\n\n\nThe \nut_runner\n provides API for integrating utPLSQL with other products. Maven, Jenkins, SQL Develper, PL/SQL Developer, TOAD and others can leverage this API to call utPLSQL.\n\n\nThe main difference as compared to \nut.run\n API is that the \nut_runner.run\n does not print outputs to the screen.\n\n\nut_runner.run\n accepts multiple reporters. Each reporter produces outputs into a separate output (uniquely identified by output_id).\nOutputs of multiple reporters can be consumed in parallel. This allows for live reporting of test execution progress with threads and several database sessions.\n\n\nThe concept is pretty simple.\n\n\n\n\nin the main thread (session), define the reporters to be used. Each reporter has it's output_id and so you need to extract and store those output_id's.\n\n\nas a separate thread, start the \nut_runner.run\n and pass reporters with previously defined output_id's\n\n\nfor each reporter start a separate thread and read outputs from \nut_output_buffer.get_lines\n table function by providing the output_id defined in the main thread.\n\n\n\n\nut_runner.run\n is internally used by the \nut_run.sql\n script\n which is a utility for running tests with multiple reporters and provides parameters to save reporters results into individual files on the local file system.", 
            "title": "Running unit tests"
        }, 
        {
            "location": "/userguide/running-unit-tests/index.html#utrun", 
            "text": "Package  ut  contains overloaded procedures and functions  run .\nThe  run  API is designed to be called directly by developer, when using IDE/SQL console to execute unit tests.\nThe main benefit of using this API is it's simplicity.\nOne-line call is enough to execute a set of tests form one or multiple schemes.  The  procedures  execute specified tests and produces outputs to DBMS_OUTPUT using specified reporter\nThe  functions  can only be used in SELECT statements. They execute specified tests and produce outputs as a pipelined data stream to be consumed by select satement.", 
            "title": "ut.run"
        }, 
        {
            "location": "/userguide/running-unit-tests/index.html#utrun-procedures", 
            "text": "Examples:  alter session set current_schema=hr;\nbegin\n  ut.run();\nend;  Execute all tests in current schema ( HR ).  begin\n  ut.run('HR');\nend;  Execute all tests in specified schema ( HR ).  begin\n  ut.run('hr:com.my_org.my_project');\nend;  Execute all tests from all packages that are on the  COM.MY_ORG.MY_PROJECT  suitepath.\nCheck the  annotations documentation  to find out about suitepaths and how they can be used to group test packages.  begin\n  ut.run('hr.test_apply_bonus');\nend;  Execute all tests from package  HR.TEST_APPLY_BONUS .   begin\n  ut.run('hr.test_apply_bonus.bonus_cannot_be_negative');\nend;  Execute single test procedure  HR.TEST_APPLY_BONUS.BONUS_CANNOT_BE_NEGATIVE .  begin\n  ut.run(ut_varcahr2_list('hr.test_apply_bonus','cust'));\nend;  Execute all tests from package  HR.TEST_APPLY_BONUS  and all tests from schema  CUST .\nUsing a list of items to execute allows you to execute a fine-grained set of tests.  Note:  ut_documentation_reporter  is default reporter for all API's defined for running unit tests.  The  ut.run  procedures and functions accept  a_reporter  attribute that defines the reporter to be used in the run.\nYou can execute any set of tests with any of the predefined reporters.  begin\n  ut.run('hr.test_apply_bonus', ut_xunit_reporter());\nend;  Execute all tests from package  HR.TEST_APPLY_BONUS  and provide outputs to DBMS_OUTPUT using the XUnit reporter.   For details on build-in reporters look at  reporters documentation .", 
            "title": "ut.run procedures"
        }, 
        {
            "location": "/userguide/running-unit-tests/index.html#utrun-functions", 
            "text": "The  ut.run  functions provide exactly the same functionality as the procedures. You may use the same sets of parameters with both functions and procedures. The only difference is the output of the results.\nFunctions provide outputs as pipelined stream and therefore need to be executed as select statements.  Example.  select * from table(ut.run('hr.test_apply_bonus', ut_xunit_reporter()));", 
            "title": "ut.run functions"
        }, 
        {
            "location": "/userguide/running-unit-tests/index.html#ut_runnerrun", 
            "text": "The  ut_runner  provides API for integrating utPLSQL with other products. Maven, Jenkins, SQL Develper, PL/SQL Developer, TOAD and others can leverage this API to call utPLSQL.  The main difference as compared to  ut.run  API is that the  ut_runner.run  does not print outputs to the screen.  ut_runner.run  accepts multiple reporters. Each reporter produces outputs into a separate output (uniquely identified by output_id).\nOutputs of multiple reporters can be consumed in parallel. This allows for live reporting of test execution progress with threads and several database sessions.  The concept is pretty simple.   in the main thread (session), define the reporters to be used. Each reporter has it's output_id and so you need to extract and store those output_id's.  as a separate thread, start the  ut_runner.run  and pass reporters with previously defined output_id's  for each reporter start a separate thread and read outputs from  ut_output_buffer.get_lines  table function by providing the output_id defined in the main thread.   ut_runner.run  is internally used by the  ut_run.sql  script  which is a utility for running tests with multiple reporters and provides parameters to save reporters results into individual files on the local file system.", 
            "title": "ut_runner.run"
        }, 
        {
            "location": "/userguide/ut_run-script/index.html", 
            "text": "The \nut_run.sql\n script is designed to allow invocation of utPLSQL with multiple reporters.\nIt allows saving of outcomes into multiple output files.\nIt also facilitates displaying on screen unit test results while the execution is still ongoing.\nCurrent limit of script parameters is 39\n\n\nScrip invocation\n\n\nut_run.sql user/password@database [-p=(ut_path|ut_paths)] [-c] [-f=format [-o=output] [-s] ...]\n\n\nParameters\n\n\n  user         - username to connect as\n  password     - password of the user\n  database     - database to connect to\n  -p=ut_path(s)- A path or a comma separated list of paths to unit test to be executed.\n                 The path can be in one of the following formats:\n                   schema[.package[.procedure]]\n                   schema:suite[.suite[.suite][...]][.procedure]\n                 Both formats can be mixed in the comma separated list.\n                 If only schema is provided, then all suites owner by that schema (user) are executed.\n                 If -p is omitted, the current schema is used.\n  -f=format    - A reporter to be used for reporting.\n                 Available options:\n                   -f=ut_documentation_reporter\n                     A textual pretty-print of unit test results (usually use for console output)\n                   -f=ut_teamcity_reporter\n                     A teamcity Unit Test reporter, that can be used to visualize progress of test execution as the job progresses.\n                   -f=ut_xunit_reporter\n                     A XUnit xml format (as defined at: http://stackoverflow.com/a/9691131 and at https://gist.github.com/kuzuha/232902acab1344d6b578)\n                     Usually used  by Continuous Integration servers like Jenkins/Hudson or Teamcity to display test results.\n                 If no -f option is provided, the ut_documentation_reporter will be used.\n\n  -o=output    - file name to save the output provided by the reporter.\n                 If defined, the output is not displayed on screen by default. This can be changed with the -s parameter.\n                 If not defined, then output will be displayed on screen, even if the parameter -s is not specified.\n                 If more than one -o parameter is specified for one -f parameter, the last one is taken into consideration.\n  -s           - Forces putting output to to screen for a given -f parameter.\n  -c           - If specified, enables printing of test results in colors as defined by ANSICONSOLE standards\n\n\n\n\nParameters -f, -o, -s are correlated. That is parameters -o and -s are defining outputs for -f.\n\n\nExamples of invocation using sqlplus from command line:\n\n\nsqlplus /nolog @ut_run hr/hr@xe -p=hr_test -f=ut_documentation_reporter -o=run.log -s -f=ut_teamcity_reporter -o=teamcity.xml\n\n\nAll Unit tests from schema/package \"hr_test\" will be be invoked with two reporters:\n  - ut_documentation_reporter - will output to screen and save it's output to file \"run.log\"\n  - ut_teamcity_reporter - will save it's output to file \"teamcity.xml\"\n\n\nsqlplus /nolog @ut_run hr/hr@xe\n\n\nAll Unit tests from schema \"hr\" will be be invoked with ut_documentation_reporter as a format and the results will be printed to screen", 
            "title": "Using the ut_run script"
        }, 
        {
            "location": "/userguide/ut_run-script/index.html#scrip-invocation", 
            "text": "ut_run.sql user/password@database [-p=(ut_path|ut_paths)] [-c] [-f=format [-o=output] [-s] ...]", 
            "title": "Scrip invocation"
        }, 
        {
            "location": "/userguide/ut_run-script/index.html#parameters", 
            "text": "user         - username to connect as\n  password     - password of the user\n  database     - database to connect to\n  -p=ut_path(s)- A path or a comma separated list of paths to unit test to be executed.\n                 The path can be in one of the following formats:\n                   schema[.package[.procedure]]\n                   schema:suite[.suite[.suite][...]][.procedure]\n                 Both formats can be mixed in the comma separated list.\n                 If only schema is provided, then all suites owner by that schema (user) are executed.\n                 If -p is omitted, the current schema is used.\n  -f=format    - A reporter to be used for reporting.\n                 Available options:\n                   -f=ut_documentation_reporter\n                     A textual pretty-print of unit test results (usually use for console output)\n                   -f=ut_teamcity_reporter\n                     A teamcity Unit Test reporter, that can be used to visualize progress of test execution as the job progresses.\n                   -f=ut_xunit_reporter\n                     A XUnit xml format (as defined at: http://stackoverflow.com/a/9691131 and at https://gist.github.com/kuzuha/232902acab1344d6b578)\n                     Usually used  by Continuous Integration servers like Jenkins/Hudson or Teamcity to display test results.\n                 If no -f option is provided, the ut_documentation_reporter will be used.\n\n  -o=output    - file name to save the output provided by the reporter.\n                 If defined, the output is not displayed on screen by default. This can be changed with the -s parameter.\n                 If not defined, then output will be displayed on screen, even if the parameter -s is not specified.\n                 If more than one -o parameter is specified for one -f parameter, the last one is taken into consideration.\n  -s           - Forces putting output to to screen for a given -f parameter.\n  -c           - If specified, enables printing of test results in colors as defined by ANSICONSOLE standards  Parameters -f, -o, -s are correlated. That is parameters -o and -s are defining outputs for -f.  Examples of invocation using sqlplus from command line:  sqlplus /nolog @ut_run hr/hr@xe -p=hr_test -f=ut_documentation_reporter -o=run.log -s -f=ut_teamcity_reporter -o=teamcity.xml  All Unit tests from schema/package \"hr_test\" will be be invoked with two reporters:\n  - ut_documentation_reporter - will output to screen and save it's output to file \"run.log\"\n  - ut_teamcity_reporter - will save it's output to file \"teamcity.xml\"  sqlplus /nolog @ut_run hr/hr@xe  All Unit tests from schema \"hr\" will be be invoked with ut_documentation_reporter as a format and the results will be printed to screen", 
            "title": "Parameters"
        }, 
        {
            "location": "/userguide/best-practices/index.html", 
            "text": "Best Practices\n\n\nThe following are best practices we as utPLSQL have learned about PL/SQL and Unit Testing. \n\n\nTest Interaction\n\n\n\n\nTests should not depend on a specific order to run. \n\n\nTests should not depend on other tests to execute.\n\n\nA developer should be able to run one or more tests of their choosing with out any prerequisites.\n\n\n\n\nTests are not for production\n\n\nTests generate will generate fake data, so it should go without saying.   You should not deploy your tests to a production database.\n\n\nTests and their relationship to code under test.\n\n\n\n\nCode that you want to test, and the tests should be in separate packages.\n\n\nTest code commonly will be the same schema as code \n\n\n\n\nVersion Control\n\n\nUse a version control system for your code.   Don't just trust the database for code storage.    This includes both the code you have under test, and the unit tests you develop as well.", 
            "title": "Testing best pracitces"
        }, 
        {
            "location": "/userguide/best-practices/index.html#best-practices", 
            "text": "The following are best practices we as utPLSQL have learned about PL/SQL and Unit Testing.", 
            "title": "Best Practices"
        }, 
        {
            "location": "/userguide/best-practices/index.html#test-interaction", 
            "text": "Tests should not depend on a specific order to run.   Tests should not depend on other tests to execute.  A developer should be able to run one or more tests of their choosing with out any prerequisites.", 
            "title": "Test Interaction"
        }, 
        {
            "location": "/userguide/best-practices/index.html#tests-are-not-for-production", 
            "text": "Tests generate will generate fake data, so it should go without saying.   You should not deploy your tests to a production database.", 
            "title": "Tests are not for production"
        }, 
        {
            "location": "/userguide/best-practices/index.html#tests-and-their-relationship-to-code-under-test", 
            "text": "Code that you want to test, and the tests should be in separate packages.  Test code commonly will be the same schema as code", 
            "title": "Tests and their relationship to code under test."
        }, 
        {
            "location": "/userguide/best-practices/index.html#version-control", 
            "text": "Use a version control system for your code.   Don't just trust the database for code storage.    This includes both the code you have under test, and the unit tests you develop as well.", 
            "title": "Version Control"
        }, 
        {
            "location": "/userguide/upgrade/index.html", 
            "text": "How to upgrade from prior versions\n\n\nTODO: Finish this documentation.", 
            "title": "Upgrade utPLSQL"
        }, 
        {
            "location": "/userguide/upgrade/index.html#how-to-upgrade-from-prior-versions", 
            "text": "TODO: Finish this documentation.", 
            "title": "How to upgrade from prior versions"
        }, 
        {
            "location": "/userguide/reporters/index.html", 
            "text": "utPLSQL provides the following reporting formats.\n\n\nDocumentation reporter\n\n\nThe \nut_documentation_reporter\n is the default reporting format used by the framework.\nIt provides a human readable test results.\n\n\nTo invoke tests with documentation reporter use one of following calls from sql console (SQLPlus)  \n\n\nexec ut.run();\n\n\nexec ut.run(ut_documentation_reporter());\n\n\nYou may also invoke unit tests directly from command line by calling.\n\n\nsqlplus /nolog @ut_run %user%/%pass%@%dbsid%\n\n\nInvoking tests from command line tool \nut_run.sql\n allows you to track progress of test execution.\nIn that case, the documentation reporter will provide information about each test that was executed as soon as it's execution finishes.\nFor more details on using the \nut_run.sql\n script look into \nut_run.sql\n documentation.\n\n\nThe \nut_documentation_reporter\n doesn't accept any arguments.\n\n\nExample outputs from documentation reporter.\n\n\n\n\nThe documentation report provides the following information.\n- Test suite name or test package name  (nested with suitepath if suitepath is used)\n- Test description name or test procedure name\n- Information about test failing \n(FAILED - n)\n \n- Information about disabled test \n(IGNORED)\n \n- List of all errors and failures\n- Summary with total number of tests, number of tests with status and timing for the execution \n\n\nColor output from documentation reporter\n\n\nWhen invoking tests with documentation reporter and your command line supports ANSICONSOLE (default on Unix), you can obtain the coloured outputs from the documentation reporter.\n\n\nTo invoke tests with documentation reporter in color mode use one of following calls.  \n\n\nexec ut.run(a_color_console=\ntrue);\n\n\nexec ut.run(ut_documentation_reporter(), a_color_console=\ntrue);\n\n\nExample outputs from documentation reporter.\n\n\n\n\nXUnit reporter\n\n\nMost of continuous integration servers (like Jenkins) are capable of consuming unit test execution results in \nXUnit/JUnit\n format.\nThe \nut_xunit_reporter\n is producing outcomes as XUnit-compatible XML unit test report, that can be used by CI servers to display their custom reports and provide metrics (like tests execution trends).\n\n\nInvocation of tests with XUnit reporter.  \n\n\nexec ut.run(ut_xunit_reporter());\n\n\nThe \nut_xunit_reporter\n doesn't accept any arguments.\n\n\nExample of xunit report integrated with \nJenkins CI\n\n\n\n\nExample of failure report details\n\n\n\n\nTeamcity reporter\n\n\nTeamcity\n is a CI server by Jetbrains. It supports XUnit reporting and additionally has it's own format of reporting that allows tracking of progress of a CI step/task as it executes.\nThe TeamCity format developed by Jetbrains is supported by utPLSQL with \nut_teamcity_reporter\n.\n\n\nInvocation of tests with Teamcity reporter.  \n\n\nexec ut.run(ut_teamcity_reporter());\n\n\nThe \nut_teamcity_reporter\n doesn't accept any arguments.\n\n\nExample of unit test report from Teamcity CI server.\n\n\n\n\nExample of failure report details\n\n\n\n\nCoverage reporters\n\n\nutPLSQL comes with a set of build-in coverage reporters. Have a look into the \ncoverage documentation\n to learn more about them.", 
            "title": "Using reporters"
        }, 
        {
            "location": "/userguide/reporters/index.html#documentation-reporter", 
            "text": "The  ut_documentation_reporter  is the default reporting format used by the framework.\nIt provides a human readable test results.  To invoke tests with documentation reporter use one of following calls from sql console (SQLPlus)    exec ut.run();  exec ut.run(ut_documentation_reporter());  You may also invoke unit tests directly from command line by calling.  sqlplus /nolog @ut_run %user%/%pass%@%dbsid%  Invoking tests from command line tool  ut_run.sql  allows you to track progress of test execution.\nIn that case, the documentation reporter will provide information about each test that was executed as soon as it's execution finishes.\nFor more details on using the  ut_run.sql  script look into  ut_run.sql  documentation.  The  ut_documentation_reporter  doesn't accept any arguments.  Example outputs from documentation reporter.   The documentation report provides the following information.\n- Test suite name or test package name  (nested with suitepath if suitepath is used)\n- Test description name or test procedure name\n- Information about test failing  (FAILED - n)  \n- Information about disabled test  (IGNORED)  \n- List of all errors and failures\n- Summary with total number of tests, number of tests with status and timing for the execution", 
            "title": "Documentation reporter"
        }, 
        {
            "location": "/userguide/reporters/index.html#color-output-from-documentation-reporter", 
            "text": "When invoking tests with documentation reporter and your command line supports ANSICONSOLE (default on Unix), you can obtain the coloured outputs from the documentation reporter.  To invoke tests with documentation reporter in color mode use one of following calls.    exec ut.run(a_color_console= true);  exec ut.run(ut_documentation_reporter(), a_color_console= true);  Example outputs from documentation reporter.", 
            "title": "Color output from documentation reporter"
        }, 
        {
            "location": "/userguide/reporters/index.html#xunit-reporter", 
            "text": "Most of continuous integration servers (like Jenkins) are capable of consuming unit test execution results in  XUnit/JUnit  format.\nThe  ut_xunit_reporter  is producing outcomes as XUnit-compatible XML unit test report, that can be used by CI servers to display their custom reports and provide metrics (like tests execution trends).  Invocation of tests with XUnit reporter.    exec ut.run(ut_xunit_reporter());  The  ut_xunit_reporter  doesn't accept any arguments.  Example of xunit report integrated with  Jenkins CI   Example of failure report details", 
            "title": "XUnit reporter"
        }, 
        {
            "location": "/userguide/reporters/index.html#teamcity-reporter", 
            "text": "Teamcity  is a CI server by Jetbrains. It supports XUnit reporting and additionally has it's own format of reporting that allows tracking of progress of a CI step/task as it executes.\nThe TeamCity format developed by Jetbrains is supported by utPLSQL with  ut_teamcity_reporter .  Invocation of tests with Teamcity reporter.    exec ut.run(ut_teamcity_reporter());  The  ut_teamcity_reporter  doesn't accept any arguments.  Example of unit test report from Teamcity CI server.   Example of failure report details", 
            "title": "Teamcity reporter"
        }, 
        {
            "location": "/userguide/reporters/index.html#coverage-reporters", 
            "text": "utPLSQL comes with a set of build-in coverage reporters. Have a look into the  coverage documentation  to learn more about them.", 
            "title": "Coverage reporters"
        }, 
        {
            "location": "/userguide/exception-reporting/index.html", 
            "text": "Exception handling and reporting\n\n\nThe utPLSQL is responsible for handling exceptions wherever they occur in the test run. utPLSQL is trapping most of the exceptions so that the test execution is not affected by individual tests or test packages throwing an exception.\nThe framework provides a full stacktrace for every exception that was thrown. The stacktrace is clean and does not include any utPLSQL library calls in it.\nTo achieve rerunability, the ORA-04068, ORA-04061 exceptions are not handled and test execution will be interrupted if such exception is encountered. This is because of how Oracle behaves on those exceptions.\n\n\nTest execution can fail for different reasons. The failures on different exceptions are handled as follows:\n\n A test package without body - each \n%test\n is reported as failed with exception, nothing is executed\n\n A test package with \ninvalid body\n - each \n%test\n is reported as failed with exception, nothing is executed\n\n A test package with \ninvalid spec\n - package is not considered a valid unit test package and is excluded from execution. When trying to run a test package with invalid spec explicitly, exception is raised. Only valid specifications are parsed for annotations \n\n A test package that is raising an exception in \n%beforeall\n - each \n%test\n is reported as failed with exception, \n%test\n, \n%beforeeach\n, \n%beforetest\n, \n%aftertest\n and \n%aftereach\n are not executed. \n%afterall\n is executed to allow cleanup of whatever was done in \n%beforeall\n\n\n A test package that is raising an exception in \n%beforeeach\n - each \n%test\n is reported as failed with exception, \n%test\n, \n%beforetest\n and \n%aftertest\n is not executed. The \n%aftereach\n and \n%afterall\n blocks are getting executed to allow cleanup of whatever was done in \n%before...\n blocks\n\n A test package that is raising an exception in \n%beforetest\n - the \n%test\n is reported as failed  with exception, \n%test\n is not executed. The \n%aftertest\n, \n%aftereach\n and \n%afterall\n blocks are getting executed to allow cleanup of whatever was done in \n%before...\n blocks\n\n A test package that is raising an exception in \n%test\n - the \n%test\n is reported as failed with exception. The execution of other blocks continues normally\n\n A test package that is raising an exception in \n%aftertest\n - the \n%test\n is reported as failed with exception. The execution of other blocks continues normally\n\n A test package that is raising an exception in \n%aftereach\n - each \n%test\n is reported as failed with exception.\n\n A test package that is raising an exception in \n%afterall\n - all blocks of  the package are executed, as the \n%afterall\n is the last step of package execution. Exception in \n%afterall\n is not affecting test results. A warning with exception stacktrace is displayed in the summary\n\n\nExample of reporting with exception thrown in \n%beforetest\n:\n\n\nRemove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \nUT3.TEST_REMOVE_ROOMS_BY_NAME\n, line 39\n               ORA-06512: at line 6\n\nFinished in ,039346 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.\n\n\n\n\nExample of reporting with exception thrown in \n%test\n:\n\n\nRemove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \nUT3.TEST_REMOVE_ROOMS_BY_NAME\n, line 48\n               ORA-06512: at line 6\n\nFinished in ,035726 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.\n\n\n\n\nExample of reporting with exception thrown in \n%aftertest\n:\n\n\nRemove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \nUT3.TEST_REMOVE_ROOMS_BY_NAME\n, line 42\n               ORA-06512: at line 6\n\nFinished in ,045523 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.\n\n\n\n\nExample of reporting with exception thrown in \n%aftereach\n:\n\n\nRemove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content (FAILED - 2)\n  Raises exception when null room name given (FAILED - 3)\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \nUT3.TEST_REMOVE_ROOMS_BY_NAME\n, line 31\n               ORA-06512: at line 6\n\n  2) room_with_content\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \nUT3.TEST_REMOVE_ROOMS_BY_NAME\n, line 31\n               ORA-06512: at line 6\n\n  3) null_room_name\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \nUT3.TEST_REMOVE_ROOMS_BY_NAME\n, line 31\n               ORA-06512: at line 6\n\nFinished in ,034863 seconds\n3 tests, 0 failed, 3 errored, 0 ignored.\n\n\n\n\nExample of reporting with exception thrown in \n%afterall\n:\n\n\nRemove rooms by name\n  Removes a room without content in it\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nWarnings:\n\n  1) test_remove_rooms_by_name - Afterall procedure failed: \n       ORA-20001: Test exception\n       ORA-06512: at \nUT3.TEST_REMOVE_ROOMS_BY_NAME\n, line 35\n       ORA-06512: at line 6\n\nFinished in ,044902 seconds\n3 tests, 0 failed, 0 errored, 0 ignored. 1 warning(s)", 
            "title": "Reporting errors"
        }, 
        {
            "location": "/userguide/exception-reporting/index.html#exception-handling-and-reporting", 
            "text": "The utPLSQL is responsible for handling exceptions wherever they occur in the test run. utPLSQL is trapping most of the exceptions so that the test execution is not affected by individual tests or test packages throwing an exception.\nThe framework provides a full stacktrace for every exception that was thrown. The stacktrace is clean and does not include any utPLSQL library calls in it.\nTo achieve rerunability, the ORA-04068, ORA-04061 exceptions are not handled and test execution will be interrupted if such exception is encountered. This is because of how Oracle behaves on those exceptions.  Test execution can fail for different reasons. The failures on different exceptions are handled as follows:  A test package without body - each  %test  is reported as failed with exception, nothing is executed  A test package with  invalid body  - each  %test  is reported as failed with exception, nothing is executed  A test package with  invalid spec  - package is not considered a valid unit test package and is excluded from execution. When trying to run a test package with invalid spec explicitly, exception is raised. Only valid specifications are parsed for annotations   A test package that is raising an exception in  %beforeall  - each  %test  is reported as failed with exception,  %test ,  %beforeeach ,  %beforetest ,  %aftertest  and  %aftereach  are not executed.  %afterall  is executed to allow cleanup of whatever was done in  %beforeall   A test package that is raising an exception in  %beforeeach  - each  %test  is reported as failed with exception,  %test ,  %beforetest  and  %aftertest  is not executed. The  %aftereach  and  %afterall  blocks are getting executed to allow cleanup of whatever was done in  %before...  blocks  A test package that is raising an exception in  %beforetest  - the  %test  is reported as failed  with exception,  %test  is not executed. The  %aftertest ,  %aftereach  and  %afterall  blocks are getting executed to allow cleanup of whatever was done in  %before...  blocks  A test package that is raising an exception in  %test  - the  %test  is reported as failed with exception. The execution of other blocks continues normally  A test package that is raising an exception in  %aftertest  - the  %test  is reported as failed with exception. The execution of other blocks continues normally  A test package that is raising an exception in  %aftereach  - each  %test  is reported as failed with exception.  A test package that is raising an exception in  %afterall  - all blocks of  the package are executed, as the  %afterall  is the last step of package execution. Exception in  %afterall  is not affecting test results. A warning with exception stacktrace is displayed in the summary  Example of reporting with exception thrown in  %beforetest :  Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at  UT3.TEST_REMOVE_ROOMS_BY_NAME , line 39\n               ORA-06512: at line 6\n\nFinished in ,039346 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.  Example of reporting with exception thrown in  %test :  Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at  UT3.TEST_REMOVE_ROOMS_BY_NAME , line 48\n               ORA-06512: at line 6\n\nFinished in ,035726 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.  Example of reporting with exception thrown in  %aftertest :  Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at  UT3.TEST_REMOVE_ROOMS_BY_NAME , line 42\n               ORA-06512: at line 6\n\nFinished in ,045523 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.  Example of reporting with exception thrown in  %aftereach :  Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content (FAILED - 2)\n  Raises exception when null room name given (FAILED - 3)\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at  UT3.TEST_REMOVE_ROOMS_BY_NAME , line 31\n               ORA-06512: at line 6\n\n  2) room_with_content\n\n        error: ORA-20001: Test exception\n               ORA-06512: at  UT3.TEST_REMOVE_ROOMS_BY_NAME , line 31\n               ORA-06512: at line 6\n\n  3) null_room_name\n\n        error: ORA-20001: Test exception\n               ORA-06512: at  UT3.TEST_REMOVE_ROOMS_BY_NAME , line 31\n               ORA-06512: at line 6\n\nFinished in ,034863 seconds\n3 tests, 0 failed, 3 errored, 0 ignored.  Example of reporting with exception thrown in  %afterall :  Remove rooms by name\n  Removes a room without content in it\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nWarnings:\n\n  1) test_remove_rooms_by_name - Afterall procedure failed: \n       ORA-20001: Test exception\n       ORA-06512: at  UT3.TEST_REMOVE_ROOMS_BY_NAME , line 35\n       ORA-06512: at line 6\n\nFinished in ,044902 seconds\n3 tests, 0 failed, 0 errored, 0 ignored. 1 warning(s)", 
            "title": "Exception handling and reporting"
        }, 
        {
            "location": "/userguide/coverage/index.html", 
            "text": "Coverage\n\n\nutPLSQL comes with build-in coverage reporting engine. The code coverage reporting is based off DBMS_PROFILER package. Code coverage is gathered for the following source types:\n\n package bodies\n\n type bodies\n\n triggers\n\n stored procedures\n* stored functions\n\n\nNote:\n\n\n\n\nThe package specifications and type specifications are explicitly excluded from code coverage analysis.This limitation is introduced to avoid false-negatives. Most of the package specifications don't contain executable code. The only exception is initialization of global constants and variables in package specification.Since, most of package specifications are not executable at all, there is no information available on the number of lines covered and those would eb reported as 0% covered, which is not desired.\n\n\n\n\nTo obtain information about code coverage of your Unit Tests, all you need to do is run your unit tests with one of build-in code coverage reporters.\nFollowing code coverage reporters are supplied with utPLSQL:\n\n \nut_coverage_html_reporter\n - generates a HTML coverage report providing summary and detailed information on code coverage. The html reporter is based on open-source \nsimplecov-html\n reporter for Ruby. It includes source code of the code that was covered (if possible)\n\n\n \nut_coveralls_reporter\n - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like \ncoveralls\n \n* \nut_coverage_sonar_reporter\n  - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by local services like \nsonarqube\n\n\nSecurity model\n\n\nCode coverage is using DBMS_PROFILER to gather information about execution of code under test and therefore follows the \nDBMS_PROFILER's Security Model\n\nIn order to be able to gather coverage information, user executing unit tests needs to be either:\n\n Owner of the code that is tested\n\n Have the following privileges to be able to gather coverage on code owned by other users:\n    * \ncreate any procedure\n system privilege\n    * \nexecute\n privilege on the code that is tested (not only the unit tests) or \nexecute any procedure\n system privilege\n\n\nIf you have \nexecute\n privilege on the code that are tested, but do not have \ncreate any procedure\n system privilege, the code that is tested will be reported as not covered (coverage = 0%).\nIf you have \nexecute\n privilege only on the unit tests, but do not have \nexecute\n privilege on the code that is tested, the code will not be reported by coverage - as if it did not exist in the database.\nIf the code that is testes is complied as NATIVE, the code coverage will not be reported as well.\n\n\nRunning unite tests with coverage\n\n\nUsing code coverage functionality is as easy as using any other \nreporter\n for utPLSQL project. All you need to do is run your tests from your preferred SQL tool and save the outcomes of reporter to a file.\nAll you need to do, is pass the constructor of the reporter to your \nut.run\n\n\nExample:\n\n\nbegin\n  ut.run(ut_coverage_html_reporter());\nend;\n/\n\n\n\n\nExecutes all unit tests in current schema, gather information about code coverage and output the html text into DBMS_OUTPUT.\nThe \nut_coverage_html_reporter\n will produce a interactive HTML report. You may see a sample of code coverage for utPLSQL project \nhere\n\n\nThe report provides a summary information with list of source code that was expected to be covered.\n\n\n\n\nThe report allow to navigate to every source and inspect line by line coverage.\n\n\n\n\nCoverage reporting options\n\n\nBy default the database schema/schemes containing the tests that were executed during the run, are fully reported by coverage reporter.\nAll valid unit tests are excluded from the report regardless if they were invoked or not. This way the coverage report is not affected by presence of tests and contains only the tested code.\n\n\nThe default behavior of coverage reporters can be altered, depending on your needs.\n\n\nIncluding/excluding objects in coverage reports\n\n\nThe most basic options are the include/exclude objects lists.\nYou may specify both include and exclude objects lists to specify which objects are to be included in the report and which are to be excluded.\nBoth of those options are meant to be used to narrow down the scope of unit test runs, that is broad by default.\n\n\nExample:\n\n\nexec ut.run('ut3_user.test_award_bonus', ut_coverage_html_reporter(a_include_object_list=\nut_varchar2_list('ut3_user.award_bonus')));\n\n\n\n\nExecutes test \ntest_award_bonus\n and gather coverage only on object \nut3_user.award_bonus\n\n\nAlternatively you could run:\n\n\nexec ut.run('ut3_user.test_award_bonus', ut_coverage_html_reporter(a_exclude_object_list=\nut_varchar2_list('ut3_user.betwnstr')));\n\n\n\n\nExecutes test \ntest_award_bonus\n and gather on all objects in schema \nut3_user\n except valid unit test objects and object \nbetwnstr\n that schema.\n\n\nYou can also combine the parameters and both will be applied.\n\n\nDefining different schema name(s)\n\n\nIn some architectures, you might end up in a situation, where your unit tests exist in a different schema than the tested code.\nThis is not the default or recommended approach but is supporter by utPLSQL.\nIn such scenarios, you would probably have a separate database schema to hold unit tests and a separate schema/schemes to hold the tested code.\nSince by default, coverage reporting is done on the schema/schemes that the invoked tests are on, the code will not be included in coverage report as it is in a different schema than the invoked tests. \n\n\nIn this situation you need to provide list of schema names that the tested code is in. This option overrides the default schema names for coverage.\n\n\nExample:\n\n\nexec ut.run('ut3_user.test_award_bonus', ut_coverage_html_reporter(a_schema_names=\nut_varchar2_list('usr')));\n\n\n\n\nExecutes test \ntest_award_bonus\n in schema \nut3_user\n and gather coverage for that execution on all non \nunit-test\n objects from schema \nusr\n.\n\n\nYou can combine schema names with include/exclude parameters and all will be applied.\nThe \na_schema_names\n parameter takes precedence however, so if include list contains objects from other schemes, that will not be considered.  \n\n\nExample:\n\n\nbegin\n  ut.run(\n    'ut3_user.test_award_bonus', \n    ut_coverage_html_reporter(\n      a_schema_names =\n ut_varchar2_list('usr'), \n      a_include_object_list =\n ut_varchar2_list('usr.award_bonus'),\n      a_exclude_object_list =\n ut_varchar2_list('usr.betwnstr')\n    )\n  );\nend;\n\n\n\n\nExecutes test \ntest_award_bonus\n in schema \nut3_user\n and gather coverage for that execution on \naward_bonus\n object from schema \nusr\n. The exclude list is of no relevance as it is not overlapping with include list.\n\n\nWorking with projects and project files\n\n\nBoth \nsonar\n and \ncoveralls\n are utilities that are more project-oriented than database-centric. They report statistics and coverage for project files in version control system.\nNowadays, most of database projects are moving away from database-centric approach towards project/product-centric approach.\nCoverage reporting of utPLSQL allows you to perform code coverage analysis for your project files.\nThis feature is supported by all build-in coverage reporting formats.\n\n\nWhen using this invocation syntax, coverage is only reported for the provided files, so using project files as input for coverage is also a way of limiting the scope of coverage analysis.\nThis syntax also allows usage of \na_include_object_list\n and \na_exclude_object_list\n as optional parameters to filter the scope of analysis. \n\n\nReporting using externally provided file mapping\n\nOne of ways to perform coverage reporting on your project files is to provide to the coverage reporter a list of file path/names along with mapping to corresponding object name and object type.\n\n\nExample:\n\n\nbegin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_file_mappings=\nut_coverage_file_mappings(\n        ut_coverage_file_mapping(\n          file_name    =\n 'sources/hr/award_bonus.prc',\n          object_owner =\n 'usr',\n          object_name  =\n 'award_bonus',\n          object_type  =\n 'procedure'                        \n        ),\n        ut_coverage_file_mapping(\n          file_name    =\n 'sources/hr/betwnstr.fnc',\n          object_owner =\n 'usr',\n          object_name  =\n 'betwnstr',\n          object_type  =\n 'function'                        \n        )\n      )\n    )\n  );\nend;\n\n\n\n\nExecutes all tests in schema \nusr\n and reports coverage for that execution on procedure \naward_bonus\n and function \nbetwnstr\n. The coverage report is mapped-back to file-system object names with paths.\n\n\nReporting using regex file mapping rule\n\nIf file names and paths in your project follow a well established naming conventions, \nthen you can use the predefined rule for mapping file names to object names or you can define your own rule and pass it to the coverage reporter at runtime.\n\n\nExample of running with predefined regex mapping rule.\n\n\nbegin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_file_paths =\n ut_varchar2_list('sources/hr/award_bonus.prc','sources/hr/betwnstr.fnc')\n    )\n  );\nend;\n\n\n\n\nThe predefined rule is based on the following default values for parameters:\n\n \na_regex_pattern =\n '.*(\\\\|\\/)((\\w+)\\.)?(\\w+)\\.(\\w{3})'\n \n\n \na_object_owner_subexpression =\n 3\n\n\n \na_object_name_subexpression =\n 4\n\n\n \na_object_type_subexpression =\n 5\n\n* \na_file_to_object_type_mapping\n - defined in table below\n\n\nThe predefined file extension to object type mappings\n\n\n\n\n\n\n\n\nfile extension\n\n\nobject type\n\n\n\n\n\n\n\n\n\n\ntpb\n\n\ntype body\n\n\n\n\n\n\npkb\n\n\npackage body\n\n\n\n\n\n\nbdy\n\n\npackage body\n\n\n\n\n\n\ntrg\n\n\ntrigger\n\n\n\n\n\n\nfnc\n\n\nfunction\n\n\n\n\n\n\nprc\n\n\nprocedure\n\n\n\n\n\n\n\n\nSince package specification and type specifications are not considered by coverage, the file extensions for those objects  are not included in the mapping.\n\n\nExamples of filename paths that will be mapped correctly using predefined rules.\n\n \n[...]directory[/subdirectory[/...]]/object_name.(tpb|pkb|trg|fnc|prc)\n\n\n \n[...]directory[/subdirectory[/...]]/schema_name.object_name.(tpb|pkb|trg|fnc|prc)\n\n\n \n[...]directory[\\subdirectory[\\...]]\\object_name.(tpb|pkb|trg|fnc|prc)\n\n\n \n[...]directory[\\subdirectory[\\...]]\\schema_name.object_name.(tpb|pkb|trg|fnc|prc)\n\n\nIf file names in your project structure are not prefixed with schema name (like above), the coverage report will look for objects to match the file names in the \ncurrent schema\n of the connection that was used to execute tests with coverage.\nIf for whatever reasons you use a user and current schema that is different then schem that holds your project code, you should use \na_schema_name\n parameter to inform coverage reporter about database schema to be used for object lookup.\n\n\nExample:\n\n\nbegin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_schema_name =\n 'hr',\n      a_file_paths  =\n ut_varchar2_list('sources/hr/award_bonus.prc','sources/hr/betwnstr.fnc')\n    )\n  );\nend;\n\n\n\n\nIf your project structure is different, you may define your own mapping rule using regex.\n\n\nExample:\n\n\nbegin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_file_paths  =\n ut_varchar2_list('sources/hr/procedures/award_bonus.sql','sources/hr/functions/betwnstr.sql'),\n      a_regex_pattern =\n '.*(\\\\|\\/)(\\w+)\\.(\\w+)\\.(\\w{3})',\n      a_object_owner_subexpression =\n 2,\n      a_object_type_subexpression =\n 3,\n      a_object_name_subexpression =\n 4,\n      a_file_to_object_type_mapping =\n ut_key_value_pairs(\n        ut_key_value_pair('functions', 'function'),\n        ut_key_value_pair('procedures', 'procedure')\n    )\n  );\nend;", 
            "title": "Code coverage"
        }, 
        {
            "location": "/userguide/coverage/index.html#coverage", 
            "text": "utPLSQL comes with build-in coverage reporting engine. The code coverage reporting is based off DBMS_PROFILER package. Code coverage is gathered for the following source types:  package bodies  type bodies  triggers  stored procedures\n* stored functions  Note:   The package specifications and type specifications are explicitly excluded from code coverage analysis.This limitation is introduced to avoid false-negatives. Most of the package specifications don't contain executable code. The only exception is initialization of global constants and variables in package specification.Since, most of package specifications are not executable at all, there is no information available on the number of lines covered and those would eb reported as 0% covered, which is not desired.   To obtain information about code coverage of your Unit Tests, all you need to do is run your unit tests with one of build-in code coverage reporters.\nFollowing code coverage reporters are supplied with utPLSQL:   ut_coverage_html_reporter  - generates a HTML coverage report providing summary and detailed information on code coverage. The html reporter is based on open-source  simplecov-html  reporter for Ruby. It includes source code of the code that was covered (if possible)    ut_coveralls_reporter  - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like  coveralls  \n*  ut_coverage_sonar_reporter   - generates a JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by local services like  sonarqube", 
            "title": "Coverage"
        }, 
        {
            "location": "/userguide/coverage/index.html#security-model", 
            "text": "Code coverage is using DBMS_PROFILER to gather information about execution of code under test and therefore follows the  DBMS_PROFILER's Security Model \nIn order to be able to gather coverage information, user executing unit tests needs to be either:  Owner of the code that is tested  Have the following privileges to be able to gather coverage on code owned by other users:\n    *  create any procedure  system privilege\n    *  execute  privilege on the code that is tested (not only the unit tests) or  execute any procedure  system privilege  If you have  execute  privilege on the code that are tested, but do not have  create any procedure  system privilege, the code that is tested will be reported as not covered (coverage = 0%).\nIf you have  execute  privilege only on the unit tests, but do not have  execute  privilege on the code that is tested, the code will not be reported by coverage - as if it did not exist in the database.\nIf the code that is testes is complied as NATIVE, the code coverage will not be reported as well.", 
            "title": "Security model"
        }, 
        {
            "location": "/userguide/coverage/index.html#running-unite-tests-with-coverage", 
            "text": "Using code coverage functionality is as easy as using any other  reporter  for utPLSQL project. All you need to do is run your tests from your preferred SQL tool and save the outcomes of reporter to a file.\nAll you need to do, is pass the constructor of the reporter to your  ut.run  Example:  begin\n  ut.run(ut_coverage_html_reporter());\nend;\n/  Executes all unit tests in current schema, gather information about code coverage and output the html text into DBMS_OUTPUT.\nThe  ut_coverage_html_reporter  will produce a interactive HTML report. You may see a sample of code coverage for utPLSQL project  here  The report provides a summary information with list of source code that was expected to be covered.   The report allow to navigate to every source and inspect line by line coverage.", 
            "title": "Running unite tests with coverage"
        }, 
        {
            "location": "/userguide/coverage/index.html#coverage-reporting-options", 
            "text": "By default the database schema/schemes containing the tests that were executed during the run, are fully reported by coverage reporter.\nAll valid unit tests are excluded from the report regardless if they were invoked or not. This way the coverage report is not affected by presence of tests and contains only the tested code.  The default behavior of coverage reporters can be altered, depending on your needs.", 
            "title": "Coverage reporting options"
        }, 
        {
            "location": "/userguide/coverage/index.html#includingexcluding-objects-in-coverage-reports", 
            "text": "The most basic options are the include/exclude objects lists.\nYou may specify both include and exclude objects lists to specify which objects are to be included in the report and which are to be excluded.\nBoth of those options are meant to be used to narrow down the scope of unit test runs, that is broad by default.  Example:  exec ut.run('ut3_user.test_award_bonus', ut_coverage_html_reporter(a_include_object_list= ut_varchar2_list('ut3_user.award_bonus')));  Executes test  test_award_bonus  and gather coverage only on object  ut3_user.award_bonus  Alternatively you could run:  exec ut.run('ut3_user.test_award_bonus', ut_coverage_html_reporter(a_exclude_object_list= ut_varchar2_list('ut3_user.betwnstr')));  Executes test  test_award_bonus  and gather on all objects in schema  ut3_user  except valid unit test objects and object  betwnstr  that schema.  You can also combine the parameters and both will be applied.", 
            "title": "Including/excluding objects in coverage reports"
        }, 
        {
            "location": "/userguide/coverage/index.html#defining-different-schema-names", 
            "text": "In some architectures, you might end up in a situation, where your unit tests exist in a different schema than the tested code.\nThis is not the default or recommended approach but is supporter by utPLSQL.\nIn such scenarios, you would probably have a separate database schema to hold unit tests and a separate schema/schemes to hold the tested code.\nSince by default, coverage reporting is done on the schema/schemes that the invoked tests are on, the code will not be included in coverage report as it is in a different schema than the invoked tests.   In this situation you need to provide list of schema names that the tested code is in. This option overrides the default schema names for coverage.  Example:  exec ut.run('ut3_user.test_award_bonus', ut_coverage_html_reporter(a_schema_names= ut_varchar2_list('usr')));  Executes test  test_award_bonus  in schema  ut3_user  and gather coverage for that execution on all non  unit-test  objects from schema  usr .  You can combine schema names with include/exclude parameters and all will be applied.\nThe  a_schema_names  parameter takes precedence however, so if include list contains objects from other schemes, that will not be considered.    Example:  begin\n  ut.run(\n    'ut3_user.test_award_bonus', \n    ut_coverage_html_reporter(\n      a_schema_names =  ut_varchar2_list('usr'), \n      a_include_object_list =  ut_varchar2_list('usr.award_bonus'),\n      a_exclude_object_list =  ut_varchar2_list('usr.betwnstr')\n    )\n  );\nend;  Executes test  test_award_bonus  in schema  ut3_user  and gather coverage for that execution on  award_bonus  object from schema  usr . The exclude list is of no relevance as it is not overlapping with include list.", 
            "title": "Defining different schema name(s)"
        }, 
        {
            "location": "/userguide/coverage/index.html#working-with-projects-and-project-files", 
            "text": "Both  sonar  and  coveralls  are utilities that are more project-oriented than database-centric. They report statistics and coverage for project files in version control system.\nNowadays, most of database projects are moving away from database-centric approach towards project/product-centric approach.\nCoverage reporting of utPLSQL allows you to perform code coverage analysis for your project files.\nThis feature is supported by all build-in coverage reporting formats.  When using this invocation syntax, coverage is only reported for the provided files, so using project files as input for coverage is also a way of limiting the scope of coverage analysis.\nThis syntax also allows usage of  a_include_object_list  and  a_exclude_object_list  as optional parameters to filter the scope of analysis.   Reporting using externally provided file mapping \nOne of ways to perform coverage reporting on your project files is to provide to the coverage reporter a list of file path/names along with mapping to corresponding object name and object type.  Example:  begin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_file_mappings= ut_coverage_file_mappings(\n        ut_coverage_file_mapping(\n          file_name    =  'sources/hr/award_bonus.prc',\n          object_owner =  'usr',\n          object_name  =  'award_bonus',\n          object_type  =  'procedure'                        \n        ),\n        ut_coverage_file_mapping(\n          file_name    =  'sources/hr/betwnstr.fnc',\n          object_owner =  'usr',\n          object_name  =  'betwnstr',\n          object_type  =  'function'                        \n        )\n      )\n    )\n  );\nend;  Executes all tests in schema  usr  and reports coverage for that execution on procedure  award_bonus  and function  betwnstr . The coverage report is mapped-back to file-system object names with paths.  Reporting using regex file mapping rule \nIf file names and paths in your project follow a well established naming conventions, \nthen you can use the predefined rule for mapping file names to object names or you can define your own rule and pass it to the coverage reporter at runtime.  Example of running with predefined regex mapping rule.  begin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_file_paths =  ut_varchar2_list('sources/hr/award_bonus.prc','sources/hr/betwnstr.fnc')\n    )\n  );\nend;  The predefined rule is based on the following default values for parameters:   a_regex_pattern =  '.*(\\\\|\\/)((\\w+)\\.)?(\\w+)\\.(\\w{3})'     a_object_owner_subexpression =  3    a_object_name_subexpression =  4    a_object_type_subexpression =  5 \n*  a_file_to_object_type_mapping  - defined in table below  The predefined file extension to object type mappings     file extension  object type      tpb  type body    pkb  package body    bdy  package body    trg  trigger    fnc  function    prc  procedure     Since package specification and type specifications are not considered by coverage, the file extensions for those objects  are not included in the mapping.  Examples of filename paths that will be mapped correctly using predefined rules.   [...]directory[/subdirectory[/...]]/object_name.(tpb|pkb|trg|fnc|prc)    [...]directory[/subdirectory[/...]]/schema_name.object_name.(tpb|pkb|trg|fnc|prc)    [...]directory[\\subdirectory[\\...]]\\object_name.(tpb|pkb|trg|fnc|prc)    [...]directory[\\subdirectory[\\...]]\\schema_name.object_name.(tpb|pkb|trg|fnc|prc)  If file names in your project structure are not prefixed with schema name (like above), the coverage report will look for objects to match the file names in the  current schema  of the connection that was used to execute tests with coverage.\nIf for whatever reasons you use a user and current schema that is different then schem that holds your project code, you should use  a_schema_name  parameter to inform coverage reporter about database schema to be used for object lookup.  Example:  begin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_schema_name =  'hr',\n      a_file_paths  =  ut_varchar2_list('sources/hr/award_bonus.prc','sources/hr/betwnstr.fnc')\n    )\n  );\nend;  If your project structure is different, you may define your own mapping rule using regex.  Example:  begin\n  ut.run(\n    'usr', \n    ut_coverage_html_reporter(\n      a_file_paths  =  ut_varchar2_list('sources/hr/procedures/award_bonus.sql','sources/hr/functions/betwnstr.sql'),\n      a_regex_pattern =  '.*(\\\\|\\/)(\\w+)\\.(\\w+)\\.(\\w{3})',\n      a_object_owner_subexpression =  2,\n      a_object_type_subexpression =  3,\n      a_object_name_subexpression =  4,\n      a_file_to_object_type_mapping =  ut_key_value_pairs(\n        ut_key_value_pair('functions', 'function'),\n        ut_key_value_pair('procedures', 'procedure')\n    )\n  );\nend;", 
            "title": "Working with projects and project files"
        }, 
        {
            "location": "/about/project-details/index.html", 
            "text": "utPLSQL Project Details\n\n\n\n\n\n\n\n\n\n\nutPLSQL is hosted on \nhosted on GitHub\n and open source project.\n\n\nCommunity help on this project is always appreciated, if your interested in helping please read our \nguide to contributing", 
            "title": "Project Details"
        }, 
        {
            "location": "/about/project-details/index.html#utplsql-project-details", 
            "text": "utPLSQL is hosted on  hosted on GitHub  and open source project.  Community help on this project is always appreciated, if your interested in helping please read our  guide to contributing", 
            "title": "utPLSQL Project Details"
        }, 
        {
            "location": "/about/license/index.html", 
            "text": "Version Information\n\n\nutPLSQL version 3\n is licensed under [Apache 2.0]\n(https://www.apache.org/licenses/LICENSE-2.0)\n\n\nExternal code used in the development of this project, but is not required for use.\n\n\n\n\n\n\n\n\nTool\n\n\nLicense\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nTravis-Oracle\n\n\nISC\n\n\nInstall Oracle for Travis Builds\n\n\n\n\n\n\nmkDocs\n\n\nBSD\n\n\nProduce HTML version of documentation\n\n\n\n\n\n\n\n\nNote:\n Version 1 \n 2 of utPLSQL were licensed under GPL, version 3 was a complete rewrite from scratch which a allowed us to change the license to a more permissive license.", 
            "title": "License"
        }, 
        {
            "location": "/about/license/index.html#version-information", 
            "text": "utPLSQL version 3  is licensed under [Apache 2.0]\n(https://www.apache.org/licenses/LICENSE-2.0)  External code used in the development of this project, but is not required for use.     Tool  License  Purpose      Travis-Oracle  ISC  Install Oracle for Travis Builds    mkDocs  BSD  Produce HTML version of documentation     Note:  Version 1   2 of utPLSQL were licensed under GPL, version 3 was a complete rewrite from scratch which a allowed us to change the license to a more permissive license.", 
            "title": "Version Information"
        }, 
        {
            "location": "/about/support/index.html", 
            "text": "How to get support\n\n\n\n\nFeel free post questions, bugs or issues]to the \nissues area of GitHub\n.\n\n\nJoin developers the \nutPLSQL team\n on \nSlack", 
            "title": "Support"
        }, 
        {
            "location": "/about/support/index.html#how-to-get-support", 
            "text": "Feel free post questions, bugs or issues]to the  issues area of GitHub .  Join developers the  utPLSQL team  on  Slack", 
            "title": "How to get support"
        }, 
        {
            "location": "/about/authors/index.html", 
            "text": "Version 3 Major Contributors\n\n\nListed Alphabetically \n\n\n\n\n\n\n\n\nName\n\n\nGitHub account\n\n\n\n\n\n\n\n\n\n\nDavid Pyke\n\n\nShoelace\n\n\n\n\n\n\nJacek Gebal\n\n\njgebal\n\n\n\n\n\n\nPavel  Kaplya\n\n\nPazus\n\n\n\n\n\n\nRobert Love\n\n\nrlove\n\n\n\n\n\n\n\n\nSpecial thanks to prior major contributors.\n\n\n\n\nSteven Feuerstein - Original Author\n\n\nChris Rimmer\n\n\nPatrick Barel\n\n\nPaul Walker", 
            "title": "Authors"
        }, 
        {
            "location": "/about/authors/index.html#version-3-major-contributors", 
            "text": "Listed Alphabetically      Name  GitHub account      David Pyke  Shoelace    Jacek Gebal  jgebal    Pavel  Kaplya  Pazus    Robert Love  rlove", 
            "title": "Version 3 Major Contributors"
        }, 
        {
            "location": "/about/authors/index.html#special-thanks-to-prior-major-contributors", 
            "text": "Steven Feuerstein - Original Author  Chris Rimmer  Patrick Barel  Paul Walker", 
            "title": "Special thanks to prior major contributors."
        }, 
        {
            "location": "/about/CONTRIBUTING/index.html", 
            "text": "How to contribute\n\n\nThe following are the guidelines, everyone should use to contribute to utPLSQL.\n\nChanges are welcome from all members of the Community. \n\n\nGetting Started\n\n\n\n\nCreate a \nGitHub Account\n.\n\n\nFork the utPLSQL Repository and setup your local Repository.\n\n\nEach of the steps below are detailed in the \nHow to Fork\n article!\n\n\nClone your Fork to your local machine.\n\n\nConfigure \"upstream\" remote to the \nmaster utPLSQL repository\n.\n\n\nUpdate the git submodules by issuing command: \ngit submodule update --remote --merge\n\n\n\n\n\n\nFor each change you want to make:       \n\n\nCreate a new branch for your change. \n\n\nMake your change in your new branch. \n\n\nAlthough changes can be made in the master branch, it easier long term if a new branch is used.\n\n\n\n\n\n\nMake sure your change is covered with unit tests and/or is represented in examples\n\n\nVerify code compiles and all existing and new unit tests pass.\n\n\nThe quickest way to have a Pull Request not be accepted, is to submit code that does not compile or pass tests.\n\n\n\n\n\n\nCommit change to your local repository.\n\n\nPush change to your remote repository\n\n\nSubmit a \nPull Request\n.\n\n\nNote: local and remote branches can be deleted after pull request has been accepted.\n\n\n\n\n\n\n\n\nNote:\n Getting changes from others requires \nSyncing your Local repository\n with Master utPLSQL repository.    This can happen at any time.\n\n\nCoding Standards\n\n\n\n\nSnake case will be used.   This separates keywords in names with underscores.  \nexecute_test\n\n\nAll names will be lower case.\n\n\nPrefixes:\n\n\nArguments to procedures and functions will start with \na_\n an Example would be procedure \nis_valid(a_owner_name varchar2);\n\n\nObject types and packages will start with \nut_\n\n\nLocal variables \nl_\n\n\nGlobal variables \ng_\n\n\nGlobal Constants start with \ngc_\n\n\nTypes in packages, objects start with \nt_\n\n\nNested Tables start with \ntt_\n\n\n\n\n\n\nvarchar2 lengths are set in characters not bytes \n\n\n\n\nNew to GIT\n\n\nIf you are new to GIT here are some links to help you with understanding how it works.    \n\n\n\n\nGIT Documentation\n\n\nAtlassian Git Tutorial\n\n\nWhat are other resources for learning Git and GitHub", 
            "title": "Contributing"
        }, 
        {
            "location": "/about/CONTRIBUTING/index.html#how-to-contribute", 
            "text": "The following are the guidelines, everyone should use to contribute to utPLSQL. \nChanges are welcome from all members of the Community.", 
            "title": "How to contribute"
        }, 
        {
            "location": "/about/CONTRIBUTING/index.html#getting-started", 
            "text": "Create a  GitHub Account .  Fork the utPLSQL Repository and setup your local Repository.  Each of the steps below are detailed in the  How to Fork  article!  Clone your Fork to your local machine.  Configure \"upstream\" remote to the  master utPLSQL repository .  Update the git submodules by issuing command:  git submodule update --remote --merge    For each change you want to make:         Create a new branch for your change.   Make your change in your new branch.   Although changes can be made in the master branch, it easier long term if a new branch is used.    Make sure your change is covered with unit tests and/or is represented in examples  Verify code compiles and all existing and new unit tests pass.  The quickest way to have a Pull Request not be accepted, is to submit code that does not compile or pass tests.    Commit change to your local repository.  Push change to your remote repository  Submit a  Pull Request .  Note: local and remote branches can be deleted after pull request has been accepted.     Note:  Getting changes from others requires  Syncing your Local repository  with Master utPLSQL repository.    This can happen at any time.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/about/CONTRIBUTING/index.html#coding-standards", 
            "text": "Snake case will be used.   This separates keywords in names with underscores.   execute_test  All names will be lower case.  Prefixes:  Arguments to procedures and functions will start with  a_  an Example would be procedure  is_valid(a_owner_name varchar2);  Object types and packages will start with  ut_  Local variables  l_  Global variables  g_  Global Constants start with  gc_  Types in packages, objects start with  t_  Nested Tables start with  tt_    varchar2 lengths are set in characters not bytes", 
            "title": "Coding Standards"
        }, 
        {
            "location": "/about/CONTRIBUTING/index.html#new-to-git", 
            "text": "If you are new to GIT here are some links to help you with understanding how it works.       GIT Documentation  Atlassian Git Tutorial  What are other resources for learning Git and GitHub", 
            "title": "New to GIT"
        }
    ]
}