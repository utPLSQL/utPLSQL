{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Index","text":""},{"location":"index.html#what-is-utplsql","title":"What is utPLSQL","text":"<p>utPLSQL is a Unit Testing framework for Oracle PL/SQL. The framework follows industry standards and best patterns of modern Unit Testing frameworks like JUnit and RSpec</p>"},{"location":"index.html#demo-project","title":"Demo project","text":"<p>Have a look at utPLSQL demo project to see:</p> <ul> <li>sample code and tests</li> <li>demo of deployment automation that leverages:</li> <li>Flyway / Liquidbase for scripting and deployment of DB changes </li> <li>Docker container with Oracle XE Database</li> <li>GitHub Actions and Azure Pipelines to orchestrate the deployment and testing process</li> <li>utPLSQL framework for writhing, execution of tests as well as reporting test results and code coverage</li> <li>Sonar for code quality gate, test results and code coverage reporting  </li> </ul>"},{"location":"index.html#three-steps","title":"Three steps","text":"<p>With just three simple steps you can define and run your unit tests for PLSQL code.</p> <ol> <li>Install the utPLSQL framework </li> <li>Create Unit Tests to for the code</li> <li>Run the tests</li> </ol> <p>Here is how you can simply create tested code, unit tests and execute the tests using SQL Developer</p> <p></p> <p>Check out the sections on annotations and expectations to see how to define your tests.  </p>"},{"location":"index.html#command-line","title":"Command line","text":"<p>You can use the utPLSQL command line client utPLSQL-cli to run tests without the need for Oracle Client or any IDE like SQLDeveloper/TOAD etc.</p> <p>Amongst many benefits they provide ability to:</p> <ul> <li>see the progress of test execution for long-running tests - real-time reporting</li> <li>use many reporting formats simultaneously and save reports to files (publish)</li> <li>map your project source files and test files into database objects </li> </ul> <p>Download the latest client and you are good to go. See project readme for details.  </p>"},{"location":"index.html#coverage","title":"Coverage","text":"<p>It is best to use utPLSQL-cli or execute tests and gather code coverage from command line. Check out the coverage documentation for options of coverage reporting</p>"},{"location":"compare_version2_to_3.html","title":"Compare version2 to 3","text":"<p>For version 3 has been a complete rewrite of the framework, the way it can be used is different to the previous versions, but also more in line with other modern unit-testing frameworks like JUnit and RSpec.</p> <p>There is a migration tool that can help you to migrate your existing utPLSQL v2 tests to the v3 capabilities. </p>"},{"location":"compare_version2_to_3.html#feature-comparison","title":"Feature comparison","text":"Feature Version 2 Version 3 Easy to install Yes Yes Documentation Yes Yes License GPL v2 Apache 2.0 Tests Creation Declarative test configuration No Yes - Annotations<sup>1</sup> Tests as Packages Yes Yes Multiple Tests in a single Package Yes Yes Optional Setup/Teardown No Yes Different Setup/Teardown  For Each Test in a Single Package No Yes - Annotations<sup>1</sup> Suite Definition Storage Tables Package - Annotations<sup>1</sup> Multiple Suites Yes Yes Suites can contain Suites No Yes Automatic Test detection No Yes - Annotations<sup>1</sup> Unconstrained naming of Test packages No - prefixes Yes - name not relevant Require Prefix on Test procedures No - prefixes Yes - name not relevant Auto Compilation of Tests Yes No (Let us know if you use this) Assertion Library 30 assertions<sup>2</sup> 26 matchers (13 + 13 negated) Extendable assertions No Yes - custom matchers PLSQL Record Assertions generated code through utRecEq Package possible on Oracle 12c+ using cursor matchers Test Skeleton Generation Yes No (Let us know if you use this) Test Execution<sup>3</sup> Single Test Package Execution Yes Yes Single Test Procedure Execution No Yes Test Suite Execution Yes Yes Subset of Suite Execution No Yes Multiple Suite Execution No Yes Organizing Suites into hierarchies No Yes Code Coverage Reporting No Yes Html Coverage Report No Yes Sonar XML Coverage Report No Yes Coveralls Json Coverage Report No Yes Framework Transaction Control No Yes - Annotations<sup>1</sup> Test Output Real-time test execution progress reporting No Yes Multiple Output Reporters can be used during test execution No Yes DBMS_OUTPUT Yes Yes (clean formatting) File Yes (to db server only) Yes (on client side) Stored in Table Yes No (can be added as custom reporter) XUnit format support No Yes HTML Format Yes No Custom Output reporter Yes-needs configuration Yes - no config needed <p><sup>1</sup> Annotations are specially formatted comments in your package specification.  This enables declarative test configuration that is coupled with the source code.   See Documentation for more details. </p> <p><sup>2</sup> utAssert2 package - Contains 59 Assertions - 2 Not implemented = 57, 28 are duplicated only change on outcome_in parameter 57-28 = 29, utPipe package - Contains 1 Assertion 29 + 1 = 30</p> <p><sup>3</sup> Test execution comparison is in a single call so the results are combined.   We know it was always possible to group in any way with multiple calls.  But that may not be desired under a CI system where you want a single JUnit XML Output.</p>"},{"location":"about/authors.html","title":"Authors","text":""},{"location":"about/authors.html#utplsql-v3-major-contributors","title":"utPLSQL v3 Major Contributors","text":"<p>Listed Alphabetically </p> Name GitHub account David Pyke Shoelace Jacek Gebal jgebal Lukasz Wasylow lwasylow Pavel  Kaplya Pazus Robert Love rlove Samuel Nitsche pesse Vinicius Avellar viniciusam <p>Many thanks to all the contributors</p>"},{"location":"about/authors.html#special-thanks-to-prior-major-contributors","title":"Special thanks to prior major contributors","text":"<ul> <li>Steven Feuerstein - Original Author</li> <li>Chris Rimmer</li> <li>Patrick Barel</li> <li>Paul Walker</li> </ul>"},{"location":"about/license.html","title":"License","text":""},{"location":"about/license.html#version-information","title":"Version Information","text":"<p>utPLSQL version 3 is licensed under  Apache 2.0</p> <p>External code used in the development of this project, but is not required for use.</p> Tool License Purpose Travis-Oracle ISC Install Oracle for Travis Builds mkDocs BSD Produce HTML version of documentation <p>Note: </p> <p>Version 1 &amp; 2 of utPLSQL were licensed under GPL, version 3 was a complete rewrite from scratch which a allowed us to change the license to be more permissive.</p>"},{"location":"about/project-details.html","title":"Project Details","text":""},{"location":"about/project-details.html#utplsql-project-details","title":"utPLSQL Project Details","text":"<p>utPLSQL is open source project hosted on GitHub.</p> <p>Contributions, help and constructive feedback is always appreciated.</p> <p>If you are interested in helping please read our contributing guide</p>"},{"location":"about/support.html","title":"Support","text":""},{"location":"about/support.html#how-to-get-support","title":"How to get support","text":"<ul> <li>Feel free to post questions, bugs or issues in the issues area of GitHub</li> <li>Join developers team on utPLSQL Slack</li> </ul>"},{"location":"userguide/advanced_data_comparison.html","title":"Advanced data comparison","text":""},{"location":"userguide/advanced_data_comparison.html#advanced-data-comparison","title":"Advanced data comparison","text":"<p>utPLSQL expectations incorporates advanced data comparison options when comparing compound data-types:</p> <ul> <li>refcursor</li> <li>object type</li> <li>nested table and varray  </li> <li>json data-types</li> </ul> <p>Advanced data-comparison options are available for the <code>equal</code> and  <code>contain</code> matcher.</p> <p>Syntax</p> <pre><code>  ut.expect( a_actual {data-type} ).to_( equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]);\n  ut.expect( a_actual {data-type} ).not_to( equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]) );\n  ut.expect( a_actual {data-type} ).to_equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]);\n  ut.expect( a_actual {data-type} ).not_to_equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]] );\n  ut.expect( a_actual {data-type} ).to_( contain( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]);\n  ut.expect( a_actual {data-type} ).not_to( contain( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]) );\n  ut.expect( a_actual {data-type} ).to_contain( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]);\n  ut.expect( a_actual {data-type} ).not_to_contain( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]);\n</code></pre> <p><code>extended_option</code> can be one of:</p> <ul> <li><code>include(a_items varchar2)</code> - item or comma separated list of items to include</li> <li><code>exclude(a_items varchar2)</code> - item or comma separated list of items to exclude</li> <li><code>include(a_items ut_varchar2_list)</code> - table of items to include </li> <li><code>exclude(a_items ut_varchar2_list)</code> - table of items to exclude</li> <li><code>unordered</code> - ignore order of data sets when comparing data. Default when comparing data-sets with  <code>to_contain</code> </li> <li><code>join_by(a_columns varchar2)</code> - column or comma separated list of columns to join two cursors by</li> <li><code>join_by(a_columns ut_varchar2_list)</code> - table of columns to join two cursors by</li> <li><code>unordered_columns</code> / <code>uc</code> - ignore the ordering of columns / attributes in compared data-sets. Column/attribute names will be used to identify data to be compared and the position will be ignored. </li> </ul> <p>Each item in the comma separated list can be: - a column name of cursor to be compared - an attribute name of object type to be compared  - an attribute name of object type within a table of objects to be compared - Include and exclude option will not support implicit colum names that starts with single quota, or in fact any other special characters e.g. &lt;, &gt;, &amp;</p> <p>Each element in <code>ut_varchar2_list</code> nested table can be an item or a comma separated list of items.</p> <p>When specifying column/attribute names, keep in mind that the names are case sensitive. </p>"},{"location":"userguide/advanced_data_comparison.html#excluding-elements-from-data-comparison","title":"Excluding elements from data comparison","text":"<p>Consider the following examples <pre><code>declare\n  l_expected sys_refcursor;\n  l_actual   sys_refcursor;\nbegin\n  open l_expected for select 'text' ignore_me, d.* from user_tables d;\n  open l_actual   for select sysdate \"ADate\",  d.* from user_tables d;\n  ut.expect( l_actual ).to_equal( l_expected ).exclude( 'IGNORE_ME,ADate' );\nend;\n/\ndeclare\n  l_expected sys_refcursor;\n  l_actual   sys_refcursor;\nbegin\n  open l_expected for select 'text' ignore_me, d.* from user_tables d where rownum = 1;\n  open l_actual   for select sysdate \"ADate\",  d.* from user_tables d;\n  ut.expect( l_actual ).to_contain( l_expected ).exclude( 'IGNORE_ME,ADate' );\nend;\n/\n</code></pre> Produces: <pre><code>SUCCESS\n  Actual: refcursor [ count = 23 ] was expected to equal: refcursor [ count = 23 ]\n\nSUCCESS\n  Actual: refcursor [ count = 23 ] was expected to contain: refcursor [ count = 1 ]\n</code></pre></p> <p>Columns 'ignore_me' and \"ADate\" will get excluded from data comparison. The actual data is equal/contains expected, when those columns are excluded.</p> <p>Note</p> <p>This option is useful in scenarios, when you need to exclude incomparable/unpredictable column data like CREATE_DATE of a record that is maintained by default value on a table column.</p>"},{"location":"userguide/advanced_data_comparison.html#selecting-columns-for-data-comparison","title":"Selecting columns for data comparison","text":"<p>Consider the following example <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_expected for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL from dual a connect by level &lt; 4;\n  open l_actual   for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL, a.* from all_objects a where rownum &lt; 4;\n  ut.expect( l_actual ).to_equal( l_expected ).include( 'RN,A_Column,SOME_COL' );\nend;\n/\ndeclare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_expected for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL from dual a connect by level &lt; 4;\n  open l_actual   for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL, a.* from all_objects a where rownum &lt; 6;\n  ut.expect( l_actual ).to_contain( l_expected ).include( 'RN,A_Column,SOME_COL' );\nend;\n/\n</code></pre> Produces: <pre><code>SUCCESS\n  Actual: refcursor [ count = 3 ] was expected to equal: refcursor [ count = 3 ]\n\nSUCCESS\n  Actual: refcursor [ count = 5 ] was expected to contain: refcursor [ count = 3 ]\n</code></pre></p> <p>Only columns <code>RN</code>,<code>A_Column</code> and <code>SOME_COL</code>  will be included in data comparison. The actual data is equal/contains expected, when only those columns are included.</p> <p>Note</p> <p>This option can be useful in scenarios where you need to narrow-down the scope of test so that the test is only focused on very specific data.  </p>"},{"location":"userguide/advanced_data_comparison.html#combining-includeexclude-options","title":"Combining include/exclude options","text":"<p>You can chain the advanced options in an expectation and mix the <code>varchar2</code> with <code>ut_varchar2_list</code> arguments. When doing so, the final list of items to include/exclude will be a concatenation of all items.   </p> <pre><code>declare\n    l_actual   sys_refcursor;\n    l_expected sys_refcursor;\nbegin\n    open l_expected for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL from dual a connect by level &lt; 4;\n    open l_actual   for select rownum as rn, 'a' as \"A_Column\", 'Y' SOME_COL, a.* from all_objects a where rownum &lt; 4;\n    ut.expect( l_actual ).to_equal( l_expected )\n      .include( 'RN')\n      .include( ut_varchar2_list( 'A_Column', 'SOME_COL' ) )\n      .exclude( 'SOME_COL' );\nend;\n/\ndeclare\n    l_actual   sys_refcursor;\n    l_expected sys_refcursor;\nbegin\n    open l_expected for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL from dual a connect by level &lt; 4;\n    open l_actual   for select rownum as rn, 'a' as \"A_Column\", 'Y' SOME_COL, a.* from all_objects a where rownum &lt; 6;\n    ut.expect( l_actual ).to_contain( l_expected )\n      .include( 'RN')\n      .include( ut_varchar2_list( 'A_Column', 'SOME_COL' ) )\n      .exclude( 'SOME_COL' );\nend;\n/\n</code></pre> <p>Results: <pre><code>SUCCESS\n  Actual: refcursor [ count = 3 ] was expected to equal: refcursor [ count = 3 ]\n\nSUCCESS\n  Actual: refcursor [ count = 5 ] was expected to contain: refcursor [ count = 3 ]\n</code></pre></p> <p>Example of <code>include / exclude</code> for anydata.convertCollection</p> <pre><code>create or replace type person as object(\n  name varchar2(100),\n  age  integer\n)\n/\ncreate or replace type people as table of person\n/\n\ndeclare\n  l_actual           people := people(person('Matt',45));\n  l_expected         people :=people(person('Matt',47));\nbegin\n  ut3.ut.expect(anydata.convertCollection(l_actual)).to_equal(anydata.convertCollection(l_expected)).include('NAME');  \nend;\n\ndeclare\n  l_actual           people := people(person('Matt',45));\n  l_expected         people :=people(person('Matt',47));\nbegin\n  ut3.ut.expect(anydata.convertCollection(l_actual)).to_equal(anydata.convertCollection(l_expected)).exclude('AGE');   \nend;\n\ndeclare\n  l_actual           people := people(person('Matt',45));\n  l_expected         people :=people(person('Matt',47));\nbegin\n  ut3.ut.expect(anydata.convertCollection(l_actual)).to_equal(anydata.convertCollection(l_expected)).include('AGE');   \nend;\n/\n</code></pre> <p>Results: <pre><code>SUCCESS\n  Actual: ut3.people [ count = 1 ] was expected to equal: ut3.people [ count = 1 ]\n\nSUCCESS\n  Actual: ut3.people [ count = 1 ] was expected to equal: ut3.people [ count = 1 ]\n\nFAILURE\n  Actual: ut3.people [ count = 1 ] was expected to equal: ut3.people [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Actual:   &lt;AGE&gt;45&lt;/AGE&gt;\n    Row No. 1 - Expected: &lt;AGE&gt;47&lt;/AGE&gt;\n  at \"anonymous block\", line 5\n</code></pre></p>"},{"location":"userguide/advanced_data_comparison.html#unordered","title":"Unordered","text":"<p>Unordered option allows for quick comparison of two compound data types without need of ordering them in any way.</p> <p>Result of such comparison will be limited to only information about row existing or not existing in given set without actual information about exact differences.</p> <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_expected for\n    select username, user_id from all_users\n    union all\n    select 'TEST' username, -600 user_id from dual\n    order by 1 desc;\n  open l_actual for \n    select username, user_id from all_users\n    union all\n    select 'TEST' username, -610 user_id from dual\n    order by 1 asc;\n  ut.expect( l_actual ).to_equal( l_expected ).unordered;\nend;\n/\n</code></pre> <p>Above test will result in two differences of one row extra and one row missing.  <pre><code>FAILURE\n  Actual: refcursor [ count = 29 ] was expected to equal: refcursor [ count = 29 ]\n  Diff:\n  Rows: [ 2 differences ]\n  Extra:    &lt;USERNAME&gt;TEST&lt;/USERNAME&gt;&lt;USER_ID&gt;-610&lt;/USER_ID&gt;\n  Missing:  &lt;USERNAME&gt;TEST&lt;/USERNAME&gt;&lt;USER_ID&gt;-600&lt;/USER_ID&gt;\n  at \"anonymous block\", line 15\n</code></pre> Note</p> <p>Consider using <code>join_by( columns... )</code> over <code>unordered()</code> with the <code>equal</code> matcher. The <code>join_by</code> method is much faster at performing data comparison.</p> <p>The <code>contain</code> matcher is not considering the order of the compared data-sets. Using <code>unordered</code> makes no difference (it's default).</p>"},{"location":"userguide/advanced_data_comparison.html#join-by-option","title":"Join By option","text":"<p>The <code>join_by</code> syntax enables comparison of unordered compound data types by joining data using specified columns. </p> <p>You can join two compound data types by defining join column(s) that will be used to uniquely identify and compare data rows.  With this option, framework is able to identify which rows are missing, which are extra and which are different without need to have both cursors uniformly ordered.  When the specified join column(s) are not unique, join will partition set over rows with the same key and join on row number as well as given join key.  The extra or missing rows will be presented to user as well as all non-matching rows. </p> <p>Join by option can be used in conjunction with include or exclude options.  However if any of the join keys is part of exclude set, comparison will fail and report to user that sets could not be joined on specific key, as the key was excluded.</p> <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_expected for \n    select username, user_id from all_users\n    union all\n    select 'TEST' username, -600 user_id from dual\n    order by 1 desc;\n  open l_actual for \n    select username, user_id from all_users\n    union all\n    select 'TEST' username, -610 user_id from dual\n    order by 1 asc;\n  ut.expect( l_actual ).to_equal( l_expected ).join_by('USERNAME');\nend;\n/\n</code></pre> <p>Above test will result in a difference in row 'TEST' regardless of data order. <pre><code>FAILURE\n  Actual: refcursor [ count = 29 ] was expected to equal: refcursor [ count = 29 ]\n  Diff:\n  Rows: [ 1 differences ]\n    PK &lt;USERNAME&gt;TEST&lt;/USERNAME&gt; - Actual:   &lt;USER_ID&gt;-610&lt;/USER_ID&gt;\n    PK &lt;USERNAME&gt;TEST&lt;/USERNAME&gt; - Expected: &lt;USER_ID&gt;-600&lt;/USER_ID&gt;\n    PK &lt;USERNAME&gt;TEST&lt;/USERNAME&gt; - Extra:    &lt;USERNAME&gt;TEST&lt;/USERNAME&gt;&lt;USER_ID&gt;-610&lt;/USER_ID&gt;\n  at \"anonymous block\", line 15\n</code></pre></p> <p>Note </p> <p>When using <code>join_by</code>, the join column(s) are displayed first (as PK) to help you identify the mismatched rows/columns.</p> <p>You can use <code>join_by</code> syntax in combination with <code>contain</code> matcher.</p> <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_actual   for select username, user_id from all_users;\n  open l_expected for \n    select username, user_id from all_users\n    union all\n    select 'TEST' username, -610 user_id from dual;\n\n  ut.expect( l_actual ).to_contain( l_expected ).join_by('USERNAME');\nend;\n/\n</code></pre> <p>Above test will indicate that in actual data-set <pre><code>FAILURE\n  Actual: refcursor [ count = 28 ] was expected to contain: refcursor [ count = 29 ]\n  Diff:\n  Rows: [ 1 differences ]\n    PK &lt;USERNAME&gt;TEST&lt;/USERNAME&gt; - Missing:  &lt;USERNAME&gt;TEST&lt;/USERNAME&gt;&lt;USER_ID&gt;-610&lt;/USER_ID&gt;\n  at \"anonymous block\", line 11\n</code></pre></p>"},{"location":"userguide/advanced_data_comparison.html#joining-using-multiple-columns","title":"Joining using multiple columns","text":"<p>You can specify multiple columns in <code>join_by</code></p> <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_expected for\n    select username, user_id, created from all_users\n     order by 1 desc;\n  open l_actual for\n    select username, user_id, created  from all_users\n     union all\n    select 'TEST' username, -610 user_id, sysdate from dual\n     order by 1 asc;\n  ut.expect( l_actual ).to_equal( l_expected ).join_by('USERNAME, USER_ID');\nend;\n/\n</code></pre> <p>Produces: <pre><code>FAILURE\n  Actual: refcursor [ count = 29 ] was expected to equal: refcursor [ count = 28 ]\n  Diff:\n  Rows: [ 1 differences ]\n    PK &lt;USERNAME&gt;TEST&lt;/USERNAME&gt;&lt;USER_ID&gt;-610&lt;/USER_ID&gt; - Extra:    &lt;USERNAME&gt;TEST&lt;/USERNAME&gt;&lt;USER_ID&gt;-610&lt;/USER_ID&gt;&lt;CREATED&gt;2019-07-11&lt;/CREATED&gt;\n  at \"anonymous block\", line 13 \n</code></pre></p>"},{"location":"userguide/advanced_data_comparison.html#joining-using-attributes-of-object-in-column-list","title":"Joining using attributes of object in column list","text":"<p><code>join_by</code> allows for joining data by attributes of object from column list of the compared compound data types.</p> <p>To reference attribute as PK, use slash symbol <code>/</code> to separate nested elements.</p> <p>In the below example, cursors are joined using the <code>NAME</code> attribute of object in column <code>SOMEONE</code></p> <pre><code>create or replace type person as object(\n  name varchar2(100),\n  age  integer\n)\n/\ncreate or replace type people as table of person\n/\n\ndeclare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_expected for\n    select person('Jack',42) someone from dual union all\n    select person('Pat', 44) someone from dual union all\n    select person('Matt',45) someone from dual;\n  open l_actual for\n    select person('Matt',55) someone from dual union all\n    select person('Pat', 44) someone from dual;\n  ut.expect( l_actual ).to_equal( l_expected ).join_by( 'SOMEONE/NAME' );\nend;\n/\n</code></pre> <p>Produces: <pre><code>FAILURE\n  Actual: refcursor [ count = 2 ] was expected to equal: refcursor [ count = 3 ]\n  Diff:\n  Rows: [ 2 differences ]\n    PK &lt;NAME&gt;Matt&lt;/NAME&gt; - Actual:   &lt;SOMEONE&gt;&lt;NAME&gt;Matt&lt;/NAME&gt;&lt;AGE&gt;55&lt;/AGE&gt;&lt;/SOMEONE&gt;\n    PK &lt;NAME&gt;Matt&lt;/NAME&gt; - Actual:   &lt;AGE&gt;55&lt;/AGE&gt;\n    PK &lt;NAME&gt;Matt&lt;/NAME&gt; - Expected: &lt;SOMEONE&gt;&lt;NAME&gt;Matt&lt;/NAME&gt;&lt;AGE&gt;45&lt;/AGE&gt;&lt;/SOMEONE&gt;\n    PK &lt;NAME&gt;Matt&lt;/NAME&gt; - Expected: &lt;AGE&gt;45&lt;/AGE&gt;\n    PK &lt;NAME&gt;Jack&lt;/NAME&gt; - Missing:  &lt;SOMEONE&gt;&lt;NAME&gt;Jack&lt;/NAME&gt;&lt;AGE&gt;42&lt;/AGE&gt;&lt;/SOMEONE&gt;\n  at \"anonymous block\", line 12\n</code></pre></p> <p>Note</p> <p><code>join_by</code> does not support joining on individual elements of nested table. You can still use data of the nested table as a PK value. When collection is referenced in <code>join_by</code>, test will fail with appropriate message, as it cannot perform a join.</p> <pre><code>create or replace type person as object(\n  name varchar2(100),\n  age  integer\n)\n/\ncreate or replace type people as table of person\n/\n\ncreate or replace package body test_join_by is\n  procedure test_join_by_collection_elem is\n    l_actual   sys_refcursor;\n    l_expected sys_refcursor;\n  begin\n    open l_expected for select people(person('Matt',45)) persons from dual;\n    open l_actual for select people(person('Matt',45)) persons from dual;\n    ut.expect( l_actual ).to_equal( l_expected ).join_by('PERSONS/PERSON/NAME');\n  end;\n\nend;\n/\n</code></pre> <pre><code>FAILURE\n  Actual: refcursor [ count = 1 ] was expected to equal: refcursor [ count = 1 ]\n  Diff:\n  Unable to join sets:\n    Join key PERSONS/PERSON/NAME does not exists in expected\n    Join key PERSONS/PERSON/NAME does not exists in actual\n    Please make sure that your join clause is not refferring to collection element\n\n  at \"anonymous block\", line 7\n</code></pre> <p>Note</p> <p><code>join_by</code> option is slower to process as it needs to perform a cursor join. It is still faster than the <code>unordered</code>. </p>"},{"location":"userguide/advanced_data_comparison.html#defining-item-lists-in-option","title":"Defining item lists in option","text":"<p>You may provide items for <code>include</code>/<code>exclude</code>/<code>join_by</code> as a single varchar2 value containing comma-separated list of attributes.</p> <p>You may provide items for <code>include</code>/<code>exclude</code>/<code>join_by</code> as a a ut_varchar2_list of attributes.   </p> <p>Note - object type attributes are nested under <code>&lt;OBJECTY_TYPE&gt;</code> element - nested table and varray items type attributes are nested under <code>&lt;ARRAY&gt;&lt;OBJECTY_TYPE&gt;</code> elements</p> <p>Example of a valid parameter to include columns: <code>RN</code>, <code>A_Column</code>, <code>SOME_COL</code> in data comparison.  <pre><code>declare\n    l_actual   sys_refcursor;\n    l_expected sys_refcursor;\nbegin\n    open l_expected for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL from dual a connect by level &lt; 4;\n    open l_actual   for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL, a.* from all_objects a where rownum &lt; 4;\n    ut.expect( l_actual ).to_equal( l_expected ).include( 'RN,A_Column,SOME_COL' );\n    open l_expected for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL from dual a connect by level &lt; 4;\n    open l_actual   for select rownum as rn, 'a' as \"A_Column\", 'x' SOME_COL, a.* from all_objects a where rownum &lt; 4;\n    ut.expect( l_actual ).to_equal( l_expected ).include( ut_varchar2_list( 'RN', 'A_Column', 'SOME_COL' ) );\nend;\n/\n</code></pre></p> <pre><code>SUCCESS\n  Actual: refcursor [ count = 3 ] was expected to equal: refcursor [ count = 3 ]\nSUCCESS\n  Actual: refcursor [ count = 3 ] was expected to equal: refcursor [ count = 3 ]\n</code></pre>"},{"location":"userguide/advanced_data_comparison.html#unordered-columns-uc-option","title":"Unordered columns / uc option","text":"<p>If you need to perform data comparison of compound data types without strictly depending on column order in the returned result-set, use the <code>unordered_columns</code> option. Shortcut name <code>uc</code> is also available for that option.</p> <p>Expectations that compare compound data type data with <code>unordered_columns</code> option, will not fail when columns are ordered differently.</p> <p>This option can be useful whn we have no control over the ordering of the column or the column order is not of importance from testing perspective.</p> <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  --Arrange\n  open   l_actual for select owner, object_name, object_type from all_objects where owner = user\n  order by 1,2,3 asc;\n  open l_expected for select object_type, owner, object_name from all_objects where owner = user\n  and rownum &lt; 20;\n\n  --Assert\n  ut.expect(l_actual).to_contain(l_expected).unordered_columns();\nend;\n/\n</code></pre> <p>Produces: <pre><code>SUCCESS\n  Actual: refcursor [ count = 348 ] was expected to contain: refcursor [ count = 19 ]\n</code></pre></p>"},{"location":"userguide/annotations.html","title":"Annotations","text":"<p>Annotations are used to configure tests and suites in a declarative way similar to modern OOP languages. This way, test configuration is stored along with the test logic inside the test package. No additional configuration files or tables are needed for test cases. The annotation names are based on popular testing frameworks such as JUnit. The framework runner searches for all the suitable annotated packages, automatically configures suites, forms the suite hierarchy, executes it and reports results in specified formats.</p> <p>Annotation is defined by:</p> <ul> <li>single line comment <code>--</code> (double hyphen)</li> <li>followed directly by a <code>%</code> (percent)</li> <li>followed by annotation name </li> <li>followed by optional annotation text placed in single brackets. </li> </ul> <p>All text between first opening bracket and last closing bracket in annotation line is considered to be annotation text</p> <p>For example  <code>--%suite(The name of my test suite)</code> represents <code>suite</code> annotation with <code>The name of my test suite</code> as annotation text.  </p> <p>utPLSQL interprets the whole line of annotation and will treat text from the first opening bracket in the line to the last closing bracket in that line as annotation text </p> <p>In below example we have a <code>suite</code> annotation with <code>Stuff) -- we should name this ( correctly</code> as the annotation text</p> <p><code>--%suite(Stuff) -- we should name this ( correctly )</code></p> <p>Do not place comments within annotation line to avoid unexpected behaviors.</p> <p>Note:</p> <p>Annotations are interpreted only in the package specification and are case-insensitive. We strongly recommend using lower-case annotations as described in this documentation.</p> <p>There are two distinct types of annotations, identified by their location in package. - package annotations - procedure annotations</p>"},{"location":"userguide/annotations.html#procedure-level-annotations","title":"Procedure level annotations","text":"<p>Annotation placed directly before a procedure (<code>--%test</code>, <code>--%beforeall</code>, <code>--%beforeeach</code> etc.). There can not be any empty lines or comments between annotation line and procedure line. There can be many annotations for a procedure. </p> <p>Valid procedure annotations example: <pre><code>package test_package is\n  --%suite\n\n\n  --%test()\n  --%disabled\n  procedure my_first_procedure;\n\n  $if dbms_db_version.version &gt;= 12 $then --This is ok - annotation before procedure \n  --%test() \n  procedure my_first_procedure;\n  $end\n\n  --A comment goes before annotations\n  --%test()\n  procedure my_first_procedure;\nend;\n</code></pre></p> <p>Invalid procedure annotations examples: <pre><code>package test_package is\n  --%suite\n\n  --%test()   --This is wrong as there is an empty line between procedure and annotation\n\n  procedure my_first_procedure;\n\n  --%test()\n  --This is wrong as there is a comment line between procedure and annotation\n  procedure proc1;\n\n  --%test() --This is wrong as there is a compiler directive between procedure and annotation\n  $if dbms_db_version.version &gt;= 12 $then  \n  procedure proc_12;\n  $end\n\n  --%test()  \n  -- procedure another_proc; \n  /* The above is wrong as the procedure is commented out \n     and annotation is not procedure annotation anymore */\n\nend;\n</code></pre></p>"},{"location":"userguide/annotations.html#package-level-annotations","title":"Package level annotations","text":"<p>Those annotations placed at any place in package except directly before procedure (<code>--%suite</code>, <code>--%suitepath</code> etc.). We strongly recommend putting package level annotations at the very top of package except for the <code>--%context</code> annotations (described below)  </p> <p>Valid package annotations example: <pre><code>package test_package is\n\n  --%suite\n\n  --%suitepath(org.utplsql.example) \n\n  --%beforeall(some_package.some_procedure)\n\n  --%context\n\n  --%test()\n  procedure my_first_procedure;\n  --%endcontext\nend;\n</code></pre></p> <p>Invalid  package annotations examples: <pre><code>package test_package is\n  --%suite               --This is wrong as suite annotation is not a procedure annotation\n  procedure irrelevant;\n\n  --%context  --This is wrong as there is no empty line between package level annotation and procedure level annotation\n  --%test()   \n  procedure my_first_procedure;\n\nend;\n</code></pre></p>"},{"location":"userguide/annotations.html#supported-annotations","title":"Supported annotations","text":"Annotation Level Description <code>--%suite( &lt;description&gt; )</code> Package Mandatory. Marks package as a test suite. Optional suite description can be provided (see <code>displayname</code>). <code>--%suitepath( &lt;path&gt; )</code> Package Similar to java package. The annotation allows logical grouping of suites into hierarchies. <code>--%displayname( &lt;description&gt; )</code> Package/procedure Human-readable and meaningful description of a context/suite/test. Overrides the <code>&lt;description&gt;</code> provided with <code>suite</code>/<code>test</code>/<code>context</code> annotation. This annotation is redundant and might be removed in future releases. <code>--%test( &lt;description&gt; )</code> Procedure Denotes that the annotated procedure is a unit test procedure.  Optional test description can be provided (see <code>displayname</code>). <code>--%throws( &lt;exception&gt;[,...] )</code> Procedure Denotes that the annotated test procedure must throw one of the exceptions provided. Supported forms of exceptions are: numeric literals, numeric constant names, exception constant names, predefined Oracle exception names. <code>--%beforeall</code> Procedure Denotes that the annotated procedure should be executed once before all elements of the suite. <code>--%beforeall( [[&lt;owner&gt;.]&lt;package&gt;.]&lt;procedure&gt;[,...] )</code> Package Denotes that the mentioned procedure(s) should be executed once before all elements of the suite. <code>--%afterall</code> Procedure Denotes that the annotated procedure should be executed once after all elements of the suite. <code>--%afterall( [[&lt;owner&gt;.]&lt;package&gt;.]&lt;procedure&gt;[,...] )</code> Package Denotes that the mentioned procedure(s) should be executed once after all elements of the suite. <code>--%beforeeach</code> Procedure Denotes that the annotated procedure should be executed before each <code>%test</code> procedure in the suite. <code>--%beforeeach( [[&lt;owner&gt;.]&lt;package&gt;.]&lt;procedure&gt;[,...] )</code> Package Denotes that the mentioned procedure(s) should be executed before each <code>%test</code> procedure in the suite. <code>--%aftereach</code> Procedure Denotes that the annotated procedure should be executed after each <code>%test</code> procedure in the suite. <code>--%aftereach( [[&lt;owner&gt;.]&lt;package&gt;.]&lt;procedure&gt;[,...] )</code> Package Denotes that the mentioned procedure(s) should be executed after each <code>%test</code> procedure in the suite. <code>--%beforetest( [[&lt;owner&gt;.]&lt;package&gt;.]&lt;procedure&gt;[,...] )</code> Procedure Denotes that mentioned procedure(s) should be executed before the annotated <code>%test</code> procedure. <code>--%aftertest( [[&lt;owner&gt;.]&lt;package&gt;.]&lt;procedure&gt;[,...] )</code> Procedure Denotes that mentioned procedure(s) should be executed after the annotated <code>%test</code> procedure. <code>--%rollback( &lt;type&gt; )</code> Package/procedure Defines transaction control. Supported values: <code>auto</code>(default) - a savepoint is created before invocation of each \"before block\" is and a rollback to specific savepoint is issued after each \"after\" block; <code>manual</code> - rollback is never issued automatically. Property can be overridden for child element (test in suite) <code>--%disabled( &lt;reason&gt; )</code> Package/procedure Used to disable a suite, whole context or a test. Disabled suites/contexts/tests do not get executed, they are however marked and reported as disabled in a test run. The reason that will be displayed next to disabled tests is decided based on hierarchy suites -&gt; context -&gt; test <code>--%context( &lt;description&gt; )</code> Package Denotes start of a named context (sub-suite) in a suite package an optional description for context can be provided. <code>--%name( &lt;name&gt; )</code> Package Denotes name for a context. Must be placed after the context annotation and before start of nested context. <code>--%endcontext</code> Package Denotes end of a nested context (sub-suite) in a suite package <code>--%tags</code> Package/procedure Used to label a test or a suite for purpose of identification"},{"location":"userguide/annotations.html#suite","title":"Suite","text":"<p>The <code>--%suite</code> annotation denotes PLSQL package as a unit test suite. It accepts an optional description that will be visible when running the tests. When description is not provided, package name is displayed on report.</p> <p>Note</p> <p>Package is considered a test-suite only when package specification contains the <code>--%suite</code> annotation at the package level.</p> <p>Some annotations like <code>--%suite</code>, <code>--%test</code> and <code>--%displayname</code> accept parameters. The parameters for annotations need to be placed in brackets. Values for parameters should be provided without any quotation marks. If the parameters are placed without brackets or with incomplete brackets, they will be ignored.</p> <p>Example: <code>--%suite(The name of suite without closing bracket</code> Example: <code>--%suite The name of suite without brackets</code></p> <p>Suite package without description. <pre><code>create or replace package test_package as\n  --%suite\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>test_package\n\nFinished in .002415 seconds\n0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Suite package with description. <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n\nFinished in .001646 seconds\n0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>When multiple <code>--%suite</code> annotations are specified in package, the first annotation will be used and a warning message will appear indicating duplicate annotation. <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n  --%suite(Bad annotation)\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n\n\nWarnings:\n\n  1) test_package\n      Duplicate annotation \"--%suite\". Annotation ignored.\n      at \"TESTS_OWNER.TEST_PACKAGE\", line 3\n\nFinished in .003318 seconds\n0 tests, 0 failed, 0 errored, 0 disabled, 1 warning(s)\n</code></pre></p> <p>When <code>--%suite</code> annotation is bound to procedure, it is ignored and results in package not getting recognized as test suite. <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n  procedure some_proc;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>ORA-20204: Suite package TESTS_OWNER.test_package not found\nORA-06512: at \"UT3.UT_RUNNER\", line 106\nORA-06512: at \"UT3.UT\", line 115\nORA-06512: at \"UT3.UT\", line 306\nORA-06512: at \"UT3.UT\", line 364\nORA-06512: at line 1\n</code></pre></p>"},{"location":"userguide/annotations.html#test","title":"Test","text":"<p>The <code>--%test</code> annotation denotes procedure withing test suite as a unit test. It accepts an optional description that will be reported when the test is executed. When description is not provided, procedure name is displayed on report.</p> <p>If <code>--%test</code> raises an unhandled exception the following will happen: - the test will be marked as errored and exception stack trace will be captured and reported - the <code>--%aftertest</code>, <code>--%aftereach</code> procedures will be executed for the errored test - the <code>--%afterall</code> procedures will be executed - test execution will continue uninterrupted for rest of the suite </p> <p>Test procedure without description. <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test\n  procedure some_test;\nend;\n/\ncreate or replace package body test_package as\n  procedure some_test is begin null; end;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  some_test [.003 sec]\n\nFinished in .004109 seconds\n1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Test procedure with description. <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\nend;\n/\ncreate or replace package body test_package as\n  procedure some_test is begin null; end;\nend;\n/\n</code></pre></p> <p><pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [.005 sec]\n\nFinished in .006828 seconds\n1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>When multiple <code>--%test</code> annotations are specified for a procedure, the first annotation will be used and a warning message will appear indicating duplicate annotation. <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  --%test(Duplicate description)\n  procedure some_test;\nend;\n/\ncreate or replace package body test_package as\n  procedure some_test is begin null; end;\nend;\n/\n</code></pre></p> <p><pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [.007 sec]\n\n\nWarnings:\n\n  1) test_package\n      Duplicate annotation \"--%test\". Annotation ignored.\n      at \"TESTS_OWNER.TEST_PACKAGE.SOME_TEST\", line 5\n\nFinished in .008815 seconds\n1 tests, 0 failed, 0 errored, 0 disabled, 1 warning(s)\n</code></pre></p>"},{"location":"userguide/annotations.html#disabled","title":"Disabled","text":"<p>Marks annotated suite package or test procedure as disabled. You can provide the reason why the test is disabled that will be displayed in output.</p> <p>Disabling suite. <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n  --%disabled(Reason for disabling suite)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  procedure other_test;\nend;\n/\ncreate or replace package body test_package as\n\n  procedure some_test is begin null; end;\n\n  procedure other_test is begin null; end;\nend;\n/\n</code></pre></p> <p><pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [0 sec] (DISABLED - Reason for disabling suite)\n  Description of another behavior [0 sec] (DISABLED - Reason for disabling suite)\n\nFinished in .001441 seconds\n2 tests, 0 failed, 0 errored, 2 disabled, 0 warning(s)\n</code></pre></p> <p>Disabling the context(s). <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%context(Context1)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\n\n  --%endcontext\n\n  --%context(Context2)\n\n  --%disabled(Reason for disabling context2)\n\n  --%test(Description of another behavior)\n  procedure other_test;\n\n  --%endcontext\nend;\n/\ncreate or replace package body test_package as\n\n  procedure some_test is begin null; end;\n\n  procedure other_test is begin null; end;\nend;\n/\n</code></pre></p> <p><pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Context1\n    Description of tested behavior [.002 sec]\n  Context2\n    Description of another behavior [0 sec] (DISABLED - Reason for disabling context2)\n\nFinished in .005079 seconds\n2 tests, 0 failed, 0 errored, 1 disabled, 0 warning(s)\n</code></pre></p> <p>Disabling individual test(s). <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  --%disabled(Reason for disabling test)\n  procedure other_test;\nend;\n/\ncreate or replace package body test_package as\n\n  procedure some_test is begin null; end;\n\n  procedure other_test is begin null; end;\nend;\n/\n</code></pre></p> <p><pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [.004 sec]\n  Description of another behavior [0 sec] (DISABLED - Reason for disabling test)\n\nFinished in .005868 seconds\n2 tests, 0 failed, 0 errored, 1 disabled, 0 warning(s)\n</code></pre></p>"},{"location":"userguide/annotations.html#beforeall","title":"Beforeall","text":"<p>There are two possible ways  to use the <code>--%beforeall</code> annotation.</p> <p>As a procedure level annotation: <pre><code>--%suite(Some test suite)\n\n--%beforeall\nprocedure to_be_executed_before_all;\n\n--%test\nprocedure some_test;\n</code></pre> Marks annotated procedure to be executed before all test procedures in a suite.</p> <p>As a package level annotation (not associated with any procedure). <pre><code>--%suite(Some test suite)\n\n--%beforeall(to_be_executed_before_all, other_package.some_setup)\n\n--%test\nprocedure some_test;\n\nprocedure to_be_executed_before_all;\n</code></pre> Indicates that the procedure(s) mentioned as the annotation parameter are to be executed before all test procedures in a suite.</p> <p>If <code>--%beforeall</code> raises an exception, suite content cannot be safely executed as the setup was not executed successfully for the suite. </p> <p>If <code>--%beforeall</code> raises an exception the following will happen:</p> <ul> <li>the <code>--%beforeall</code> procedures that follow the failed one, will not be executed</li> <li>all <code>--%test</code> procedures and their <code>--%beforeeach</code>, <code>--%aftereach</code>, <code>--%beforetest</code> and <code>--%aftertest</code> procedures within suite package will not be executed</li> <li>all <code>--%test</code> procedures will be marked as failed</li> <li>the <code>--%afterall</code> procedures will be executed</li> <li>test execution will continue uninterrupted for other suite packages </li> </ul> <p>When multiple <code>--%beforeall</code> procedures are defined in a suite package, all of them will be executed before invoking any test.</p> <p>For multiple <code>--%beforeall</code> procedures order of execution is defined by annotation position in the package specification.</p> <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  procedure other_test;\n\n  --%beforeall\n  procedure setup_stuff;\n\nend;\n/\ncreate or replace package body test_package as\n  procedure setup_stuff is\n  begin\n    dbms_output.put_line('--- SETUP_STUFF invoked ---');\n  end;\n\n  procedure some_test is begin null; end;\n\n  procedure other_test is begin null; end;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  --- SETUP_STUFF invoked ---\n  Description of tested behavior [.004 sec]\n  Description of another behavior [.003 sec]\n\nFinished in .012292 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre> <p>In the below example a combination pacakge and procedure level <code>--%beforeall</code> annotations is used. The order of execution of the beforeall procedures is determined by the annotation position in package.  All of the <code>--%beforeall</code> procedures get invoked before any test is executed in a suite. <pre><code>  create or replace package test_package as\n    --%suite(Tests for a package)\n\n    --%beforeall(initial_setup,test_package.another_setup)\n\n    --%test(Description of tested behavior)\n    procedure some_test;\n\n    --%test(Description of another behavior)\n    procedure other_test;\n\n    --%beforeall\n    procedure next_setup;\n\n    --%beforeall(one_more_setup)\n\n    procedure another_setup;\n    procedure one_more_setup;\n    procedure initial_setup;\n\n  end;\n  /\n  create or replace package body test_package as\n    procedure one_more_setup is\n    begin\n      dbms_output.put_line('--- ONE_MORE_SETUP invoked ---');\n    end;\n\n    procedure next_setup is\n    begin\n      dbms_output.put_line('--- NEXT_SETUP invoked ---');\n    end;\n\n    procedure another_setup is\n    begin\n      dbms_output.put_line('--- ANOTHER_SETUP invoked ---');\n    end;\n\n    procedure initial_setup is\n    begin\n      dbms_output.put_line('--- INITIAL_SETUP invoked ---');\n    end;\n\n    procedure some_test is begin null; end;\n\n    procedure other_test is begin null; end;\n  end;\n  /\n</code></pre></p> <pre><code> exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  --- INITIAL_SETUP invoked ---\n  --- ANOTHER_SETUP invoked ---\n  --- NEXT_SETUP invoked ---\n  --- ONE_MORE_SETUP invoked ---\n  Description of tested behavior [.003 sec]\n  Description of another behavior [.002 sec]\n\nFinished in .018944 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre> <p>When multiple <code>--%beforeall</code> annotations are specified for a procedure, the first annotation will be used and a warning message will appear indicating duplicate annotation. When procedure is annotated as both <code>--%beforeall</code> and <code>--%test</code>, the procedure will become a test and a warning message will appear indicating invalid annotation combination.   <pre><code> create or replace package test_package as\n   --%suite(Tests for a package)\n\n   --%beforeall\n   --%beforeall\n   procedure initial_setup;\n\n   --%test(Description of tested behavior)\n   --%beforeall\n   procedure some_test;\n\n   --%test(Description of another behavior)\n   procedure other_test;\n\n end;\n /\n create or replace package body test_package as\n\n   procedure initial_setup is\n   begin\n     dbms_output.put_line('--- INITIAL_SETUP invoked ---');\n   end;\n\n   procedure some_test is begin null; end;\n\n   procedure other_test is begin null; end;\n end;\n /\n</code></pre></p> <pre><code> exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  --- INITIAL_SETUP invoked ---\n  Description of tested behavior [.003 sec]\n  Description of another behavior [.004 sec]\n\n\nWarnings:\n\n  1) test_package\n      Duplicate annotation \"--%beforeall\". Annotation ignored.\n      at \"UT3_TESTER.TEST_PACKAGE.INITIAL_SETUP\", line 5\n  2) test_package\n      Annotation \"--%beforeall\" cannot be used with annotation: \"--%test\"\n      at \"UT3_TESTER.TEST_PACKAGE.SOME_TEST\", line 9\n\nFinished in .012158 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 2 warning(s)\n</code></pre>"},{"location":"userguide/annotations.html#afterall","title":"Afterall","text":"<p>There are two possible ways  to use the <code>--%afterall</code> annotation.</p> <p>As a procedure level annotation: <pre><code>--%suite(Some test suite)\n\n--%afterall\nprocedure to_be_executed_after_all;\n\n--%test\nprocedure some_test;\n</code></pre> Marks annotated procedure to be executed after all test procedures in a suite.</p> <p>As a package level annotation (not associated with any procedure). <pre><code>--%suite(Some test suite)\n\n--%afterall(to_be_executed_after_all, other_package.some_cleanup)\n\n--%test\nprocedure some_test;\n\nprocedure to_be_executed_after_all;\n</code></pre></p> <p>Indicates that the procedure(s) mentioned as the annotation parameter are to be executed after all test procedures in a suite.</p> <p>If <code>--%afterall</code> raises an exception the following will happen:</p> <ul> <li>a warning will be raised, indicating that <code>--%afterall</code> procedure has failed</li> <li>execution will continue uninterrupted for rest of the suite </li> </ul> <p>If <code>--%afterall</code> raises an exception, it can have negative impact on other tests, as the environment was not cleaned-up after the tests.  This however doesn't have direct impact on test execution within current suite, as the tests are already complete by the time <code>--%afterall</code> is called. </p> <p>When multiple <code>--%afterall</code> procedures are defined in a suite, all of them will be executed after invoking all tests from the suite.</p> <p>For multiple <code>--%afterall</code> procedures order of execution is defined by annotation position in the package specification.</p> <p>All rules defined for <code>--%beforeall</code> also apply for <code>--%afterall</code> annotation. See beforeall for more details.</p> <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  procedure other_test;\n\n  --%afterall\n  procedure cleanup_stuff;\n\nend;\n/\ncreate or replace package body test_package as\n  procedure cleanup_stuff is\n  begin\n    dbms_output.put_line('---CLEANUP_STUFF invoked ---');\n  end;\n\n  procedure some_test is begin null; end;\n\n  procedure other_test is begin null; end;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [.003 sec]\n  Description of another behavior [.005 sec]\n  ---CLEANUP_STUFF invoked ---\n\nFinished in .014161 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre>"},{"location":"userguide/annotations.html#beforeeach","title":"Beforeeach","text":"<p>The procedure annotated as <code>--%beforeeach</code> is getting executed before each test in a suite. That means that the procedure will be executed as many times as there are test in suite package.</p> <p>There are two possible ways  to use the <code>--%beforeeach</code> annotation.</p> <p>As a procedure level annotation: <pre><code>--%suite(Some test suite)\n\n--%beforeeach\nprocedure to_be_executed_before_each;\n\n--%test\nprocedure some_test;\n</code></pre> Marks annotated procedure to be executed before each test procedures in a suite.</p> <p>As a package level annotation (not associated with any procedure). <pre><code>--%suite(Some test suite)\n\n--%beforeeach(to_be_executed_before_each, other_package.some_setup)\n\n--%test\nprocedure some_test;\n\nprocedure to_be_executed_before_each;\n</code></pre></p> <p>Indicates that the procedure(s) mentioned as the annotation parameter are to be executed before each test procedure in a suite.</p> <p>If a test is marked as disabled the <code>--%beforeeach</code> procedure is not invoked for that test.</p> <p>If <code>--%beforeeach</code> raises an unhandled exception the following will happen:</p> <ul> <li>the following <code>--%beforeeach</code> as well as all <code>--%beforetest</code> for that test will not be executed</li> <li>the test will be marked as errored and exception stack trace will be captured and reported</li> <li>the <code>--%aftertest</code>, <code>--%aftereach</code> procedures will be executed for the errored test</li> <li>the <code>--%afterall</code> procedures will be executed</li> <li>test execution will continue uninterrupted for rest of the suite </li> </ul> <p>As a rule, the <code>--%beforeeach</code> execution gets aborted if preceding <code>--%beforeeach</code> failed. </p> <p>When multiple <code>--%beforeeach</code> procedures are defined in a suite, all of them will be executed before invoking each test.</p> <p>For multiple <code>--%beforeeach</code> procedures order of execution is defined by annotation position in the package specification.</p> <pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  procedure other_test;\n\n  --%beforeeach\n  procedure setup_for_test;\n\n  --%beforeall\n  procedure setup_stuff;\nend;\n/\ncreate or replace package body test_package as\n  procedure setup_stuff is\n  begin\n    dbms_output.put_line('---SETUP_STUFF invoked ---');\n  end;\n\n  procedure setup_for_test is\n  begin\n    dbms_output.put_line('---SETUP_FOR_TEST invoked ---');\n  end;\n\n  procedure some_test is \n  begin \n    dbms_output.put_line('---SOME_TEST invoked ---');\n  end;\n\n  procedure other_test is \n  begin \n    dbms_output.put_line('---OTHER_TEST invoked ---');\n  end;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  ---SETUP_STUFF invoked ---\n  Description of tested behavior [.004 sec]\n  ---SETUP_FOR_TEST invoked ---\n  ---SOME_TEST invoked ---\n  Description of another behavior [.006 sec]\n  ---SETUP_FOR_TEST invoked ---\n  ---OTHER_TEST invoked ---\n\nFinished in .014683 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre> <p>See beforeall for more examples.</p>"},{"location":"userguide/annotations.html#aftereach","title":"Aftereach","text":"<p>Marks annotated procedure to be executed after each test procedure in a suite.</p> <p>The procedure annotated as <code>--%aftereach</code> is getting executed after each test in a suite. That means that the procedure will be executed as many times as there are test in suite package.</p> <p>There are two possible ways  to use the <code>--%aftereach</code> annotation.</p> <p>As a procedure level annotation: <pre><code>--%suite(Some test suite)\n\n--%aftereach\nprocedure to_be_executed_after_each;\n\n--%test\nprocedure some_test;\n</code></pre> Marks annotated procedure to be executed after each test procedures in a suite.</p> <p>As a package level annotation (not associated with any procedure). <pre><code>--%suite(Some test suite)\n\n--%aftereach(to_be_executed_after_each, other_package.some_setup)\n\n--%test\nprocedure some_test;\n\nprocedure to_be_executed_after_each;\n</code></pre></p> <p>Indicates that the procedure(s) mentioned as the annotation parameter are to be executed after each test procedure in a suite.</p> <p>If a test is marked as disabled the <code>--%aftereach</code> procedure is not invoked for that test.</p> <p>If <code>--%aftereach</code> raises an unhandled exception the following will happen:</p> <ul> <li>the test will be marked as errored and exception stack trace will be captured and reported</li> <li>the <code>--%aftertest</code>, <code>--%aftereach</code> procedures will be executed for the errored test</li> <li>the <code>--%afterall</code> procedures will be executed</li> <li>test execution will continue uninterrupted for rest of the suite </li> </ul> <p>When multiple <code>--%aftereach</code> procedures are defined in a suite, all of them will be executed after invoking each test.</p> <p>For multiple <code>--%aftereach</code> procedures order of execution is defined by the annotation position in the package specification.</p> <p>As a rule, the <code>--%aftereach</code> gets executed even if the associated <code>--%beforeeach</code>, <code>--%beforetest</code>, <code>--%test</code> or other <code>--%aftereach</code> procedures have raised unhandled exceptions. </p> <p><pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  procedure other_test;\n\n  --%aftereach\n  procedure cleanup_for_test;\n\n  --%afterall\n  procedure cleanup_stuff;\nend;\n/\ncreate or replace package body test_package as\n  procedure cleanup_stuff is\n  begin\n    dbms_output.put_line('---CLEANUP_STUFF invoked ---');\n  end;\n\n  procedure cleanup_for_test is\n  begin\n    dbms_output.put_line('---CLEANUP_FOR_TEST invoked ---');\n  end;\n\n  procedure some_test is \n  begin \n    dbms_output.put_line('---SOME_TEST invoked ---');\n  end;\n\n  procedure other_test is \n  begin \n    dbms_output.put_line('---OTHER_TEST invoked ---');\n  end;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [.006 sec]\n  ---SOME_TEST invoked ---\n  ---CLEANUP_FOR_TEST invoked ---\n  Description of another behavior [.006 sec]\n  ---OTHER_TEST invoked ---\n  ---CLEANUP_FOR_TEST invoked ---\n  ---CLEANUP_STUFF invoked ---\n\nFinished in .018115 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>See beforeall for more examples.</p>"},{"location":"userguide/annotations.html#beforetest","title":"Beforetest","text":"<p>Indicates specific setup procedure(s) to be executed for a test. The procedure(s) can be located either:</p> <ul> <li>within current package (package name is optional)</li> <li>within another package </li> </ul> <p>The annotation need to be placed alongside <code>--%test</code> annotation.</p> <p>The <code>--%beforetest</code> procedures are executed after invoking all <code>--%beforeeach</code> for a test.</p> <p>If a test is marked as disabled the <code>--%beforetest</code> procedures are not invoked for that test.</p> <p>If <code>--%beforetest</code> raises an unhandled exception the following will happen:</p> <ul> <li>the following <code>--%beforetest</code> for that test will not be executed</li> <li>the test will be marked as errored and exception stack trace will be captured and reported</li> <li>the <code>--%aftertest</code>, <code>--%aftereach</code> procedures will be executed for the errored test</li> <li>the <code>--%afterall</code> procedures will be executed</li> <li>test execution will continue uninterrupted for rest of the suite </li> </ul> <p>When multiple <code>--%beforetest</code> procedures are defined for a test, all of them will be executed before invoking the test.</p> <p>The order of execution for <code>--%beforetest</code> procedures is defined by:</p> <ul> <li>position of procedure on the list within single annotation</li> <li>annotation position</li> </ul> <p>As a rule, the <code>--%beforetest</code> execution gets aborted if preceding <code>--%beforeeach</code> or <code>--%beforetest</code> failed. </p> <p><pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  --%beforetest(test_package.setup_for_a_test)\n  --%beforetest(another_setup_for_a_test)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  --%beforetest(test_package.setup_for_a_test, another_setup_for_a_test)\n  procedure other_test;\n\n  procedure another_setup_for_a_test;\n\n  procedure setup_for_a_test;\n\nend;\n/\ncreate or replace package body test_package as\n  procedure setup_for_a_test is\n  begin\n    dbms_output.put_line('---SETUP_FOR_A_TEST invoked ---');\n  end;\n\n  procedure another_setup_for_a_test is\n  begin\n    dbms_output.put_line('---ANOTHER_SETUP_FOR_A_TEST invoked ---');\n  end;\n\n  procedure some_test is \n  begin \n    dbms_output.put_line('---SOME_TEST invoked ---');\n  end;\n\n  procedure other_test is \n  begin \n    dbms_output.put_line('---OTHER_TEST invoked ---');\n  end;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [.008 sec]\n  ---SETUP_FOR_A_TEST invoked ---\n  ---ANOTHER_SETUP_FOR_A_TEST invoked ---\n  ---SOME_TEST invoked ---\n  Description of another behavior [.005 sec]\n  ---SETUP_FOR_A_TEST invoked ---\n  ---ANOTHER_SETUP_FOR_A_TEST invoked ---\n  ---OTHER_TEST invoked ---\n\nFinished in .015185 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p>"},{"location":"userguide/annotations.html#aftertest","title":"Aftertest","text":"<p>Indicates specific cleanup procedure(s) to be executed for a test. The procedure(s) can be located either:</p> <ul> <li>within current package (package name is optional)</li> <li>within another package </li> </ul> <p>The annotation need to be placed alongside <code>--%test</code> annotation.</p> <p>If a test is marked as disabled the <code>--%aftertest</code> procedures are not invoked for that test.</p> <p>If <code>--%aftertest</code> raises an unhandled exception the following will happen:</p> <ul> <li>the test will be marked as errored and exception stack trace will be captured and reported</li> <li>the following <code>--%aftertest</code> and all <code>--%aftereach</code> procedures will be executed for the errored test</li> <li>the <code>--%afterall</code> procedures will be executed</li> <li>test execution will continue uninterrupted for rest of the suite </li> </ul> <p>When multiple <code>--%aftertest</code> procedures are defined for a test, all of them will be executed after invoking the test.</p> <p>The order of execution for <code>--%aftertest</code> procedures is defined by:</p> <ul> <li>position of procedure on the list within single annotation</li> <li>annotation position</li> </ul> <p>As a rule, the <code>--%aftertest</code> gets executed even if the associated <code>--%beforeeach</code>, <code>--%beforetest</code>, <code>--%test</code> or other <code>--%aftertest</code> procedures have raised unhandled exceptions. </p> <p><pre><code>create or replace package test_package as\n  --%suite(Tests for a package)\n\n  --%test(Description of tested behavior)\n  --%aftertest(test_package.cleanup_for_a_test)\n  --%aftertest(another_cleanup_for_a_test)\n  procedure some_test;\n\n  --%test(Description of another behavior)\n  --%aftertest(test_package.cleanup_for_a_test, another_cleanup_for_a_test)\n  procedure other_test;\n\n  procedure another_cleanup_for_a_test;\n\n  procedure cleanup_for_a_test;\n\nend;\n/\ncreate or replace package body test_package as\n  procedure cleanup_for_a_test is\n  begin\n    dbms_output.put_line('---CLEANUP_FOR_A_TEST invoked ---');\n  end;\n\n  procedure another_cleanup_for_a_test is\n  begin\n    dbms_output.put_line('---ANOTHER_CLEANUP_FOR_A_TEST invoked ---');\n  end;\n\n  procedure some_test is \n  begin \n    dbms_output.put_line('---SOME_TEST invoked ---');\n  end;\n\n  procedure other_test is \n  begin \n    dbms_output.put_line('---OTHER_TEST invoked ---');\n  end;\nend;\n/\n</code></pre> <pre><code>exec ut.run('test_package');\n</code></pre> <pre><code>Tests for a package\n  Description of tested behavior [.008 sec]\n  ---SOME_TEST invoked ---\n  ---CLEANUP_FOR_A_TEST invoked ---\n  ---ANOTHER_CLEANUP_FOR_A_TEST invoked ---\n  Description of another behavior [.006 sec]\n  ---OTHER_TEST invoked ---\n  ---CLEANUP_FOR_A_TEST invoked ---\n  ---ANOTHER_CLEANUP_FOR_A_TEST invoked ---\n\nFinished in .016873 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p>"},{"location":"userguide/annotations.html#context","title":"Context","text":"<p>In most of the cases, the code to be tested is consisting of PLSQL packages containing procedures and functions. When creating test suites, it's quite common to maintain <code>one to one</code> relationship between test suite packages and tested code.</p> <p>When it comes to test procedures themselves, it is best practice to have one test procedure for one tested behavior of the code that is tested. The relationship between test procedure and tested code will be therefore <code>many to one</code> or <code>many to many</code> in most of the cases.</p> <p>With this comes a challenge. How to group tests, related to one tested behavior, so that it is obvious that they relate to the same thing.</p> <p>This is where utPLSQL contexts come handy. </p> <p>Contexts allow for creating sub-suites within a suite package and they allow for grouping of tests that are somehow related.</p> <p>In essence, context behaves like a suite within a suite. </p> <p>Context have following characteristics:</p> <ul> <li>context starts with the <code>--%context</code> annotation and ends with <code>--%endcontext</code>. Everything placed between those two annotations belongs to that context</li> <li>can have a description provided as parameter for example <code>--%context(Some interesting stuff)</code>. </li> <li>can have a name provided with <code>--%name</code> annotation. This is different than with <code>suite</code> and <code>test</code> annotations, where name is taken from <code>package/procedure</code> name.</li> <li>contexts can be nested, you can place a context inside another context</li> <li>when no name is provided for context, the context is named <code>context_N</code> where <code>N</code> is the number of the context in suite or parent context.</li> <li>context name must be unique within it's parent (suite / parent context)</li> <li>if context name is not unique within it's parent, context and it's entire content is excluded from execution </li> <li>context name should not contain spaces or special characters</li> <li>context name cannot contain a <code>.</code> (full stop/period) character</li> <li>suite/context can have multiple nested sibling contexts in it </li> <li>contexts can have their own <code>--%beforeall</code>, <code>--%beforeeach</code>, <code>--%afterall</code> and <code>--%aftereach</code> procedures</li> <li><code>--%beforeall</code>, <code>--%beforeeach</code>, <code>--%afterall</code> and <code>--%aftereach</code> procedures defined at ancestor level, propagate to context</li> <li>if <code>--%endcontext</code> is missing for a context, the context spans to the end of package specification</li> </ul> <p>The below example illustrates usage of <code>--%context</code> for separating tests for individual procedures of package.</p> <p>Sample tables and code <pre><code>create table rooms (\n  room_key number primary key,\n  name varchar2(100) not null\n);\n\ncreate table room_contents (\n  contents_key number primary key,\n  room_key     number not null,\n  name         varchar2(100) not null,\n  create_date  timestamp default current_timestamp not null,\n  constraint fk_rooms foreign key (room_key) references rooms (room_key)\n);\n\ncreate or replace package rooms_management is\n\n  procedure remove_rooms_by_name( a_name rooms.name%type );\n\n  procedure add_rooms_content( \n    a_room_name    rooms.name%type,\n    a_content_name room_contents.name%type\n  );\n\nend;\n/\n\ncreate or replace package body rooms_management is\n  procedure remove_rooms_by_name( a_name rooms.name%type ) is\n  begin\n    if a_name is null then\n      raise program_error;\n    end if;\n    delete from rooms where name like a_name;\n  end;\n\n  procedure add_rooms_content( \n    a_room_name    rooms.name%type,\n    a_content_name room_contents.name%type\n  ) is\n    l_room_key     rooms.room_key%type;\n  begin\n\n    select room_key into l_room_key \n      from rooms where name = a_room_name;\n\n    insert into room_contents\n          (contents_key, room_key, name)\n    select nvl(max(contents_key)+1, 1) as contents_key,\n           l_room_key,\n           a_content_name\n      from room_contents;\n  end;\nend;\n/\n</code></pre></p> <p>Below test suite defines:</p> <ul> <li><code>--%beforeall</code> outside of context, that will be executed before all tests</li> <li><code>--%context(remove_rooms_by_name)</code> to group tests related to <code>remove_rooms_by_name</code> functionality</li> <li><code>--%context(add_rooms_content)</code> to group tests related to <code>add_rooms_content</code> functionality</li> </ul> <pre><code>create or replace package test_rooms_management is\n\n  gc_null_value_exception constant integer := -1400;\n  --%suite(Rooms management)\n\n  --%beforeall\n  procedure setup_rooms;\n\n\n  --%context(remove_rooms_by_name)\n  --%displayname(Remove rooms by name)\n\n    --%test(Removes a room without content in it)\n    procedure remove_empty_room;\n\n    --%test(Raises exception when null room name given)\n    --%throws(-6501)\n    procedure null_room_name;  \n\n  --%endcontext\n\n  --%context(add_rooms_content)\n  --%displayname(Add content to a room)\n\n    --%test(Fails when room name is not valid)\n    --%throws(no_data_found)\n    procedure fails_on_room_name_invalid;\n\n    --%test(Fails when content name is null)\n    --%throws(test_rooms_management.gc_null_value_exception)\n    procedure fails_on_content_null;\n\n    --%test(Adds a content to existing room)\n    procedure add_content_success;\n\n  --%endcontext\n\nend;\n/\n\ncreate or replace package body test_rooms_management is\n\n  procedure setup_rooms is\n  begin\n    insert all\n      into rooms values(1, 'Dining Room')\n      into rooms values(2, 'Living Room')\n      into rooms values(3, 'Bathroom')\n    select 1 from dual;\n\n    insert all\n      into room_contents values(1, 1, 'Table', sysdate)\n      into room_contents values(3, 1, 'Chair', sysdate)\n      into room_contents values(4, 2, 'Sofa', sysdate)\n      into room_contents values(5, 2, 'Lamp', sysdate)\n    select 1 from dual;\n\n    dbms_output.put_line('---SETUP_ROOMS invoked ---');\n  end;\n\n  procedure remove_empty_room is\n    l_rooms_not_named_b sys_refcursor;\n    l_remaining_rooms   sys_refcursor;\n  begin\n    open l_rooms_not_named_b for select * from rooms where name not like 'B%';\n\n    rooms_management.remove_rooms_by_name('B%');\n\n    open l_remaining_rooms for select * from rooms;\n    ut.expect( l_remaining_rooms ).to_equal(l_rooms_not_named_b);\n  end;\n\n  procedure room_with_content is\n  begin\n    rooms_management.remove_rooms_by_name('Living Room');\n  end;\n\n  procedure null_room_name is\n  begin\n    --Act\n    rooms_management.remove_rooms_by_name(NULL);\n    --Assert done by --%throws annotation\n  end;\n\n  procedure fails_on_room_name_invalid is\n  begin\n    --Act\n    rooms_management.add_rooms_content('bad room name','Chair');\n    --Assert done by --%throws annotation\n  end;\n\n  procedure fails_on_content_null is\n  begin\n    --Act\n    rooms_management.add_rooms_content('Dining Room',null);\n    --Assert done by --%throws annotation\n  end;\n\n  procedure add_content_success is\n    l_expected        room_contents.name%type;\n    l_actual          room_contents.name%type;\n  begin\n    --Arrange\n    l_expected := 'Table';\n\n    --Act\n    rooms_management.add_rooms_content( 'Dining Room', l_expected );\n    --Assert\n    select name into l_actual from room_contents\n     where contents_key = (select max(contents_key) from room_contents);\n\n    ut.expect( l_actual ).to_equal( l_expected );\n  end;\n\nend;\n/\n</code></pre> <p>When the tests are executed <pre><code>exec ut.run('test_rooms_management');\n</code></pre> The following report is displayed <pre><code>Rooms management\n  ---SETUP_ROOMS invoked ---\n  remove_rooms_by_name\n    Removes a room without content in it [.015 sec]\n    Raises exception when null room name given [.002 sec]\n  add_rooms_content\n    Fails when room name is not valid [.003 sec]\n    Fails when content name is null [.003 sec]\n    Adds a content to existing room [.003 sec]\n\nFinished in .035261 seconds\n5 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Example of nested contexts test suite specification. Source - slide 145 of Structure and Interpretation of Test Cases by Kevlin Henney</p> <pre><code>create or replace package queue_spec as\n  --%suite(Queue specification)\n\n  --%context(A new queue)\n\n    --%test(Is empty)\n    procedure is_empty;\n    --%test(Preserves positive bounding capacity)\n    procedure positive_bounding_capacity;\n    --%test(Cannot be created with non positive bounding capacity)\n    procedure non_positive_bounding_cap;\n  --%endcontext\n  --%context(An empty queue)\n\n    --%test(Dequeues an empty value)\n    procedure deq_empty_value;\n    --%test(Remains empty when null enqueued)\n    procedure empty_with_null_enq;\n    --%test(Becomes non empty when non null value enqueued)\n    procedure non_empty_after_enq;\n  --%endcontext\n  --%context(A non empty queue)\n\n    --%context(that is not full)\n\n      --%test(Becomes longer when non null value enqueued)\n      procedure grow_on_enq_non_null;\n      --%test(Becomes full when enqueued up to capacity)\n      procedure full_on_enq_to_cap;\n    --%endcontext\n    --%context(that is full)\n\n      --%test(Ignores further enqueued values)\n      procedure full_ignore_enq;\n      --%test(Becomes non full when dequeued)\n      procedure non_full_on_deq;\n    --%endcontext\n\n    --%test(Dequeues values in order enqueued)\n    procedure dequeue_ordered;\n    --%test(Remains unchanged when null enqueued)\n    procedure no_change_on_null_enq;\n  --%endcontext\nend;\n</code></pre> <p>When such specification gets executed <code>ut.run('queue_spec'')</code> (without body created) you will see the nesting of tests within contexts. <pre><code>Queue specification\n  An empty queue\n    Dequeues an empty value [.014 sec] (FAILED - 1)\n    Remains empty when null enqueued [.004 sec] (FAILED - 2)\n    Becomes non empty when non null value enqueued [.005 sec] (FAILED - 3)\n  A non empty queue\n    that is not full\n      Becomes longer when non null value enqueued [.005 sec] (FAILED - 4)\n      Becomes full when enqueued up to capacity [.005 sec] (FAILED - 5)\n    That is full\n      Ignores further enqueued values [.004 sec] (FAILED - 6)\n      Becomes non full when dequeued [.005 sec] (FAILED - 7)\n    Dequeues values in order enqueued [.006 sec] (FAILED - 8)\n    Remains unchanged when null enqueued [.004 sec] (FAILED - 9)\n  A new queue\n    Is empty [.007 sec] (FAILED - 10)\n    Preserves positive bounding capacity [.006 sec] (FAILED - 11)\n    Cannot be created with non positive bounding capacity [.005 sec] (FAILED - 12)\nFailures:\n   1) deq_empty_value\n      ORA-04067: not executed, package body \"UT3.QUEUE_SPEC\" does not exist\n      ORA-06508: PL/SQL: could not find program unit being called: \"UT3.QUEUE_SPEC\"\n      ORA-06512: at line 6\n...\nFinished in .088573 seconds\n12 tests, 0 failed, 12 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Suite nesting allows for organizing tests into human-readable specification of behavior.</p>"},{"location":"userguide/annotations.html#name","title":"Name","text":"<p>The <code>--%name</code> annotation is currently only used only for naming a context. If a context doesn't have explicit name specified, then the name is given automatically by framework.</p> <p>The automatic name will be <code>context_#n</code> where <code>n</code> is a context number within a suite/parent context.</p> <p>The <code>--%name</code> can be useful when you would like to run only a specific context or its items by <code>suitepath</code>.</p> <p>Consider the below example.</p> <pre><code>create or replace package queue_spec as\n  --%suite(Queue specification)\n\n  --%context(A new queue)\n\n    --%test(Cannot be created with non positive bounding capacity)\n    procedure non_positive_bounding_cap;\n  --%endcontext\n  --%context(An empty queue)\n\n    --%test(Becomes non empty when non null value enqueued)\n    procedure non_empty_after_enq;\n  --%endcontext\n  --%context(A non empty queue)\n\n    --%context(that is not full)\n\n      --%test(Becomes full when enqueued up to capacity)\n      procedure full_on_enq_to_cap;\n    --%endcontext\n    --%context(that is full)\n\n      --%test(Becomes non full when dequeued)\n      procedure non_full_on_deq;\n    --%endcontext\n\n  --%endcontext\nend;\n</code></pre> <p>In the above code, suitepaths, context names and context descriptions will be as follows.</p> suitepath description name queue_spec Queue specification queue_spec queue_spec.context_#1 A new queue context_#1 queue_spec.context_#2 An empty queue context_#2 queue_spec.context_#3 A non empty queue context_#3 queue_spec.context_#3.context_#1 that is not full context_#1 queue_spec.context_#3.context_#2 that is full context_#2 <p>In order to run only the tests for the context <code>A non empty queue that is not full</code> you will need to call utPLSQL as below: <pre><code>  exec ut.run(':queue_spec.context_#3.context_#1');\n</code></pre></p> <p>You can use <code>--%name</code> annotation to explicitly name contexts on suitepath. <pre><code>create or replace package queue_spec as\n  --%suite(Queue specification)\n\n  --%context(A new queue)\n  --%name(a_new_queue)\n\n    --%test(Cannot be created with non positive bounding capacity)\n    procedure non_positive_bounding_cap;\n  --%endcontext\n  --%context(An empty queue)\n  --%name(an_empty_queue)\n\n    --%test(Becomes non empty when non null value enqueued)\n    procedure non_empty_after_enq;\n  --%endcontext\n  --%context(A non empty queue)\n  --%name(a_non_empty_queue)\n\n    --%context(that is not full)\n    --%name(that_is_not_full)\n\n      --%test(Becomes full when enqueued up to capacity)\n      procedure full_on_enq_to_cap;\n    --%endcontext\n    --%context(that is full)\n    --%name(that_is_full)\n\n      --%test(Becomes non full when dequeued)\n      procedure non_full_on_deq;\n    --%endcontext\n\n  --%endcontext\nend;\n</code></pre></p> <p>In the above code, suitepaths, context names and context descriptions will be as follows.</p> suitepath description name queue_spec Queue specification queue_spec queue_spec.a_new_queue A new queue a_new_queue queue_spec.an_empty_queue An empty queue an_empty_queue queue_spec.a_non_empty_queue A non empty queue a_non_empty_queue queue_spec.a_non_empty_queue.that_is_not_full that is not full that_is_not_full queue_spec.a_non_empty_queue.that_is_full that is full that_is_full <p>The <code>--%name</code> annotation is only relevant for:</p> <ul> <li>running subsets of tests by given context suitepath</li> <li>some of test reports, like <code>ut_junit_reporter</code> that use suitepath or test-suite element names (not descriptions) for reporting   </li> </ul>"},{"location":"userguide/annotations.html#name-naming-convention","title":"Name naming convention","text":"<p>The value of <code>--%name</code> annotation must follow the following naming rules:</p> <ul> <li>cannot contain spaces</li> <li>cannot contain a <code>.</code> (full stop/dot)</li> <li>is case-insensitive  </li> </ul>"},{"location":"userguide/annotations.html#tags","title":"Tags","text":"<p>Tag is a label attached to the test or a suite. It is used for identification and execution of a group of tests / suites that share the same tag.  </p> <p>It allows for grouping of tests / suites using various categorization and place tests / suites in multiple buckets. Same tests can be grouped with other tests based on the functionality , frequency, type of output etc.</p> <p>e.g. </p> <pre><code>--%tags(batch,daily,csv)\n</code></pre> <p>or</p> <pre><code>--%tags(online,json)\n--%tags(api)\n</code></pre> <p>Tags are defined as a comma separated list within the <code>--%tags</code> annotation. </p> <p>When a suite/context is tagged, all of its children will automatically inherit the tag and get executed along with the parent, unless they are excluded explicitly at runtime with a negated tag expression. See running unit tests for more information on using tags to filter test suites that are to be executed.</p>"},{"location":"userguide/annotations.html#tag-naming-convention","title":"Tag naming convention","text":"<p>Tags must follow the below naming convention:</p> <ul> <li>tag is case sensitive</li> <li>tag must not contain any of the following reserved characters:</li> <li>comma (,)</li> <li>left or right parenthesis ((, ))</li> <li>ampersand (&amp;)</li> <li>vertical bar (|)</li> <li>exclamation point (!)</li> <li>tag cannot be null or blank</li> <li>tag cannot start with a dash, e.g. <code>-some-stuff</code> is not a valid tag</li> <li>tag cannot contain spaces, e.g. <code>test of batch</code>. To create a multi-word tag use underscores or dashes, e.g. <code>test_of_batch</code>, <code>test-of-batch</code></li> <li>leading and trailing spaces are ignored in tag name, e.g. <code>--%tags(  tag1  ,   tag2  )</code> becomes <code>tag1</code> and <code>tag2</code> tag names</li> <li>tag cannot be one of two reserved words: <code>none</code> and <code>any</code>. <code>none</code> and <code>any</code> as a tag will be treated as no tag</li> </ul>"},{"location":"userguide/annotations.html#suitepath","title":"Suitepath","text":"<p>It is very likely that the application for which you are going to introduce tests consists of many different packages, procedures and functions. Usually procedures can be logically grouped inside a package, there also might be several logical groups of procedures in a single package and packages might be grouped into modules and modules into subject areas.</p> <p>As your project grows, the codebase will grow to. utPLSQL allows you to group packages into modules and also allows for nesting modules. </p> <p>Let's say you have a complex insurance application that deals with policies, claims and payments. The payment module contains several packages for payment recognition, charging, planning etc. The payment recognition module among others contains a complex <code>recognize_payment</code> procedure that associates received money to the policies.</p> <p>If you want to create tests for your application it is recommended to structure your tests similarly to the logical structure of your application. So you end up with something like: * Integration tests   *   Policy tests   *   Claim tests   *   Payment tests     * Payments recognition     * Payments set off</p> <p>The <code>--%suitepath</code> annotation is used for such grouping. Even though test packages are defined in a flat structure the <code>--%suitepath</code> is used by the framework to form them into a hierarchical structure. </p> <p>Your payments recognition test package might look like: <pre><code>create or replace package test_payment_recognition as\n\n  --%suite(Payment recognition tests)\n  --%suitepath(payments)\n\n  --%test(Recognize payment by policy number)\n  procedure test_recognize_by_num;\n\n  --%test(Recognize payment by payment purpose)\n  procedure test_recognize_by_purpose;\n\n  --%test(Recognize payment by customer)\n  procedure test_recognize_by_customer;\n\nend test_payment_recognition;\n</code></pre></p> <p>And payments set off test package: <pre><code>create or replace package test_payment_set_off as\n\n  --%suite(Payment set off tests)\n  --%suitepath(payments)\n\n  --%test(Creates set off)\n  procedure test_create_set_off;\n\n  --%test(Cancels set off)\n  procedure test_cancel_set_off;\n\nend test_payment_set_off;\n</code></pre></p> <p>When you execute tests for your application, the framework constructs a test suite for each test package. Then it combines suites into grouping suites by the <code>--%suitepath</code> annotation value so that the fully qualified path to the <code>recognize_by_num</code> procedure is <code>USER:payments.test_payment_recognition.test_recognize_by_num</code>. If any of its expectations fails then the test is marked as failed, also the <code>test_payment_recognition</code> suite, the parent suite <code>payments</code> and the whole run is marked as failed. The test report indicates which expectation has failed on the payments module. The payments recognition submodule is causing the failure as <code>recognize_by_num</code> has not met the expectations of the test. Grouping tests into modules and submodules using the <code>--%suitepath</code> annotation allows you to logically organize your project's flat structure of packages into functional groups.</p> <p>An additional advantage of such grouping is the fact that every element level of the grouping can be an actual unit test package containing a common module level setup for all of the submodules. So in addition to the packages mentioned above you could have the following package. <pre><code>create or replace package payments as\n\n  --%suite(Payments)\n\n  --%beforeall\n  procedure set_common_payments_data;\n\n  --%afterall\n  procedure reset_common_paymnets_data;\n\nend payments;\n</code></pre></p> <p>When executing tests, <code>path</code> for executing tests can be provided in three ways:</p> <ul> <li>schema - execute all tests in the schema</li> <li>[schema]:suite1[.suite2][.suite3]...[.procedure] - execute all tests by <code>suitepath</code> in all suites on path suite1[.suite2][.suite3]...[.procedure]. If schema is not provided, then the current schema is used. Example: <code>:all.rooms_tests</code></li> <li>[schema.]package[.procedure] - execute all tests in the specified test package. The whole hierarchy of suites in the schema is built before all before/after hooks or part suites for the provided suite package are executed as well. Example: <code>tests.test_contact.test_last_name_validator</code> or simply <code>test_contact.test_last_name_validator</code> if <code>tests</code> is the current schema.</li> </ul>"},{"location":"userguide/annotations.html#rollback","title":"Rollback","text":"<p>By default, changes performed by every setup, cleanup and test procedure are isolated by savepoints. This solution is suitable for use-cases where the code that is being tested as well as the unit tests themselves do not use transaction control (commit/rollback) or DDL commands.</p> <p>In general, your unit tests should not use transaction control as long as the code you are testing is not using it too. Keeping the transactions uncommitted allows your changes to be isolated and the execution of tests does not impact others who might be using a shared development database.</p> <p>If you are in a situation where the code you are testing uses transaction control (common case with ETL code), then your tests probably should not use the default automatic transaction control. In that case use the annotation <code>--%rollback(manual)</code> on the suite level to disable automatic transaction control for the entire suite. If you are using nested suites, you need to make sure that the entire suite all the way to the root is using manual transaction control.</p> <p>It is possible with utPLSQL to change the transaction control on individual suites or tests that are part of complex suite. It is strongly recommended not to have mixed transaction control in a suite. Mixed transaction control settings will not work properly when your suites are using shared setup/cleanup with beforeall, afterall, beforeeach or aftereach annotations. Your suite will most likely fail with error or warning on execution. Some of the automatic rollbacks will probably fail to execute depending on the configuration you have.</p> <p>In some cases it is necessary to perform DDL as part of setup or cleanup for the tests. It is recommended to move such DDL statements to a procedure with <code>pragma autonomous_transaction</code> to eliminate implicit commits in the main session that is executing all your tests. Doing so allows your tests to use the framework's automatic transaction control and releases you from the burden of manual cleanup of data that was created or modified by test execution.</p> <p>When you are testing code that performs explicit or implicit commits, you may set the test procedure to run as an autonomous transaction with <code>pragma autonomous_transaction</code>. Keep in mind that when your test runs as autonomous transaction it will not see the data prepared in a setup procedure unless the setup procedure committed the changes.</p> <p>Note</p> <p>The <code>--%suitepath</code> annotation, when used, must be provided with a value of path. The path in suitepath cannot contain spaces. Dot (.) identifies individual elements of the path.</p> <p>Example: <code>--%suitepath(org.utplsql.core.utils)</code> </p>"},{"location":"userguide/annotations.html#throws","title":"Throws","text":"<p>The <code>--%throws</code> annotation allows you to specify a list of exceptions as one of:</p> <ul> <li>number literals - example <code>--%throws(-20134)</code></li> <li>variables of type exception defined in a package specification - example <code>--%throws(exc_pkg.c_exception_No_variable)</code></li> <li>variables of type number defined in a package specification - example <code>--%throws(exc_pkg.c_some_exception)</code></li> <li>predefined oracle exceptions - example <code>--%throws(no_data_found)</code></li> </ul> <p>The annotation is ignored, when no valid arguments are provided. Examples of invalid annotations <code>--%throws()</code>,<code>--%throws</code>, <code>--%throws(abe, 723pf)</code>.</p> <p>If <code>--%throws</code> annotation is specified with arguments and no exception is raised, the test is marked as failed.</p> <p>If <code>--%throws</code> annotation is specified with arguments and exception raised is not on the list of provided exceptions, the test is marked as failed.</p> <p>The framework will raise a warning, when <code>--%throws</code> annotation has invalid arguments or when no arguments were provided.</p> <p>Annotation <code>--%throws(7894562, operaqk, -=1, -20496, pow74d, posdfk3)</code> will be interpreted as <code>--%throws(-20496)</code>.</p> <p>Please note that <code>NO_DATA_FOUND</code> exception is a special case in Oracle. To capture it use <code>NO_DATA_FOUND</code> named exception or <code>-1403</code> exception No.</p> <p>Example: <pre><code>create or replace package exc_pkg is\n  c_e_option1  constant number := -20200;\n  c_e_option2  constant varchar2(10) := '-20201';\n  c_e_option3  number := -20202;\n\n  e_option4 exception;\n  pragma exception_init(e_option4, -20203);\n\nend;\n/\n\ncreate or replace package example_pgk as\n\n  --%suite(Example Throws Annotation)\n\n  --%test(Throws one of the listed exceptions)\n  --%throws(-20145,bad,-20146, -20189 ,-20563)\n  procedure raised_one_listed_exception;\n\n  --%test(Throws different exception than expected)\n  --%throws(-20144)\n  procedure raised_different_exception;\n\n  --%test(Throws different exception than listed)\n  --%throws(-20144,-00001,-20145)\n  procedure raised_unlisted_exception;\n\n  --%test(Gives failure when an exception is expected and nothing is thrown)\n  --%throws(-20459, -20136, -20145)\n  procedure nothing_thrown;\n\n  --%test(Throws package exception option1)\n  --%throws(exc_pkg.c_e_option1)\n  procedure raised_option1_exception;\n\n  --%test(Throws package exception option2)\n  --%throws(exc_pkg.c_e_option2)\n  procedure raised_option2_exception;\n\n  --%test(Throws package exception option3)\n  --%throws(exc_pkg.c_e_option3)\n  procedure raised_option3_exception;\n\n  --%test(Throws package exception option4)\n  --%throws(exc_pkg.e_option4)\n  procedure raised_option4_exception;\n\n  --%test(Raise name exception)\n  --%throws(DUP_VAL_ON_INDEX)\n  procedure raise_named_exc;\n\n  --%test(Invalid throws annotation)\n  --%throws\n  procedure bad_throws_annotation;\n\nend;  \n/\ncreate or replace package body example_pgk is\n  procedure raised_one_listed_exception is\n  begin\n      raise_application_error(-20189, 'Test error');\n  end;\n\n  procedure raised_different_exception is\n  begin\n      raise_application_error(-20143, 'Test error');\n  end;\n\n  procedure raised_unlisted_exception is\n  begin\n      raise_application_error(-20143, 'Test error');\n  end;\n\n  procedure nothing_thrown is\n  begin\n      ut.expect(1).to_equal(1);\n  end;\n\n  procedure raised_option1_exception is\n  begin\n      raise_application_error(exc_pkg.c_e_option1, 'Test error');\n  end;\n\n  procedure raised_option2_exception is\n  begin\n      raise_application_error(exc_pkg.c_e_option2, 'Test error');\n  end;\n\n  procedure raised_option3_exception is\n  begin\n      raise_application_error(exc_pkg.c_e_option3, 'Test error');\n  end;\n\n  procedure raised_option4_exception is\n  begin\n      raise exc_pkg.e_option4;\n  end;\n\n  procedure raise_named_exc is\n  begin\n      raise DUP_VAL_ON_INDEX;\n  end;\n\n  procedure bad_throws_annotation is\n  begin\n    null;\n  end;\nend;\n/\n\nexec ut3.ut.run('example_pgk');\n</code></pre></p> <p>Running the test will give report: <pre><code>Example Throws Annotation\n  Throws one of the listed exceptions [.002 sec]\n  Throws different exception than expected [.002 sec] (FAILED - 1)\n  Throws different exception than listed [.003 sec] (FAILED - 2)\n  Gives failure when an exception is expected and nothing is thrown [.002 sec] (FAILED - 3)\n  Throws package exception option1 [.003 sec]\n  Throws package exception option2 [.002 sec]\n  Throws package exception option3 [.002 sec]\n  Throws package exception option4 [.002 sec]\n  Raise name exception [.002 sec]\n  Invalid throws annotation [.002 sec]\n\nFailures:\n\n  1) raised_different_exception\n      Actual: -20143 was expected to equal: -20144\n      ORA-20143: Test error\n      ORA-06512: at \"UT3.EXAMPLE_PGK\", line 9\n      ORA-06512: at \"UT3.EXAMPLE_PGK\", line 9\n      ORA-06512: at line 6\n\n  2) raised_unlisted_exception\n      Actual: -20143 was expected to be one of: (-20144, -1, -20145)\n      ORA-20143: Test error\n      ORA-06512: at \"UT3.EXAMPLE_PGK\", line 14\n      ORA-06512: at \"UT3.EXAMPLE_PGK\", line 14\n      ORA-06512: at line 6\n\n  3) nothing_thrown\n      Expected one of exceptions (-20459, -20136, -20145) but nothing was raised.\n\n\nWarnings:\n\n  1) example_pgk\n      Invalid parameter value \"bad\" for \"--%throws\" annotation. Parameter ignored.\n      at \"UT3.EXAMPLE_PGK.RAISED_ONE_LISTED_EXCEPTION\", line 6\n  2) example_pgk\n      \"--%throws\" annotation requires a parameter. Annotation ignored.\n      at \"UT3.EXAMPLE_PGK.BAD_THROWS_ANNOTATION\", line 42\n\nFinished in .025784 seconds\n10 tests, 3 failed, 0 errored, 0 disabled, 2 warning(s)\n</code></pre></p>"},{"location":"userguide/annotations.html#order-of-execution","title":"Order of execution","text":"<pre><code>create or replace package test_employee_pkg is\n\n  --%suite(Employee management)\n  --%suitepath(com.my_company.hr)\n  --%rollback(auto)\n\n  --%beforeall\n  procedure setup_employees;\n\n  --%beforeall\n  procedure setup_departments;\n\n  --%afterall\n  procedure cleanup_log_table;\n\n  --%context(add_employee)\n\n  --%beforeeach\n  procedure setup_for_add_employees;\n\n  --%test(Raises exception when employee already exists)\n  --%throws(-20145)\n  procedure add_existing_employee;\n\n  --%test(Inserts employee to emp table)\n  procedure add_employee;  \n\n  --%endcontext\n\n\n  --%context(remove_employee)\n\n  --%beforeall\n  procedure setup_for_remove_employee;\n\n  --%test(Removed employee from emp table)\n  procedure del_employee;\n\n  --%endcontext\n\n  --%test(Test without context)\n  --%beforetest(setup_another_test)\n  --%aftertest(cleanup_another_test)\n  procedure some_test;\n\n  --%test(Name of test)\n  --%disabled\n  procedure disabled_test;\n\n  --%test(Name of test)\n  --%rollback(manual)\n  procedure no_transaction_control_test;\n\n  procedure setup_another_test;\n\n  procedure cleanup_another_test;\n\n  --%beforeeach\n  procedure set_session_context;\n\n  --%aftereach\n  procedure cleanup_session_context;\n\nend test_employee_pkg;\n</code></pre> <p>When processing the test suite <code>test_employee_pkg</code> defined in Example of annotated test package, the order of execution will be as follows.</p> <pre><code>  create a savepoint 'before-suite'         \n    execute setup_employees                 (--%beforeall)\n    execute setup_departments               (--%beforeall)\n\n    create a savepoint 'before-context'     \n      create savepoint 'before-test'\n          execute test_setup                (--%beforeeach)\n          execute setup_for_add_employees   (--%beforeeach from context)\n          execute add_existing_employee     (--%test)\n          execute test_cleanup              (--%aftereach)\n      rollback to savepoint 'before-test'\n      create savepoint 'before-test'        (--%suite)\n          execute test_setup                (--%beforeeach)\n          execute setup_for_add_employees   (--%beforeeach from context)\n          execute add_employee              (--%test)\n          execute test_cleanup              (--%aftereach)\n      rollback to savepoint 'before-test'      \n    rollback to savepoint 'before-context'  \n\n    create a savepoint 'before-context'\n      execute setup_for_remove_employee     (--%beforeall from context)     \n      create savepoint 'before-test'\n          execute test_setup                (--%beforeeach)\n          execute add_existing_employee     (--%test)\n          execute test_cleanup              (--%aftereach)\n      rollback to savepoint 'before-test'\n    rollback to savepoint 'before-context'  \n\n    create savepoint 'before-test'\n      execute test_setup                    (--%beforeeach)\n      execute some_test                     (--%test)\n      execute test_cleanup                  (--%aftereach)\n    rollback to savepoint 'before-test'     \n\n    create savepoint 'before-test'          \n      execute test_setup                    (--%beforeeach)\n      execute setup_another_test            (--%beforetest)\n      execute another_test                  (--%test)\n      execute cleanup_another_test          (--%aftertest)\n      execute test_cleanup                  (--%beforeeach)\n    rollback to savepoint 'before-test'\n\n    mark disabled_test as disabled          (--%test --%disabled)\n\n    execute test_setup                      (--%beforeeach)\n    execute no_transaction_control_test     (--%test)\n    execute test_cleanup                    (--%aftertest)\n\n    execute global_cleanup                  (--%afterall)\n  rollback to savepoint 'before-suite'\n</code></pre> <p>Note</p> <p>utPLSQL does not guarantee ordering of tests in suite. On contrary utPLSQL might give random order of tests/contexts in suite. Order of execution within multiple occurrences of <code>before</code>/<code>after</code> procedures is determined by the order of annotations in specific block (context/suite) of package specification.</p>"},{"location":"userguide/annotations.html#sys_context","title":"sys_context","text":"<p>It is possible to access information about currently running suite. The information is available by calling <code>sys_context( 'UT3_INFO', attribute )</code>. It can be accessed from any procedure invoked as part of utPLSQL test execution.</p> <p>Note</p> <p>Context name is derived from schema name where utPLSQL is installed. The context name in below examples represents the default install schema -&gt; <code>UT3</code> If you install utPLSQL into another schema the context name will be different. For example if utPLSQL is installed into <code>HR</code> schema, the context name will be <code>HR_INFO</code></p> <p>Following attributes are populated:</p> Name Scope Description COVERAGE_RUN_ID run Value of COVERAGE_RUN_ID used by utPLSQL internally for coverage gathering RUN_PATHS run list of suitepaths / suitenames used as input parameters for call to <code>ut.run(...)</code> or <code>ut_runner.run(...)</code> SUITE_DESCRIPTION run the description of test suite that is currently being executed SUITE_PACKAGE run the owner and name of test suite package that is currently being executed SUITE_PATH run the suitepath for the test suite package that is currently being executed SUITE_START_TIME run the execution start timestamp of test suite package that is currently being executed CURRENT_EXECUTABLE_NAME run the owner.package.procedure of currently running test suite executable CURRENT_EXECUTABLE_TYPE run the type of currently running test suite executable (one of: <code>beforeall</code>, <code>beforeeach</code>, <code>beforetest</code>, <code>test</code>, <code>aftertest</code>, <code>aftereach</code>, <code>afterall</code> CONTEXT_DESCRIPTION suite context the description of test suite context that is currently being executed CONTEXT_NAME suite context the name of test suite context that is currently being executed CONTEXT_PATH suite context the suitepath for the currently executed test suite context CONTEXT_START_TIME suite context the execution start timestamp for the currently executed test suite context TEST_DESCRIPTION test* the description of test for which the current executable is being invoked TEST_NAME test* the name of test for which the current executable is being invoked TEST_START_TIME test* the execution start timestamp of test that is currently being executed (the time when first <code>beforeeach</code>/<code>beforetest</code> was called for that test) <p>Scopes</p> <ul> <li>run - context information is available in any element of test run</li> <li>suite context - context information is available in any element nested within a suite context </li> <li>test* - context information is available when executing following procedure types: test, beforetest, aftertest, beforeeach or aftereach </li> </ul> <p>Example: <pre><code>create or replace procedure which_procecure_called_me is\nbegin\n  dbms_output.put_line(\n    'Currently running utPLSQL ' ||sys_context( 'ut3_info', 'current_executable_type' )\n    ||' ' ||sys_context( 'ut3_info', 'current_executable_name' )\n  );\nend;\n/\n\ncreate or replace package test_call is\n\n  --%suite\n\n  --%beforeall\n  procedure beforeall;\n\n  --%beforeeach\n  procedure beforeeach;\n\n  --%test\n  procedure test1;\n\n  --%test\n  procedure test2;\n\nend;\n/\n\ncreate or replace package body test_call is\n\n  procedure beforeall is\n  begin\n    which_procecure_called_me();\n    dbms_output.put_line('Current test procedure is: '||sys_context('ut3_info','test_name'));\n  end;\n\n  procedure beforeeach is\n  begin\n    which_procecure_called_me();\n    dbms_output.put_line('Current test procedure is: '||sys_context('ut3_info','test_name'));\n  end;\n\n  procedure test1 is\n  begin\n    which_procecure_called_me();\n    ut.expect(sys_context('ut3_info','suite_package')).to_equal(user||'.test_call');\n  end;\n\n  procedure test2 is\n  begin\n    which_procecure_called_me();\n    ut.expect(sys_context('ut3_info','test_name')).to_equal(user||'.test_call.test2');\n  end;\n\nend;\n/\n</code></pre></p> <pre><code>exec ut.run('test_call');\n</code></pre> <pre><code>test_call\n  Currently running utPLSQL beforeall UT3.test_call.beforeall\n  Current test procedure is: \n  test1 [.008 sec]\n  Currently running utPLSQL beforeeach UT3.test_call.beforeeach\n  Current test procedure is: UT3.test_call.test1\n  Currently running utPLSQL test UT3.test_call.test1\n  test2 [.004 sec]\n  Currently running utPLSQL beforeeach UT3.test_call.beforeeach\n  Current test procedure is: UT3.test_call.test2\n  Currently running utPLSQL test UT3.test_call.test2\n\nFinished in .021295 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre>"},{"location":"userguide/annotations.html#annotation-cache","title":"Annotation cache","text":"<p>utPLSQL needs to scan the source of package specifications to identify and parse annotations. To improve framework startup time, especially when dealing with database users owning large amounts of packages, the framework has a built-in persistent cache for annotations.</p> <p>The annotation cache is checked for staleness and refreshed automatically on every run. The initial startup of utPLSQL for a schema will take longer than consecutive executions.</p> <p>If you are in a situation where your database is controlled via CI/CD server and is refreshed/wiped before each run of your tests, consider building the annotation cache upfront and taking a snapshot of the database after the cache has been refreshed.</p> <p>To build the annotation cache without actually invoking any tests, call <code>ut_runner.rebuild_annotation_cache(a_object_owner)</code> for every unit test owner for which you want to have the annotation cache prebuilt. Example: <pre><code>exec ut_runner.rebuild_annotation_cache('HR');\n</code></pre></p> <p>To purge the annotation cache call <code>ut_runner.purge_cache(a_object_owner, a_object_type)</code>. Both parameters are optional and if not provided, all owners/object_types will be purged.  Example: <pre><code>exec ut_runner.purge_cache('HR', 'PACKAGE');\n</code></pre></p>"},{"location":"userguide/best-practices.html","title":"Testing best practices","text":"<p>The following are best practices we at utPLSQL have learned about PL/SQL and Unit Testing. </p>"},{"location":"userguide/best-practices.html#test-isolation-and-dependency","title":"Test Isolation and Dependency","text":"<ul> <li>Tests should not depend on a specific order to run </li> <li>Tests should not depend on other tests to execute</li> <li>Tests should not depend on specific database state, they should setup the expected state before being run</li> <li>Tests should keep the environment unchanged post execution</li> </ul>"},{"location":"userguide/best-practices.html#writing-tests","title":"Writing tests","text":"<ul> <li>Tests should not mimic / duplicate the logic of tested code</li> <li>Tests should contain zero logic (or as close to zero as possible)</li> <li>The 3A rule:<ul> <li>Arrange (setup inputs/data/environment for the tested code)</li> <li>Act (execute code under test)</li> <li>Assert (validate the outcomes of the execution)</li> </ul> </li> <li>Each tested procedure/function/trigger (code block) should have more than one test</li> <li>Each test should check only one behavior (one requirement) of the code block under test</li> <li>Tests should be maintained as thoroughly as production code</li> <li>Every test needs to be built so that it can fail, tests that do not fail when needed are useless  </li> </ul>"},{"location":"userguide/best-practices.html#gaining-value-from-the-tests","title":"Gaining value from the tests","text":"<ul> <li>Tests are only valuable if they are executed frequently; ideally with every change to the project code</li> <li>Tests need to run very fast; the slower the tests, the longer you wait. Build tests with performance in mind (do you really need to have 10k rows to run the tests?)</li> <li>Tests that are executed infrequently can quickly become stale and end up adding overhead rather than value. Maintain tests as you would maintain code.</li> <li>Tests that are failing need to be addressed immediately. How can you trust your tests when 139 of 1000 tests are failing for a month? Will you recognise each time that it is still the same 139 tests?  </li> </ul>"},{"location":"userguide/best-practices.html#tests-are-not-for-production","title":"Tests are not for production","text":"<p>Tests will generate and operate on fake data. They might insert, update and delete data. You don't want tests to run on a production database and affect real life data.</p>"},{"location":"userguide/best-practices.html#tests-and-their-relationship-to-code-under-test","title":"Tests and their relationship to code under test","text":"<ul> <li>Tests and the code under test should be in separate packages. This is a fundamental separation of responsibilities.</li> <li>It is common for test code to be in the same schema as the tested code. This removes the need to manage privileges for the tests. </li> </ul>"},{"location":"userguide/best-practices.html#version-control","title":"Version Control","text":"<p>Use a version control system for your code.  Don't just trust the database for code storage. This includes both the code under test, and the unit tests you develop as well. Treat the database as a target/destination for your code, not as a source of it.</p>"},{"location":"userguide/coverage.html","title":"Code coverage","text":"<p>utPLSQL comes with a built-in coverage reporting engine. The code coverage reporting uses package DBMS_PROFILER (and DBMS_PLSQL_CODE_COVERAGE on Oracle database version 12.2 and above) provided with Oracle database. Code coverage is gathered for the following source types:</p> <ul> <li>package bodies</li> <li>type bodies</li> <li>triggers</li> <li>procedures</li> <li>functions</li> </ul> <p>Note</p> <p>The package and type specifications are excluded from code coverage analysis.  This limitation is introduced to avoid false-negatives. Typically package specifications contain no executable code.  The only exception is initialization of global constants and variables in package specification. Since most package specifications are not executable at all, there is no information available  on the number of lines covered and those would be reported as 0% covered, which is not desirable.</p> <p>To obtain information about code coverage for unit tests, run utPLSQL with one of built-in code coverage reporters. The following code coverage reporters are supplied with utPLSQL:</p> <ul> <li><code>ut_coverage_html_reporter</code> - generates a HTML coverage report providing summary and detailed information on code coverage. The HTML reporter is based on the open-source simplecov-html reporter for Ruby. It includes source code of the code that was covered (if the code is accessible for test user)  </li> <li><code>ut_coveralls_reporter</code> - generates a Coveralls compatible JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like Coveralls</li> <li><code>ut_coverage_sonar_reporter</code>  - generates a Sonar Compatible XML coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like SonarQube and SonarCloud</li> <li><code>ut_coverage_cobertura_reporter</code>  - generates a basic Cobertura coverage (http://cobertura.sourceforge.net/xml/coverage-04.dtd) report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like TFS and Jenkins. Check this link for an example of XML generated by Java: https://raw.githubusercontent.com/jenkinsci/cobertura-plugin/master/src/test/resources/hudson/plugins/cobertura/coverage-with-data.xml</li> </ul>"},{"location":"userguide/coverage.html#security-model","title":"Security model","text":"<p>utPLSQL code coverage uses DBMS_PROFILER to gather information about the execution of code under test and therefore follows the DBMS_PROFILER's Security Model. In order to be able to gather coverage information, the user executing unit tests needs to be either:</p> <ul> <li>The owner of the code that is being tested</li> <li>Have the following privileges to be able to gather coverage on code owned by other users:<ul> <li><code>create any procedure</code> system privilege</li> <li><code>execute</code> privilege on the code that is being tested (not only the unit tests) or <code>execute any procedure</code> system privilege</li> </ul> </li> </ul> <p>If you have <code>execute</code> privilege on the code that is being tested, but do not have <code>create any procedure</code> system privilege, then the code that is being tested will be reported as not covered (coverage = 0%). If you have <code>execute</code> privilege only on the unit tests, but do not have <code>execute</code> privilege on the code that is being tested, the code will not be reported by coverage - as if it did not exist in the database. If the code that is being tested is compiled as NATIVE, the code coverage will not be reported as well.</p>"},{"location":"userguide/coverage.html#manually-running-unit-tests-with-coverage","title":"Manually running unit tests with coverage","text":"<p>Using the code coverage functionality is as easy as using any other reporter for the utPLSQL test-run. Run your tests from your preferred SQL tool and save the reporter results to a file. All you need to do, is pass the constructor of the reporter to the <code>ut.run</code> procedure call.</p> <p>Example: <pre><code>set serveroutput on\nbegin\n  ut.run(ut_coverage_html_reporter());\nend;\n/\n</code></pre> The above command executes all unit tests in the current schema, gathers information about code coverage for all sources in that schema and outputs the HTML report as text into DBMS_OUTPUT. The <code>ut_coverage_html_reporter</code> will produce an interactive HTML report. You can see a sample of code coverage for the utPLSQL project here</p> <p>The report provides summary information with a list of source code that should be covered.</p> <p></p> <p>The report allow you to navigate to each source file and inspect line by line coverage.</p> <p></p>"},{"location":"userguide/coverage.html#oracle-122-extended-coverage-with-profiler-and-block-coverage","title":"Oracle 12.2 extended coverage with profiler and block coverage","text":"<p>Using data collected from profiler and block coverage running parallel we are able to enrich information about coverage. For every line recorded by the profiler if we have a partially covered same line in block coverage we will display that information presenting line as partially covered, displaying number of block and how many blocks have been covered in that line.The feature will be automatically enabled in the Oracle database version 12.2 and higher, for older versions current profiler will be used.</p> <p>utPLSQL installation automatically creates tables needed by <code>dbms_plsql_code_coverage</code> on databases in versions above 12c Release 1. Due to security model of <code>dbms_plsql_code_coverage</code> package, utPLSQL grants access to those tables and creates synonyms for those tables. The access and synonyms will be public when using the headless installation. This approach avoids complexity of forcing every user of utPLSQL framework to create tables on their own.    </p> <p>Sample output:</p> <p></p> <p></p>"},{"location":"userguide/coverage.html#coverage-reporting-options","title":"Coverage reporting options","text":"<p>There are two distinct ways to gather code coverage: - Coverage on database schema(s) - Coverage on project files</p> <p>Those two options are mutually exclusive and cannot be mixed. By default, when using one of coverage reporters, coverage is gathered on schema(s).  The database schema(s) containing the tests that were executed during the run will be reported on by coverage reporter.</p> <p>The parameters used to execute tests determine if utPLSQL will be using one approach or the other. If parameter <code>a_source_file_mappings</code> or <code>a_source_files</code> is provided, then coverage is gathered on project files provided, otherwise coverage is gathered on schemas.  </p> <p>Note</p> <p>Regardless of the options provided, all unit test packages are excluded from the coverage report. Coverage reports provide information only about the tested code.</p> <p>The default behavior of coverage reporting can be altered using invocation parameters.</p>"},{"location":"userguide/coverage.html#schema-based-coverage","title":"Schema based Coverage","text":"<p>To gather coverage for all objects in the current schema execute tests with coverage report as argument. This is the default reporting option and therefore additional coverage options don't need to be provided. </p> <pre><code>exec ut.run(ut_coverage_html_reporter());\n</code></pre> <p>Note</p> <p>When no filters are used, the size of the coverage report will depend two factors:     - the type of report (does the report include source code or not)     - the amount of source code in the database schema Keep in mind that for schemas containing a lot of code, it can take quite some time to produce the coverage report.</p>"},{"location":"userguide/coverage.html#setting-coverage-schemas","title":"Setting coverage schema(s)","text":"<p>By default, coverage is gathered on the schema(s) derived from suite paths provided to execute tests. This is a valid approach as long as your test packages and tested code share the same schema.</p> <p>So when you run: <pre><code>exec ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter());\n</code></pre> Coverage will be gathered on both <code>user_1</code> and <code>user_2</code> objects.</p> <p>If your tests live in a different schema from the tested code you may override the default behavior by providing an explicit list of coverage schema names.</p> <p>In the example below, coverage will still be gathered for <code>user_1</code> and <code>user_2</code> objects, even thought we run the tests located in schema <code>unit_test_schema</code></p> <pre><code>begin\n  ut.run('unit_test_schema', ut_coverage_html_reporter(), \n    a_coverage_schemes =&gt; ut_varchar2_list('user_1','user_2') \n  );\nend;\n</code></pre>"},{"location":"userguide/coverage.html#filtering-objects-in-coverage-reports","title":"Filtering objects in coverage reports","text":"<p>Multiple parameters can be used to define the scope of coverage report.</p> <ul> <li><code>a_source_file_mappings ( ut_file_mappings )</code> - map of filenames to database objects. It is used for file-based coverage - see below.</li> <li><code>a_include_schema_expr  (    varchar(4000) )</code> - string of regex expression of schemas to be included in the coverage report. Case-insensitive. </li> <li><code>a_include_object_expr  (    varchar(4000) )</code> - string of regex expression of objects ( without schema name ) to be included in the coverage report. Case-insensitive.</li> <li><code>a_exclude_schema_expr  (    varchar(4000) )</code> - string of regex expression of schemas to be excluded from the coverage report. Case-insensitive.</li> <li><code>a_exclude_object_expr  (    varchar(4000) )</code> - string of regex expression of objects ( without schema name ) to be excluded from the coverage report. Case-insensitive. </li> <li><code>a_coverage_schemes     ( ut_varchar2_list )</code> - List of database schema names to gather coverage on.</li> <li><code>a_include_objects      ( ut_varchar2_list )</code> - list of <code>[object_owner.]object_name</code> to be included in the coverage report.</li> <li><code>a_exclude_objects      ( ut_varchar2_list )</code> - list of <code>[object_owner.]object_name</code> to be excluded from the coverage report.</li> </ul> <p>You may specify both include and exclude options to gain more control over what needs to be included / excluded from the coverage report.</p> <p>Important note</p> <p>The order of priority is for evaluation of include/exclude filter parameters is as follows. - if <code>a_source_file_mappings</code> is defined then all include/exclude parameters are ignored (see section below for usage of <code>a_source_file_mappings</code> parameter ) - else if <code>a_include_schema_expr</code> or <code>a_include_object_expr</code> parameter is specified then parameters <code>a_coverage_schemes</code> and <code>a_include_objects</code> are ignored - else if <code>a_include_objects</code> is specified then the coverage is gathered only on specified database objects.    - if <code>a_coverage_schemes</code> is specified then those schemas are used for objects in <code>a_include_objects</code> without schema name    - if <code>a_coverage_schemes</code> is not specified then schema from paths (<code>a_paths</code>) parameter are used for objects in <code>a_include_objects</code> without schema name  - else if, only the <code>a_coverage_schemes</code> is specified then the coverage is gathered only on specified database schemas - else if no coverage specific parameters are provided coverage is gathered on all schemas specified in paths passed to run procedure - else if no paths were specified, the coverage is gathered on current schema of the session running the tests</p> <p>The exclude parameters are not mutually-exclusive and can be mixed together. All of exclude parameters are always applied.  </p> <p>Example: Limiting coverage by schema regex. <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_include_schema_expr =&gt; '^ut3_develop'\n  );\nend;\n</code></pre> Will result in showing coverage for all schemas that match regular expression <code>^ut3_develop</code></p> <p>Example: Limiting coverage by schema regex with parameter <code>a_include_objects</code> ignored.  <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(),\n    a_include_schema_expr =&gt; '^ut3_develop', a_include_objects =&gt; ut_varchar2_list( 'ut3_tester_helper.regex_dummy_cov' )\n  );\nend;\n</code></pre> Will result in showing coverage for all schemas that match regular expression <code>^ut3_develop</code>.</p> <p>Example: Limiting coverage by object regex.  <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_include_object_expr =&gt; 'regex123'\n  );\nend;\n</code></pre> Will result in showing coverage for all objects that name match regular expression <code>regex123</code>.</p> <p>Example: Limiting coverage by object regex with parameter <code>a_include_objects</code> ignored.  <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_include_object_expr =&gt; 'utl', a_include_objects =&gt; ut_varchar2_list( 'user_2.utils_package' )\n  );\nend;\n</code></pre> Will result in showing coverage for all objects that name match regular expression <code>utl</code>.</p> <p>Example: Limiting coverage by excluding schema with regex.  <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_exclude_schema_expr =&gt; 'er_1$'\n  );\nend;\n</code></pre> Will result in showing coverage for objects in all schema except schemas that are matching regular expression <code>er_1$</code></p> <p>Example: Limiting coverage by excluding schema with regex and excluding specific object.  <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_exclude_schema_expr =&gt; 'er_1$', a_exclude_objects =&gt; ut_varchar2_list( 'user_2.utils_package' )\n  );\nend;\n</code></pre> Will result in showing coverage for objects in all schemas except schemas that are matching regular expression <code>er_1$</code> Will also exclude object <code>user_2.utils_package</code> from coverage report</p> <p>Example: Limiting coverage by excluding objects with regex.  <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_exclude_object_expr =&gt; 'utl'\n  );\nend;\n</code></pre> Will result in showing coverage for all objects that name is not matching regular expression <code>utl</code>.</p> <p>Example: Limiting coverage by excluding objects with regex with parameter <code>a_exclude_objects</code> ignored.  <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_exclude_object_expr =&gt; 'utl', a_exclude_objects =&gt; ut_varchar2_list( 'user_2.utils_package' )\n  );\nend;\n</code></pre> Will result in showing coverage for all objects that name is not matching regular expression <code>utl</code>. Will also exclude object <code>user_2.utils_package</code> from coverage report</p> <p>Example: Limiting coverage by object name, for tested code located in the same schema as the unit tests. <pre><code>begin\n  ut.run(ut_varchar2_list('user_1','user_2'), ut_coverage_html_reporter(), \n    a_include_objects=&gt;ut_varchar2_list('award_bonus')\n  );\nend;\n</code></pre> Executes all tests in schemas: <code>user_1</code> and <code>user_2</code>. Coverage will only be reported on objects <code>user_1.award_bonus</code>, <code>user_2.award_bonus</code></p> <p>Example: Limiting coverage by object name, for tested code located in different schemas than the unit tests. <pre><code>begin\n  ut.run(\n    'unit_test_schema', ut_coverage_html_reporter(),\n     a_coverage_schemes =&gt; ut_varchar2_list('user_1','user_2'),\n     a_include_objects =&gt; ut_varchar2_list('award_bonus', 'betwnstr')\n  );\nend;\n</code></pre> Executes all tests in schema <code>unit_test_schema</code>. Coverage will only be reported on objects <code>user_1.award_bonus</code>, <code>user_2.award_bonus</code>, <code>user_1.betwnstr</code>, <code>user_2.betwnstr</code>. Objects that do not exist in the database but were specified in <code>a_include_objects</code> will be ignored.</p> <p>Example: Limiting coverage by object owner and name. <pre><code>begin\n  ut.run(\n    'unit_test_schema', ut_coverage_html_reporter(),\n     a_include_objects =&gt; ut_varchar2_list('user_1.award_bonus','user_2.betwnstr')\n  );\nend;\n</code></pre> Executes all tests in schema <code>unit_test_schema</code>. Coverage will only be reported on objects <code>user_1.award_bonus</code>, <code>user_2.betwnstr</code></p> <p>The <code>a_exclude_objects</code> can be used in the same way as <code>a_include_objects</code>.</p> <p>Example: Excluding objects from coverage report by providing a list of object owner/name to be excluded. <pre><code>begin\n  ut.run(\n    'unit_test_schema.test_award_bonus', ut_coverage_html_reporter(), \n    a_exclude_objects =&gt; ut_varchar2_list('ut3_user.betwnstr')\n  );\nend;\n</code></pre> Executes test <code>test_award_bonus</code> in schema <code>unit_test_schema</code>. Coverage will be reported on all objects in schema <code>ut3_user</code> except the <code>betwnstr</code> object.</p> <p>Note</p> <p>Filtering using <code>a_include_objects</code> and <code>a_exclude_objects</code> is only applicable when gathering coverage for a schema. Those filters are not applied when reporting coverage on project files.</p> <p>Note</p> <p>When running coverage on schema objects, all source code of package bodies, functions, procedures, type bodies and triggers that were not executed will be reported as having 0% code coverage and all source code lines will show as uncovered. This is different from the behavior when gathering coverage on project files.</p>"},{"location":"userguide/coverage.html#project-based-coverage","title":"Project based Coverage","text":"<p>utPLSQL provides reporters that produce reports consumable by external tools like <code>Sonar</code>/<code>SonarCloud</code> &amp; <code>Coveralls</code>.</p> <p>Services like Sonar, Coveralls and others perform analysis based on source code in project files. They are abstracted from database, schema names, packages, procedures and functions, and operate on a more generic concept of project source code.</p> <p>To be able to effectively use reporters dedicated for those tools, utPLSQL provides functionality for mapping database object names to project files.</p> <p>There are a few significant differences when running coverage on project files compared to running coverage on schema(s).</p> <ul> <li>Coverage is only reported on objects that were successfully mapped to project files.</li> <li>Project files (database objects) that were not executed at all are not reported as fully uncovered. It is up to the consumer (Sonar/Coveralls) to determine if project file should be considered as 0% coverage or just ignored.</li> </ul> <p>In order to successfully use coverage on project files, those files must be mapped to database objects.</p> <p>Though you can gather project based code coverage directly using <code>exec ut.run(...)</code>, it is highly recommended to use utPLSQL-cli command line client.</p> <p>The examples below are using utPLSQL-cli to execute tests and gather coverage information.</p>"},{"location":"userguide/coverage.html#file-mapping-using-default-parameters","title":"File mapping using default parameters","text":"<p>The example below illustrates a directory structure supported by the default parameters of utPLSQL. The structure represents a multi-schema project with file names indicating object owner. <pre><code>C:\n  \\my_project\n    \\sources\n      \\hotel.add_rooms_content.prc\n      \\hotel.remove_rooms_by_name.prc\n      \\hotel.rooms.tbl\n      \\hr.award_bonus.prc\n      \\hr.betwnstr.fnc\n      \\hr.employees_test.tbl\n    \\tests\n      \\hotel.test_add_room_content.pkb\n      \\hotel.test_add_room_content.pks\n      \\hotel.test_remove_rooms_by_name.pkb\n      \\hotel.test_remove_rooms_by_name.pks\n      \\hr.test_award_bonus.pkb\n      \\hr.test_award_bonus.pks\n      \\hr.test_betwnstr.pkb\n      \\hr.test_betwnstr.pks\n</code></pre></p> <p>By default, utPLSQL will convert file paths into database objects using the following regular expression <code>/(((\\w|[$#])+)\\.)?((\\w|[$#])+)\\.(\\w{3})$</code></p> <ul> <li>object owner (if it is present) is identified by the expression in the second set of  brackets</li> <li>object name is identified by the expression in the fourth set of brackets</li> <li>object type is identified by the expression in the sixth set of brackets</li> </ul> <p>Note</p> <p>utPLSQL will replace any '\\' with '/' for the purpose of mapping files to objects. The paths shown in the results will remain (contain '\\' where it was present). This is done to simplify the syntax of regular expressions. Regular expression will always use '/' as a directory separator on a file path regardless of whether you're on a Windows or Unix system.    </p> <p>Note</p> <p>Below examples assume that you have downloaded latest version of utPLSQL-cli  and extracted it into your projects root directory and that you run the utPLSQL-cli from that directory.    </p> <p>Windows: <pre><code>utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_host:db_port/db_service_name ^\n -p=hr,hotel ^\n -source_path=sources ^\n -test_path=tests ^\n -f=ut_coverage_html_reporter -o=coverage.html ^\n -f=ut_sonar_test_reporter    -o=test_results.xml\n</code></pre></p> <p>Bash: <pre><code>utPLSQL-cli/bin/utplsql run test_runner/pass@db_host:db_port/db_service_name \\\n -p=hr,hotel \\\n -source_path=sources \\\n -test_path=tests \\\n -f=ut_coverage_html_reporter -o=coverage.html \\\n -f=ut_sonar_test_reporter    -o=test_results.xml\n</code></pre></p> <p>The above commands will:</p> <ul> <li>connect as user <code>test_runner</code></li> <li>run all utPLSQL v3 tests for users <code>hr</code>, <code>hotel</code></li> <li>map database code to project files in <code>sources</code> directory and save code coverage results into <code>coverage.html</code></li> <li>map test packages to project files in <code>tests</code> directory and save test results into <code>test_results.xml</code> </li> </ul> <p>To better understand the default regular expression used, have a look here.</p> <p>Tested code is mapped to files in <code>coverage.html</code></p> <p></p> <p>Unit test code is mapped to files in <code>test_results.xml</code></p> <p></p>"},{"location":"userguide/coverage.html#using-custom-regular-expressions","title":"Using custom regular expressions","text":"<p>If your project directory structure is different, you can use additional configuration parameters to tell utPLSQL how the project files are to be mapped into database objects.  </p> <p>Example: Using custom regular expressions on a multi-schema project with separate directories for each object owner. <pre><code>C:\n  \\my_project\n    \\sources\n      \\hotel\n        \\add_rooms_content.prc\n        \\remove_rooms_by_name.prc\n        \\rooms.tbl\n      \\hr\n        \\award_bonus.prc\n        \\betwnstr.fnc\n        \\employees_test.tbl\n    \\tests\n      \\hotel\n        \\test_add_room_content.pkb\n        \\test_add_room_content.pks\n        \\test_remove_rooms_by_name.pkb\n        \\test_remove_rooms_by_name.pks\n      \\hr\n        \\test_award_bonus.pkb\n        \\test_award_bonus.pks\n        \\test_betwnstr.pkb\n        \\test_betwnstr.pks\n</code></pre></p> <p>The command below will gather coverage and map files to database objects using custom regular expression. Note that the owner/name/type subexpressions don't need to be explicitly specified if they are same as default values ( 2/3/4 ). In the below example, they were specified explicitly only for <code>source_path</code>, <code>test_path</code> doesn't have subexpressions specified and so they are default (2/3/4).</p> <p>Windows: <pre><code>utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^\n -p=hr,hotel ^\n -source_path=sources ^\n -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" ^\n -owner_subexpression=2 ^\n -name_subexpression=3 ^\n -type_subexpression=4 ^\n -test_path=tests -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" ^\n -f=ut_coverage_html_reporter -o=coverage.html ^\n -f=ut_sonar_test_reporter -o=test_results.xml ^\n</code></pre></p> <p>Bash: <pre><code>utPLSQL-cli/bin/utplsql run test_runner/pass@db_url \\\n -source_path=sources \\\n -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" \\\n -owner_subexpression=2 \\\n -name_subexpression=3 \\\n -type_subexpression=4 \\\n -test_path=tests -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" \\\n -owner_subexpression=2 \\\n -name_subexpression=3 \\\n -type_subexpression=4 \\\n -f=ut_coverage_html_reporter -o=coverage.html \\\n -f=ut_sonar_test_reporter -o=test_results.xml\n</code></pre></p> <p>You can specify different mapping rules for source files and for test files - see utPLSQL-cli readme for details.</p> <p>To better understand the regular expression used, have a look here.</p> <p>Tested code is mapped to files in <code>coverage.html</code></p> <p></p> <p>Unit test code is mapped to files in <code>test_results.xml</code></p> <p></p>"},{"location":"userguide/coverage.html#explicitly-specifying-object-owner","title":"Explicitly specifying object owner","text":"<p>When dealing with projects that operate within a single schema the project structure probably doesn't indicate the owner. In such scenarios, you can explicitly specify the object owner for both tests and source code.</p> <p>Example: Single-schema project - no indication of object owner <pre><code>C:\n  \\my_project\n    \\sources\n      \\betwnstr.fnc\n    \\tests\n      \\test_betwnstr.pkb\n      \\test_betwnstr.pks\n</code></pre></p> <p>The command below will gather coverage and map files to database objects. For the database objects mapped to <code>souces</code> directory user <code>code_owner</code>  will be used. For the database objects mapped to <code>tests</code>  directory user <code>tests_owner</code> will be used. </p> <p>Windows: <pre><code>utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^\n -p=tests_owner ^\n -source_path=sources -owner=code_owner ^\n -test_path=tests     -owner=tests_owner ^\n -f=ut_coverage_html_reporter -o=coverage.html ^\n -f=ut_sonar_test_reporter    -o=test_results.xml\n</code></pre></p> <p>Bash: <pre><code>utPLSQL-cli/bin/utplsql run test_runner/pass@db_url \\\n -p=tests_owner \\\n -source_path=sources -owner=code_owner \\\n -test_path=tests     -owner=tests_owner \\\n -f=ut_coverage_html_reporter -o=coverage.html \\\n -f=ut_sonar_test_reporter    -o=test_results.xml\n</code></pre></p> <p>Note</p> <p>When the project folder structure does not provide any information about source code owner and test owner, you can specify the owner for tests and owner for code explicitly. Such project configuration supports only single-owner for source code and single owner for tests.  </p> <p>Tested code is mapped to files in <code>coverage.html</code></p> <p></p> <p>Unit test code is mapped to files in <code>test_results.xml</code></p> <p></p>"},{"location":"userguide/coverage.html#custom-mapping-of-object-types","title":"Custom mapping of object types","text":"<p>By default, when mapping project files to database objects, utPLSQL will identify the object type by file extension.</p> <p>The table below represents the default mapping of file extensions to database object types.</p> file extension object type tpb type body pkb package body bdy package body trg trigger fnc function prc procedure <p>If your project naming convention differs and your file extensions do not match the above, or you simply name all of your files with <code>.sql</code> suffix, you can still use utPLSQL, but you need to provide custom mapping for object types.</p> <p>Example: Multi-schema project with separate directories for each object owner and object type <pre><code>C:\n  \\my_project\n    \\sources\n      \\hotel\n        \\functions\n        \\packages\n        \\packages_bodies\n        \\procedures\n          \\add_rooms_content.sql\n          \\remove_rooms_by_name.sql\n        \\tables\n          \\rooms.sql\n        \\triggers\n        \\types\n        \\type_bodies\n      \\hr\n        \\functions\n          \\betwnstr.sql\n        \\packages\n        \\package_bodies\n        \\procedures\n          \\award_bonus.sql\n        \\tables\n          \\employees_test.sql\n        \\triggers\n        \\types\n        \\types_bodies\n    \\tests\n      \\hotel\n        \\packages\n          \\test_add_room_content.sql\n          \\test_remove_rooms_by_name.sql\n        \\packages_bodies\n          \\test_add_room_content.sql\n          \\test_remove_rooms_by_name.sql\n      \\hr\n        \\packages\n          \\test_award_bonus.sql\n          \\test_betwnstr.sql\n        \\packages_bodies\n          \\test_award_bonus.sql\n          \\test_betwnstr.sql\n</code></pre></p> <p>Windows: <pre><code>utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^\n -p=hr,hotel ^\n -source_path=sources ^\n -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" ^\n -type_mapping=\"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" ^\n -owner_subexpression=1 ^\n -name_subexpression=3 ^\n -type_subexpression=2 ^\n -test_path=tests -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" ^\n -type_mapping=\"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" ^\n -owner_subexpression=1 ^\n -name_subexpression=3 ^\n -type_subexpression=2 ^\n -f=ut_coverage_html_reporter -o=coverage.html ^\n -f=ut_sonar_test_reporter -o=test_results.xml\n</code></pre></p> <p>Bash: <pre><code>utPLSQL-cli/bin/utplsql run test_runner/pass@db_urll \\\n -p=hr,hotel \\\n -source_path=sources \\\n -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" \\\n -type_mapping=\"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" \\\n -owner_subexpression=1 \\\n -name_subexpression=3 \\\n -type_subexpression=2 \\\n -test_path=tests -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" \\\n -type_mapping=\"body=PACKAGE BODY/type_body=TYPE BODY/trigger=TRIGGER\" \\\n -owner_subexpression=1 \\\n -name_subexpression=3 \\\n -type_subexpression=2 \\\n -f=ut_coverage_html_reporter -o=coverage.html \\\n -f=ut_sonar_test_reporter -o=test_results.xml\n</code></pre></p> <p>The parameter <code>type_mapping</code> accepts a list of a key-value pairs representing a mapping of regex subexpression to database object type.  </p> <p>To better understand the regular expression used, have a look here.</p> <p>Tested code is mapped to files in <code>coverage.html</code></p> <p></p> <p>Unit test code is mapped to files in <code>test_results.xml</code></p> <p></p>"},{"location":"userguide/coverage.html#object-file-mapping-rules","title":"Object-file mapping rules","text":"<p>In order to allow deterministic and accurate mapping of database source-code into project files, the project directory and file structure needs to meet certain criteria.</p> <ul> <li>Source code is kept separate from test code (separate directories)</li> <li>Each database (source-code) object is stored in an individual file. Package/type specification is kept separate from its body.</li> <li>File name (file path) contains the name of database object</li> <li>Each file-path clearly identifies object type (by file extension)</li> <li>Each file contains representation of database object \"as is\". No extra commands (like <code>set echo off</code> <code>ALTER SESSION SET PLSQL_CCFLAGS = 'debug:TRUE';</code>) or blank lines are present before <code>CREATE TYPE</code>,<code>CREATE TYPE</code> etc.</li> <li>When project is spanning across multiple database schemes, each file-path clearly and uniformly identifies object owner</li> </ul>"},{"location":"userguide/coverage.html#file-mapping-from-sql","title":"File mapping from SQL","text":"<p>The <code>ut.run</code> command provides interface to map project into database objects when executing tests. While it is much easier to perform mapping directly from command line, it is possible to achieve similar functionality from any SQL client. The main differences when using the <code>ut.run(...)</code> command, will be:</p> <ul> <li>you can only use single reporter and therefore will get only one report from test execution</li> <li>you need to provide fill list of project files rather than point to <code>sources</code> and <code>tests</code> directories</li> </ul> <p>Example project directory structure.  <pre><code>C:\n  \\my_project\n    \\sources\n      \\hotel\n        \\functions\n        \\packages\n        \\packages_bodies\n        \\procedures\n          \\add_rooms_content.sql\n          \\remove_rooms_by_name.sql\n        \\tables\n          \\rooms.sql\n        \\triggers\n        \\types\n        \\type_bodies\n      \\hr\n        \\functions\n          \\betwnstr.sql\n        \\packages\n        \\package_bodies\n        \\procedures\n          \\award_bonus.sql\n        \\tables\n          \\employees_test.sql\n        \\triggers\n        \\types\n        \\types_bodies\n    \\tests\n      \\hotel\n        \\packages\n          \\test_add_room_content.sql\n          \\test_remove_rooms_by_name.sql\n        \\packages_bodies\n          \\test_add_room_content.sql\n          \\test_remove_rooms_by_name.sql\n      \\hr\n        \\packages\n          \\test_award_bonus.sql\n          \\test_betwnstr.sql\n        \\packages_bodies\n          \\test_award_bonus.sql\n          \\test_betwnstr.sql\n</code></pre></p> <p>To execute all tests and map database source code into source file names you could use the following command in any SQL client:        </p> <pre><code>begin\n  ut.run(\n    ut_varchar2_list('hr','hotel'),\n    ut_coverage_html_reporter(),\n    a_source_file_mappings =&gt;\n      ut_file_mapper.build_file_mappings(\n        a_file_paths  =&gt; ut_varchar2_list(\n          'sources\\hotel\\procedures\\add_rooms_content.sql',\n          'sources\\hotel\\procedures\\remove_rooms_by_name.sql',\n          'sources\\hotel\\tables\\rooms.sql',\n          'sources\\hr\\functions\\betwnstr.sql',\n          'sources\\hr\\procedures\\award_bonus.sql',\n          'sources\\hr\\tables\\employees_test.sql'\n          ),\n        a_regex_pattern =&gt; '/(\\w+)/(\\w+)/(\\w+)\\..{3}$',\n        a_object_owner_subexpression =&gt; 1,\n        a_object_name_subexpression =&gt; 3,\n        a_object_type_subexpression =&gt; 2,\n        a_file_to_object_type_mapping =&gt; ut_key_value_pairs(\n          ut_key_value_pair('packages_bodies', 'PACKAGE BODY'),\n          ut_key_value_pair('types_bodies', 'TYPE BODY'),\n          ut_key_value_pair('triggers', 'TRIGGER'),\n          ut_key_value_pair('procedures', 'PROCEDURE'),\n          ut_key_value_pair('functions', 'FUNCTION')\n        )\n      )\n  );\nend;\n</code></pre> <p>To execute all tests and map database tests code into test file names you could use the following command in any SQL client:       <pre><code>begin\n  ut.run(\n    ut_varchar2_list('hr','hotel'),\n    ut_sonar_test_reporter(),\n    a_test_file_mappings =&gt;\n      ut_file_mapper.build_file_mappings(\n        a_file_paths  =&gt; ut_varchar2_list(\n            'tests\\hotel\\packages\\test_add_room_content.sql',\n            'tests\\hotel\\packages\\test_remove_rooms_by_name.sql',\n            'tests\\hotel\\packages_bodies\\test_add_room_content.sql',\n            'tests\\hotel\\packages_bodies\\test_remove_rooms_by_name.sql',\n            'tests\\hr\\packages\\test_award_bonus.sql',\n            'tests\\hr\\packages\\test_betwnstr.sql',\n            'tests\\hr\\packages_bodies\\test_award_bonus.sql',\n            'tests\\hr\\packages_bodies\\test_betwnstr.sql'\n          ),\n        a_regex_pattern =&gt; '/(\\w+)/(\\w+)/(\\w+)\\..{3}$',\n        a_object_owner_subexpression =&gt; 1,\n        a_object_name_subexpression =&gt; 3,\n        a_object_type_subexpression =&gt; 2,\n        a_file_to_object_type_mapping =&gt; ut_key_value_pairs(\n          ut_key_value_pair('packages_bodies', 'PACKAGE BODY'),\n          ut_key_value_pair('types_bodies', 'TYPE BODY'),\n          ut_key_value_pair('triggers', 'TRIGGER'),\n          ut_key_value_pair('procedures', 'PROCEDURE'),\n          ut_key_value_pair('functions', 'FUNCTION')\n        )\n      )\n  );\nend;\n</code></pre></p>"},{"location":"userguide/coverage.html#reporting-coverage-outside-utplsql-and-in-parallel-sessions","title":"Reporting coverage outside utPLSQL and in parallel sessions","text":"<p>utPSLQL allows fo standalone reporting code coverage across multiple database sessions. This functionality enables coverage reporting for external testing tools.</p> <p>Following API calls enable the  standalone coverage reporting.</p> <ul> <li><code>ut_runner.coverage_start( coverage_run_id );</code> - initiates code coverage within a session    </li> <li><code>ut_runner.coverage_stop();</code> - stops gathering of code coverage within a session</li> <li><code>.get_report( ... )</code> - coverage reporters function producing coverage report as pipelined data-set (to be used in SQL query) </li> <li><code>.get_report_cursor( ... )</code> - coverage reporters function producing coverage report as ref-cursor </li> </ul> <p>Example: <pre><code>--SESSION 1\n-- gather coverage on code using specific coverage_run_id value\ndeclare\n  l_coverage_run_id raw(32);\nbegin\n  l_coverage_run_id := 'A6AA5B7361251CE6E053020011ACA055';\n--  l_coverage_run_id := sys_guid;\n  ut_runner.coverage_start(l_coverage_run_id);\n\n  --The code to gather coverage on goes here   \n\n  ut_runner.coverage_stop();\nend;\n/\n</code></pre></p> <pre><code>--SESSION 2\n-- alternative approach\n-- gather coverage on code using specific coverage_run_id value\nexec ut_runner.coverage_start('A6AA5B7361251CE6E053020011ACA055');  \n\n--The code to gather coverage on goes here   \n\nexec ut_runner.coverage_stop();\n</code></pre> <pre><code>--SESSION 1 or SESSION2 2 or SESSION 3 \n-- run after calls in SESSION 1 &amp; 2 are finished\n-- retrieve coverage report in HTML format coverage_run_id value\nselect *\n  from table(\n    ut_coverage_html_reporter().get_report(\n      a_coverage_options =&gt; ut_coverage_options(\n        coverage_run_id =&gt; 'A6AA5B7361251CE6E053020011ACA055'\n      )\n    )\n  ); \n</code></pre> <pre><code>--SESSION 1 or SESSION2 2 or SESSION 3 \n-- run after calls in SESSION 1 &amp; 2 are finished\ndeclare\n  l_results_cursor sys_refcursor;\nbegin\n  l_results_cursor :=  ut_coverage_html_reporter().get_report_cursor(\n      a_coverage_options =&gt; ut_coverage_options(\n        coverage_run_id =&gt; 'A6AA5B7361251CE6E053020011ACA055'\n      )\n    );\n  --fetch and process the cursor results\n  close l_results_cursor;\nend;\n/\n</code></pre> <p>Specification of parameters for <code>get_report</code> and <code>get_report_cursor</code> <pre><code>function get_report(\n   a_coverage_options ut_coverage_options,\n   a_client_character_set varchar2 := null \n) return ut_varchar2_rows pipelined\n</code></pre></p> <p><pre><code>function get_report_cursor(\n   a_coverage_options ut_coverage_options,\n   a_client_character_set varchar2 := null \n) return sys_refcursor\n</code></pre> <pre><code>ut_coverage_options(\n  coverage_run_id          raw,\n  schema_names             ut_varchar2_rows := null,\n  exclude_objects          ut_varchar2_rows := null,\n  include_objects          ut_varchar2_rows := null,\n  file_mappings            ut_file_mappings := null\n  include_schema_expr      varchar2(4000) := null,\n  include_object_expr      varchar2(4000) := null,\n  exclude_schema_expr      varchar2(4000) := null,\n  exclude_object_expr      varchar2(4000) := null\n);\n</code></pre></p> <p>The <code>a_client_character_set</code> is used to provide character set to the report. Coverage reports in XML and HTML format include this information to assure that HMTL/XML encoding tag is aligned with encoding of the report produced. Use this parameter to provide encoding of your client application.   </p> <p>The <code>a_coverage_options</code> parameter is used to control the scope and formatting of data returned by report.</p> <p><code>ut_coverage_options</code> object accepts the following arguments</p> <ul> <li><code>coverage_run_id</code> - identifier of coverage run to generate report for - data-type <code>RAW(32)</code> </li> <li><code>schema_names</code> - optional - list of schema names to include in coverage report - data-type <code>UT_VARCHAR2_ROWS</code> </li> <li><code>exclude_objects</code> - optional - list of object names to exclude from report - data-type <code>UT_VARCHAR2_ROWS</code> </li> <li><code>include_objects</code> - optional - list of object names to gather coverage on - data-type <code>UT_VARCHAR2_ROWS</code></li> <li><code>file_mappings</code> - optional - list of schema names to gather coverage on - data-type <code>UT_FILE_MAPPINGS</code></li> <li><code>include_schema_expr</code> - optional - regular expression to match against schema name to include in coverage - data-type <code>VARCHAR2(4000)</code></li> <li><code>include_object_expr</code> - optional - regular expression to match against object name to include in coverage - data-type <code>VARCHAR2(4000)</code></li> <li><code>exclude_schema_expr</code> - optional - regular expression to match against schema name to exclude in coverage - data-type <code>VARCHAR2(4000)</code></li> <li><code>exclude_object_expr</code> - optional - regular expression to match against object name to exclude in coverage - data-type <code>VARCHAR2(4000)</code></li> </ul> <p><code>coverage_run_id</code> parameter identifies a common coverage run. The valid value type for that parameter is RAW(32). It is recommended to use <code>sys_guid()</code> to generate a common, unique identifier for a specific coverage run. If the identifier is not unique, previous runs of coverage that used the same <code>coverage_run_id</code> will be aggregated to the resulting coverage report.    </p> <p>For details on the meaning of <code>schema_names</code>, <code>exclude_objects</code>, <code>include_objects</code>, <code>file_mappings</code> see sections above. Note that data-types of include/exclude/schema lists are different when calling <code>ut.run</code> vs. calling <code>get_report/get_report_cursor</code>.    </p>"},{"location":"userguide/exception-reporting.html","title":"Error handling and reporting","text":"<p>utPLSQL is responsible for handling exceptions wherever they occur in the test run. The framework is trapping most of the exceptions so that the test execution is not affected by individual tests or test packages throwing an exception. The framework provides a full stacktrace for every exception that was thrown. The reported stacktrace does not include any utPLSQL library calls in it. To achieve rerunability, the package state invalidation exceptions (ORA-04068, ORA-04061) are not handled and test execution will be interrupted if such exceptions are encountered. This is because of how Oracle behaves on those exceptions.</p> <p>Test execution can fail for different reasons. The failures on different exceptions are handled as follows:</p> Problem /  error Framework behavior A test package without body each <code>--%test</code> is reported as failed with exception, nothing is executed A test package with invalid body each <code>--%test</code> is reported as failed with exception, nothing is executed A test package with invalid spec package is not considered a valid unit test package and is excluded from execution. When trying to run a test package with invalid spec explicitly, exception is raised. Only valid specifications are parsed for annotations A test package that is raising an exception in <code>--%beforeall</code> each <code>--%test</code> is reported as failed with exception, <code>--%test</code>, <code>--%beforeeach</code>, <code>--%beforetest</code>, <code>--%aftertest</code> and <code>--%aftereach</code> are not executed. <code>--%afterall</code> is executed to allow cleanup of whatever was done in <code>--%beforeall</code> A test package that is raising an exception in <code>--%beforeeach</code> each <code>--%test</code> is reported as failed with exception, <code>--%test</code>, <code>--%beforetest</code> and <code>--%aftertest</code> is not executed. The <code>--%aftereach</code> and <code>--%afterall</code> blocks are getting executed to allow cleanup of whatever was done in <code>--%before...</code> blocks A test package that is raising an exception in <code>--%beforetest</code> the <code>--%test</code> is reported as failed  with exception, <code>--%test</code> is not executed. The <code>--%aftertest</code>, <code>--%aftereach</code> and <code>--%afterall</code> blocks are getting executed to allow cleanup of whatever was done in <code>--%before...</code> blocks A test package that is raising an exception in <code>--%test</code> the <code>--%test</code> is reported as failed with exception. The execution of other blocks continues normally A test package that is raising an exception in <code>--%aftertest</code> the <code>--%test</code> is reported as failed with exception. The execution of other blocks continues normally A test package that is raising an exception in <code>--%aftereach</code> each <code>--%test</code> is reported as failed with exception. A test package that is raising an exception in <code>--%afterall</code> all blocks of  the package are executed, as the <code>--%afterall</code> is the last step of package execution. Exception in <code>--%afterall</code> is not affecting test results. A warning with exception stacktrace is displayed in the summary <p>Warning</p> <p>If an exception is thrown in an <code>afterall</code> procedure then no failure reported by utPLSQL. Framework will only report a warning on the suite that the <code>afterall</code> belongs to.</p> <p>Example of reporting with exception thrown in <code>%beforetest</code>: <pre><code>Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 39\n               ORA-06512: at line 6\n\nFinished in ,039346 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.\n</code></pre></p> <p>Example of reporting with exception thrown in <code>%test</code>: <pre><code>Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 48\n               ORA-06512: at line 6\n\nFinished in ,035726 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.\n</code></pre></p> <p>Example of reporting with exception thrown in <code>%aftertest</code>: <pre><code>Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 42\n               ORA-06512: at line 6\n\nFinished in ,045523 seconds\n3 tests, 0 failed, 1 errored, 0 ignored.\n</code></pre></p> <p>Example of reporting with exception thrown in <code>%aftereach</code>: <pre><code>Remove rooms by name\n  Removes a room without content in it (FAILED - 1)\n  Does not remove room when it has content (FAILED - 2)\n  Raises exception when null room name given (FAILED - 3)\n\nFailures:\n\n  1) remove_empty_room\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31\n               ORA-06512: at line 6\n\n  2) room_with_content\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31\n               ORA-06512: at line 6\n\n  3) null_room_name\n\n        error: ORA-20001: Test exception\n               ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31\n               ORA-06512: at line 6\n\nFinished in ,034863 seconds\n3 tests, 0 failed, 3 errored, 0 ignored.\n</code></pre></p> <p>Example of reporting with exception thrown in <code>%afterall</code>: <pre><code>Remove rooms by name\n  Removes a room without content in it\n  Does not remove room when it has content\n  Raises exception when null room name given\n\nWarnings:\n\n  1) test_remove_rooms_by_name - Afterall procedure failed: \n       ORA-20001: Test exception\n       ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 35\n       ORA-06512: at line 6\n\nFinished in ,044902 seconds\n3 tests, 0 failed, 0 errored, 0 ignored. 1 warning(s)\n</code></pre></p>"},{"location":"userguide/expectations.html","title":"Expectations","text":""},{"location":"userguide/expectations.html#expectation-concepts","title":"Expectation concepts","text":"<p>Validation of the code under test (the tested logic of procedure/function etc.) is performed by comparing the actual data against the expected data.</p> <p>utPLSQL uses expectations and matchers to perform the check on the data.</p> <p>Example of an expectation <pre><code>begin\n  ut.expect( 'the tested value' ).to_equal('the expected value');\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: 'the tested value' (varchar2) was expected to equal: 'the expected value' (varchar2)\n  at \"anonymous block\", line 2\n</code></pre></p> <p>Expectation is a combination of:</p> <ul> <li>the expected value</li> <li>optional custom message for the expectation </li> <li>the matcher used to perform comparison</li> <li>the matcher parameters (actual value), depending on the matcher type</li> </ul> <p>Matcher defines the comparison operation to be performed on expected (and actual) value. Pseudo-code: <pre><code>  ut.expect( a_actual {data-type} [, a_message {varchar2}] ).to_( {matcher} );\n  ut.expect( a_actual {data-type} [, a_message {varchar2}] ).not_to( {matcher} );\n</code></pre></p> <p>Expectations provide two variants of syntax that you can use. Both variants are functionally-equal but give different usage flexibility.  </p> <p>Syntax where matcher is passed as parameter to the expectation: <pre><code>  ut.expect( a_actual ).to_( {matcher} );\n  ut.expect( a_actual ).not_to( {matcher} );\n  -- example\n  ut.expect( 1 ).to_( be_null() );\n</code></pre></p> <p>Shortcut syntax, where matcher is directly part of expectation: <pre><code>  ut.expect( a_actual ).to_{matcher};\n  ut.expect( a_actual ).not_to_{matcher};\n\n  --example\n  ut.expect( 1 ).to_be_null();\n</code></pre></p> <p>When using shortcut syntax you don't need to surround matcher with brackets. Shortcut syntax is provided for convenience.</p> <p>If you would like to perform more dynamic checks in your code, you could pass the matcher into a procedure like in the below example: <pre><code>declare\n  procedure do_check( p_actual varchar2, p_matcher ut_matcher ) is \n  begin\n    ut.expect(p_actual).to_( p_matcher );\n  end;\nbegin\n  do_check( 'a', equal('b') );\n  do_check( 'Alibaba', match('ali','i') );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: 'a' (varchar2) was expected to equal: 'b' (varchar2)\n  at \"anonymous block\", line 4\n  at \"anonymous block\", line 7\nSUCCESS\n  Actual: 'Alibaba' (varchar2) was expected to match: 'ali' , modifiers 'i'\n</code></pre></p> <p>Note</p> <p>In order to keep the document brief, the examples in the document are only using the standalone expectations syntax.  </p>"},{"location":"userguide/expectations.html#using-expectations","title":"Using expectations","text":"<p>There are two ways to use expectations: - by invoking utPLSQL framework to execute suite(s) of utPLSQL tests - without invoking the utPLSQL framework - running expectations standalone</p>"},{"location":"userguide/expectations.html#running-expectations-within-utplsql-framework","title":"Running expectations within utPLSQL framework","text":"<p>When expectations are run as a part of a test suite, the framework tracks:</p> <ul> <li>status of each expectation </li> <li>outcomes (messages) produced by each expectation</li> <li>call stack to each expectation</li> </ul> <p>In this case:</p> <ul> <li>expectation results of are not sent directly to <code>dbms_output</code></li> <li>utPLSQL Reporters used when running suite decide on how the expectation results are formatted and displayed    </li> </ul> <p>Example of test suite with an expectation: <pre><code>create or replace package test_divide as \n  --%suite(Divide two numbers)\n\n  --%test(Returns result when divisor is not zero)\n  procedure divide_6_by_2;\n\n  --%test(Throws exception when divisor is zero)\n  --%throws(zero_divide)\n  procedure divide_by_0_throws;\nend;\n/\n\ncreate or replace package body test_divide as \n  procedure divide_6_by_2 is\n  begin\n    ut.expect(6/2).to_equal(3);\n  end;\n\n  procedure divide_by_0_throws is\n  begin\n    ut.expect(6/0).to_be_not_null();\n  end;\nend;\n/\n\nexec ut.run('test_divide');\n\ndrop package test_divide;\n</code></pre></p> <p>Produces following outputs: <pre><code>Package TEST_DIVIDE compiled\n\n\nPackage Body TEST_DIVIDE compiled\n\nDivide two numbers\n  Returns result when divisor is not zero [.003 sec]\n  Throws exception when divisor is zero [.003 sec]\n\nFinished in .009774 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n\n\n\nPL/SQL procedure successfully completed.\n\n\nPackage TEST_DIVIDE dropped.\n</code></pre></p> <p>Please read about different options for running test suites.</p>"},{"location":"userguide/expectations.html#running-expectations-outside-utplsql-framework","title":"Running expectations outside utPLSQL framework","text":"<p>When expectations are invoked outside of utPLSQL framework the outputs from expectations are redirected straight to <code>dbms_output</code>.</p> <p>Note</p> <p>The output from expectation contains call stack trace only when expectation fails.  Source code of the line which called the expectation is only reported when the line is part of in-database code (package) and the user calling expectation has privileges to see that source code.</p> <p>Important</p> <p>Please do not use expectations as part of your production code. They are not designed to be used as part of your code. Expectations are meant to be used only as part of your day-to-day testing activities.</p>"},{"location":"userguide/expectations.html#matchers","title":"Matchers","text":"<p>utPLSQL provides the following matchers to perform checks on the expected and actual values.  </p> <ul> <li><code>be_between( a_upper_bound {data-type}, a_lower_bound {data-type} )</code></li> <li><code>be_empty()</code></li> <li><code>be_false()</code></li> <li><code>be_greater_than( a_expected {data-type} )</code></li> <li><code>be_greater_or_equal( a_expected {data-type} )</code></li> <li><code>be_less_or_equal( a_expected {data-type} )</code></li> <li><code>be_less_than( a_expected {data-type} )</code></li> <li><code>be_like( a_mask {varchar2} [, a_escape_char {varchar2}] )</code></li> <li><code>be_not_null()</code></li> <li><code>be_null()</code></li> <li><code>be_true()</code></li> <li><code>equal( a_expected {data-type} [, a_nulls_are_equal {boolean}] )</code></li> <li><code>contain( a_expected {data-type})</code></li> <li><code>have_count( a_expected {integer} )</code></li> <li><code>match( a_patter {varchar2} [, a_modifiers {varchar2}] )</code></li> </ul>"},{"location":"userguide/expectations.html#providing-a-custom-message","title":"Providing a custom message","text":"<p>You can provide a custom failure message by passing it as the second parameter to the expectation. <code>ut.expect( a_actual {data-type}, a_message {varchar2} ).to_{matcher}</code></p> <p>Example: <pre><code>exec  ut.expect( 'supercat', 'checked superhero-animal was not a dog' ).to_equal('superdog');\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  \"checked superhero-animal was not a dog\"\n  Actual: 'supercat' (varchar2) was expected to equal: 'superdog' (varchar2)\n  at \"anonymous block\", line 1\n</code></pre> If the message is provided, it is being added to the normal failure message returned by the matcher. This is mostly useful when your expectations accept dynamic content, as you can provide additional context to make failing test results more readable.</p> <p>In most cases, there is no need to provide custom message to expectation. This is because utPLSQL identifies:</p> <ul> <li>The test used to execute the expectation</li> <li>The line number where the expectation is placed in your test code</li> <li>The line text of the expectation</li> </ul> <p>Custom message is useful, if your expectation is placed in a shared procedure to perform a check and your test is using the procedure multiple times.</p> <p>Example: <pre><code>create or replace package shared_expectation_test is\n  --%suite\n\n  --%test\n  procedure the_test;\nend;\n/\ncreate or replace package body shared_expectation_test is\n  procedure table_is_empty(p_table_name varchar2) is\n    l_count integer;\n  begin\n    execute immediate 'select count(*) from '||p_table_name into l_count;\n    ut.expect( l_count, 'Checking table '||p_table_name ).to_equal(0);\n  end;\n\n  procedure the_test is\n  begin\n    table_is_empty('ALL_USERS');\n    table_is_empty('ALL_TABLES');\n  end;\nend;\n/\n\nexec ut.run('shared_expectation_test');\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>shared_expectation_test\n  the_test [.064 sec] (FAILED - 1)\n\nFailures:\n\n  1) the_test\n      \"Checking table ALL_USERS\"\n      Actual: 28 (number) was expected to equal: 0 (number)\n      at \"UT3_USER.SHARED_EXPECTATION_TEST.TABLE_IS_EMPTY\", line 6 ut.expect( l_count, 'Checking table '||p_table_name ).to_equal(0);\n      at \"UT3_USER.SHARED_EXPECTATION_TEST.THE_TEST\", line 11\n\n      \"Checking table ALL_TABLES\"\n      Actual: 55 (number) was expected to equal: 0 (number)\n      at \"UT3_USER.SHARED_EXPECTATION_TEST.TABLE_IS_EMPTY\", line 6 ut.expect( l_count, 'Checking table '||p_table_name ).to_equal(0);\n      at \"UT3_USER.SHARED_EXPECTATION_TEST.THE_TEST\", line 12\n\nFinished in .066344 seconds\n1 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>In the tests results window you can see the list of failed expectations for a test as well as:</p> <ul> <li>the additional message for expectation</li> <li>the reason why the expectation failed</li> <li>the line number of the expectation</li> <li>the line text of the expectations</li> <li>the call stack for the expectation (in the example it's the lines that called the procedure <code>table_is_empty</code>)</li> </ul>"},{"location":"userguide/expectations.html#negating-a-matcher","title":"Negating a matcher","text":"<p>Expectations provide a very convenient way to perform a check on a negated matcher.</p> <p>Syntax to check for matcher evaluating to true: <pre><code>begin \n  ut.expect( a_actual {data-type} ).to_{matcher};\n  ut.expect( a_actual {data-type} ).to_( {matcher} );\nend;\n</code></pre></p> <p>Syntax to check for matcher evaluating to false: <pre><code>begin\n  ut.expect( a_actual {data-type} ).not_to_{matcher};\n  ut.expect( a_actual {data-type} ).not_to( {matcher} );\nend;\n</code></pre></p> <p>If a matcher evaluated to NULL, then both <code>to_</code> and <code>not_to</code> will cause the expectation to report failure.</p> <p>Example: <pre><code>declare\n  l_actual boolean;\nbegin\n  ut.expect( l_actual ).to_be_true();\n  ut.expect( l_actual ).not_to_be_true();\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: NULL (boolean) was expected to be true\n  at \"anonymous block\", line 4\nFAILURE\n  Actual: NULL (boolean) was expected not to be true\n  at \"anonymous block\", line 5\n</code></pre> Since NULL is neither true nor false, both expectations will report failure.</p>"},{"location":"userguide/expectations.html#supported-data-types","title":"Supported data types","text":"<p>The matrix below illustrates the data types supported by different matchers.</p> Matcher blob boolean clob date number timestamp timestampwithtimezone timestampwithlocaltimezone varchar2 intervalyeartomonth intervaldaytosecond cursor nestedtable/ varray object json be_not_null X X X X X X X X X X X X X X X be_null X X X X X X X X X X X X X X X be_false X be_true X be_greater_than X X X X X X X be_greater_or_equal X X X X X X X be_less_or_equal X X X X X X X be_less_than X X X X X X X be_between X X X X X X X X equal X X X X X X X X X X X X X X X contain X X X match X X be_like X X be_empty X X X X X have_count X X X be_within().of_() X X X X X be_within_pct().of_() X"},{"location":"userguide/expectations.html#expecting-exceptions","title":"Expecting exceptions","text":"<p>Testing is not limited to checking for happy-path scenarios. When writing tests, you often want to validate that in specific scenarios, an exception is thrown.</p> <p>Use the <code>--%throws</code> annotation, to test for expected exceptions. </p> <p>Example: <pre><code>create or replace function divide(x varchar2, y varchar2) return number is\nbegin\n  return x/y;\nend;\n/\n\ncreate or replace package test_divide as\n  --%suite(Divide function)\n\n  --%test(Throws divisor equal)\n  --%throws(-01476)\n  procedure raises_divisor_exception;\nend;  \n/\n\ncreate or replace package body test_divide is\n\n  procedure raises_divisor_exception is\n    x integer;\n  begin\n    x := divide(6,0);\n  end;\n\nend;\n/\n\nexec ut.run('test_divide');\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>Divide function\n  Throws divisor equal [.007 sec]\n\nFinished in .009229 seconds\n1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>For more details see documentation of the <code>--%throws</code> annotation. </p>"},{"location":"userguide/expectations.html#matchers_1","title":"Matchers","text":"<p>You can choose different matchers to validate that your PL/SQL code is working as expected.</p>"},{"location":"userguide/expectations.html#be_between","title":"be_between","text":"<p>Validates that the actual value is between the lower and upper bound.</p> <p>Example: <pre><code>declare\n  l_timestamp     timestamp := current_timestamp;\n  l_timestamp_tz  timestamp with time zone := systimestamp;\n  l_timestamp_ltz timestamp with local time zone := systimestamp;\n  l_interval_ds   interval day to second := interval '1' second;\n  l_interval_ym   interval year to month := interval '1' year;\nbegin\n  ut.expect( 3 ).to_be_between( 1, 3 );\n  ut.expect( 5 ).to_( be_between( 1, 3 ) );\n  ut.expect( 3 ).not_to_be_between( 1, 3 );\n  ut.expect( 5 ).not_to( be_between( 1, 3 ) );  \n  ut.expect( sysdate ).to_be_between( sysdate, sysdate + 1 );\n  ut.expect( l_timestamp ).to_be_between( l_timestamp,  l_timestamp );\n  ut.expect( systimestamp ).to_be_between( l_timestamp_tz, systimestamp );\n  ut.expect( systimestamp ).to_be_between( l_timestamp_ltz, l_timestamp_ltz );\n  ut.expect( l_interval_ds ).to_be_between( interval '0.1' second, interval '1' day );\n  ut.expect( l_interval_ym ).to_be_between( interval '12' month, interval '12' year );\n  ut.expect( 'Abb' ).to_be_between( 'Aba', 'Abc' );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: 3 (number) was expected to be between: 1  and 3 \nFAILURE\n  Actual: 5 (number) was expected to be between: 1  and 3 \n  at \"anonymous block\", line 9\nFAILURE\n  Actual: 3 (number) was expected not to be between: 1  and 3 \n  at \"anonymous block\", line 10\nSUCCESS\n  Actual: 5 (number) was expected not to be between: 1  and 3 \nSUCCESS\n  Actual: 2019-07-07T21:25:27 (date) was expected to be between: 2019-07-07T21:25:27  and 2019-07-08T21:25:27 \nSUCCESS\n  Actual: 2019-07-07T22:25:27.701546000 (timestamp) was expected to be between: 2019-07-07T22:25:27.701546000  and 2019-07-07T22:25:27.701546000 \nSUCCESS\n  Actual: 2019-07-07T21:25:27.705768000 +00:00 (timestamp with time zone) was expected to be between: 2019-07-07T21:25:27.701596000 +00:00  and 2019-07-07T21:25:27.705808000 +00:00 \nFAILURE\n  The matcher 'be between' cannot be used with data type (timestamp with time zone).\n  at \"anonymous block\", line 15\nSUCCESS\n  Actual: +000000000 00:00:01.000000000 (interval day to second) was expected to be between: +000000000 00:00:00.100000000  and +000000001 00:00:00.000000000 \nSUCCESS\n  Actual: +000000001-00 (interval year to month) was expected to be between: +000000001-00  and +000000012-00 \nSUCCESS\n  Actual: 'Abb' (varchar2) was expected to be between: 'Aba'  and 'Abc'\n</code></pre></p>"},{"location":"userguide/expectations.html#be_empty","title":"be_empty","text":"<p>Unary matcher that validates if the provided dataset is empty.</p> <p>Can be used with <code>BLOB</code>,<code>CLOB</code>, <code>refcursor</code> or <code>nested table</code>/<code>varray</code> passed as <code>ANYDATA</code></p> <p>Note</p> <p>BLOB/CLOB that is initialized is not NULL but it is actually equal to <code>empty_blob()</code>/<code>empty_clob()</code>.</p> <p>Example: <pre><code>declare\n  l_cursor sys_refcursor;\nbegin\n  open l_cursor for select * from dual where 0=1;\n  ut.expect( l_cursor ).to_be_empty();\n  ut.expect( anydata.convertCollection(ut_varchar2_list()) ).to_( be_empty() );\n  ut.expect( empty_clob() ).not_to_be_empty();\n  ut.expect( empty_blob() ).not_to( be_empty() );\n  ut.expect( 1 ).not_to( be_empty() );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: (refcursor [ count = 0 ])\n      Data-types:\n      &lt;DUMMY&gt;VARCHAR2&lt;/DUMMY&gt;\n      Data:\n   was expected to be empty\nSUCCESS\n  Actual: (ut3.ut_varchar2_list [ count = 0 ])\n      Data-types:\n      &lt;UT_VARCHAR2_LIST&gt;VARCHAR2&lt;/UT_VARCHAR2_LIST&gt;\n      Data:\n   was expected to be empty\nFAILURE\n  Actual: EMPTY (clob) was expected not to be empty\n  at \"anonymous block\", line 7\nFAILURE\n  Actual: EMPTY (blob) was expected not to be empty\n  at \"anonymous block\", line 8\nFAILURE\n  The matcher 'be empty' cannot be used with data type (number).\n  at \"anonymous block\", line 9\n</code></pre></p>"},{"location":"userguide/expectations.html#be_false","title":"be_false","text":"<p>Unary matcher that validates if the provided value is false.</p> <p>Usage: <pre><code>begin\n  ut.expect( ( 1 = 0 ) ).to_be_false();\n  ut.expect( ( 1 = 1 ) ).to_( be_false() );\n  ut.expect( ( 1 = 0 ) ).not_to_be_false();\n  ut.expect( ( 1 = 1 ) ).not_to( be_false() );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: FALSE (boolean) was expected to be false\nFAILURE\n  Actual: TRUE (boolean) was expected to be false\n  at \"anonymous block\", line 3\nFAILURE\n  Actual: FALSE (boolean) was expected not to be false\n  at \"anonymous block\", line 4\nSUCCESS\n  Actual: TRUE (boolean) was expected not to be false\n</code></pre></p>"},{"location":"userguide/expectations.html#be_greater_or_equal","title":"be_greater_or_equal","text":"<p>Checks if the actual value is greater or equal than the expected.</p> <p>Usage: <pre><code>begin\n  ut.expect( sysdate ).to_be_greater_or_equal( sysdate - 1 );\n  ut.expect( sysdate ).to_( be_greater_or_equal( sysdate + 1 ) );\n  ut.expect( sysdate ).not_to_be_greater_or_equal( sysdate - 1 );\n  ut.expect( sysdate ).not_to( be_greater_or_equal( sysdate + 1 ) );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: 2019-07-07T22:43:29 (date) was expected to be greater or equal: 2019-07-06T22:43:29 (date)\nFAILURE\n  Actual: 2019-07-07T22:43:29 (date) was expected to be greater or equal: 2019-07-08T22:43:29 (date)\n  at \"anonymous block\", line 3\nFAILURE\n  Actual: 2019-07-07T22:43:29 (date) was expected not to be greater or equal: 2019-07-06T22:43:29 (date)\n  at \"anonymous block\", line 4\nSUCCESS\n  Actual: 2019-07-07T22:43:29 (date) was expected not to be greater or equal: 2019-07-08T22:43:29 (date)\n</code></pre></p>"},{"location":"userguide/expectations.html#be_greater_than","title":"be_greater_than","text":"<p>Checks if the actual value is greater than the expected.</p> <p>Usage: <pre><code>begin\n  ut.expect( 2 ).to_be_greater_than( 1 );\n  ut.expect( 0 ).to_( be_greater_than( 1 ) );\n  ut.expect( 2 ).not_to_be_greater_than( 1 );\n  ut.expect( 0 ).not_to( be_greater_than( 1 ) );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: 2 (number) was expected to be greater than: 1 (number)\nFAILURE\n  Actual: 0 (number) was expected to be greater than: 1 (number)\n  at \"anonymous block\", line 3\nFAILURE\n  Actual: 2 (number) was expected not to be greater than: 1 (number)\n  at \"anonymous block\", line 4\nSUCCESS\n  Actual: 0 (number) was expected not to be greater than: 1 (number)\n</code></pre></p>"},{"location":"userguide/expectations.html#be_less_or_equal","title":"be_less_or_equal","text":"<p>Checks if the actual value is less or equal than the expected.</p> <p>Usage: <pre><code>begin\n  ut.expect( 3 ).to_be_less_or_equal( 3 );\n  ut.expect( 4 ).to_( be_less_or_equal( 3 ) );\n  ut.expect( 3 ).not_to_be_less_or_equal( 3 );\n  ut.expect( 4 ).not_to( be_less_or_equal( 3 ) );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: 3 (number) was expected to be less or equal: 3 (number)\nFAILURE\n  Actual: 4 (number) was expected to be less or equal: 3 (number)\n  at \"anonymous block\", line 3\nFAILURE\n  Actual: 3 (number) was expected not to be less or equal: 3 (number)\n  at \"anonymous block\", line 4\nSUCCESS\n  Actual: 4 (number) was expected not to be less or equal: 3 (number)\n</code></pre></p>"},{"location":"userguide/expectations.html#be_less_than","title":"be_less_than","text":"<p>Checks if the actual value is less than the expected.</p> <p>Usage: <pre><code>begin\n  ut.expect( 3 ).to_be_less_than( 2 );\n  ut.expect( 0 ).to_( be_less_than( 2 ) );\n  ut.expect( 3 ).not_to_be_less_than( 2 );\n  ut.expect( 0 ).not_to( be_less_than( 2 ) );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: 3 (number) was expected to be less than: 2 (number)\n  at \"anonymous block\", line 2\nSUCCESS\n  Actual: 0 (number) was expected to be less than: 2 (number)\nSUCCESS\n  Actual: 3 (number) was expected not to be less than: 2 (number)\nFAILURE\n  Actual: 0 (number) was expected not to be less than: 2 (number)\n  at \"anonymous block\", line 5\n</code></pre></p>"},{"location":"userguide/expectations.html#be_like","title":"be_like","text":"<p>Validates that the actual value is like the expected expression.</p> <p>Syntax:</p> <p><code>ut.expect( a_actual ).to_be_like( a_mask [, a_escape_char] )</code></p> <p>Parameters <code>a_mask</code> and <code>a_escape_char</code> represent valid parameters of the Oracle LIKE condition.</p> <p>If you use Oracle Database version 11.2.0.4, you may run into Oracle Bug 14402514: WRONG RESULTS WITH LIKE ON CLOB USING ESCAPE CHARACTER. In this case we recommend to use <code>match</code> instead of <code>be_like</code>.</p> <p>Usage: <pre><code>begin\n  ut.expect( 'Lorem_impsum' ).to_be_like( '%rem%');\n  ut.expect( 'Lorem_impsum' ).to_be_like( '%rem\\_i%', '\\' );\n  ut.expect( 'Lorem_impsum' ).to_( be_like( 'Lor_m%' ) );\n  ut.expect( 'Lorem_impsum' ).not_to_be_like( '%rem%');\n  ut.expect( 'Lorem_impsum' ).not_to( be_like( '%reM%') );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: 'Lorem_impsum' (varchar2) was expected to be like: '%rem%' \nSUCCESS\n  Actual: 'Lorem_impsum' (varchar2) was expected to be like: '%rem\\_i%' , escape '\\'\nSUCCESS\n  Actual: 'Lorem_impsum' (varchar2) was expected to be like: 'Lor_m%' \nFAILURE\n  Actual: 'Lorem_impsum' (varchar2) was expected not to be like: '%rem%' \n  at \"anonymous block\", line 5\nSUCCESS\n  Actual: 'Lorem_impsum' (varchar2) was expected not to be like: '%reM%' \n</code></pre></p>"},{"location":"userguide/expectations.html#be_not_null","title":"be_not_null","text":"<p>Unary matcher that validates if the actual value is not null.</p> <p>Usage: <pre><code>begin \n  ut.expect( to_clob('ABC') ).to_be_not_null();\n  ut.expect( to_clob('') ).to_( be_not_null() );\n  ut.expect( to_clob('ABC') ).not_to_be_not_null();\n  ut.expect( '').not_to( be_not_null() );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: 'ABC' (clob) was expected to be not null\nFAILURE\n  Actual: NULL (clob) was expected to be not null\n  at \"anonymous block\", line 3\nFAILURE\n  Actual: 'ABC' (clob) was expected not to be not null\n  at \"anonymous block\", line 4\nSUCCESS\n  Actual: NULL (varchar2) was expected not to be not null\n</code></pre></p>"},{"location":"userguide/expectations.html#be_null","title":"be_null","text":"<p>Unary matcher that validates if the actual value is null.</p> <p>Usage: <pre><code>begin\n  ut.expect( '' ).to_be_null();\n  ut.expect( 0 ).to_( be_null() );\n  ut.expect( '' ).not_to_be_null();\n  ut.expect( 0 ).not_to( be_null() );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: NULL (varchar2) was expected to be null\nFAILURE\n  Actual: 0 (number) was expected to be null\n  at \"anonymous block\", line 3\nFAILURE\n  Actual: NULL (varchar2) was expected not to be null\n  at \"anonymous block\", line 4\nSUCCESS\n  Actual: 0 (number) was expected not to be null\n</code></pre></p>"},{"location":"userguide/expectations.html#be_true","title":"be_true","text":"<p>Unary matcher that validates if the provided value is true.</p> <p>Usage: <pre><code>begin\n  ut.expect( ( 1 = 0 ) ).to_be_true();\n  ut.expect( ( 1 = 1 ) ).to_( be_true() );\n  ut.expect( ( 1 = 0 ) ).not_to_be_true();\n  ut.expect( ( 1 = 1 ) ).not_to( be_true() );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: FALSE (boolean) was expected to be true\n  at \"anonymous block\", line 2\nSUCCESS\n  Actual: TRUE (boolean) was expected to be true\nSUCCESS\n  Actual: FALSE (boolean) was expected not to be true\nFAILURE\n  Actual: TRUE (boolean) was expected not to be true\n  at \"anonymous block\", line 5\n</code></pre></p>"},{"location":"userguide/expectations.html#have_count","title":"have_count","text":"<p>Unary matcher that validates if the provided dataset count is equal to expected value.</p> <p>Can be used with <code>refcursor</code>, <code>json</code> or <code>table type</code></p> <p>Usage: <pre><code>declare\n  l_cursor sys_refcursor;\n  l_collection ut_varchar2_list;\nbegin\n  open l_cursor for select * from dual connect by level &lt;=10;\n  ut.expect( l_cursor ).to_have_count(10);\n  open l_cursor for select rownum from xmltable('1 to 5');\n  ut.expect( l_cursor ).to_( have_count(10) );\n  l_collection := ut_varchar2_list( 'a', 'a', 'b' );\n  ut.expect( anydata.convertCollection( l_collection ) ).not_to_have_count(10);\n  ut.expect( anydata.convertCollection( l_collection ) ).not_to( have_count(3) );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: (refcursor [ count = 10 ]) was expected to have [ count = 10 ]\nFAILURE\n  Actual: (refcursor [ count = 5 ]) was expected to have [ count = 10 ]\n  at \"anonymous block\", line 8\nSUCCESS\n  Actual: ut3.ut_varchar2_list [ count = 3 ] was expected not to have [ count = 10 ]\nFAILURE\n  Actual: ut3.ut_varchar2_list [ count = 3 ] was expected not to have [ count = 3 ]\n  at \"anonymous block\", line 11\n</code></pre></p>"},{"location":"userguide/expectations.html#match","title":"match","text":"<p>Validates that the actual value is matching the expected regular expression.</p> <p>Syntax:</p> <p><code>ut.expect( a_actual ).to_match( a_pattern [, a_modifiers] );</code></p> <p>Parameters <code>a_pattern</code> and <code>a_modifiers</code> represent a valid regexp pattern accepted by Oracle REGEXP_LIKE condition</p> <p>Usage: <pre><code>begin \n  ut.expect( '123-456-ABcd' ).to_match( '\\d{3}-\\d{3}-[a-z]{4}', 'i' );\n  ut.expect( 'some value' ).to_( match( '^some.*' ) ) ;\n  ut.expect( '123-456-ABcd' ).not_to_match( '\\d{3}-\\d{3}-[a-z]{4}', 'i' );\n  ut.expect( 'some value' ).not_to( match( '^some.*' ) ) ;\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: '123-456-ABcd' (varchar2) was expected to match: '\\d{3}-\\d{3}-[a-z]{4}' , modifiers 'i'\nSUCCESS\n  Actual: 'some value' (varchar2) was expected to match: '^some.*' \nFAILURE\n  Actual: '123-456-ABcd' (varchar2) was expected not to match: '\\d{3}-\\d{3}-[a-z]{4}' , modifiers 'i'\n  at \"anonymous block\", line 4\nFAILURE\n  Actual: 'some value' (varchar2) was expected not to match: '^some.*' \n  at \"anonymous block\", line 5\n</code></pre></p>"},{"location":"userguide/expectations.html#equal","title":"equal","text":"<p>The <code>equal</code> matcher is very restrictive. Test using this matcher succeeds only when the compared data-types are exactly the same. If you are comparing a <code>varchar2</code> to a <code>number</code>, it will fail even if the text contains the same numeric value as the number. The matcher will also fail when comparing a <code>timestamp</code> to a <code>timestamp with timezone</code> data-type etc.</p> <p>The matcher enables detection of data-type changes.  If you expect your variable to be a number and it is now some other type, the test will fail and give you early indication of a potential problem.</p> <p>To keep it simple, the <code>equal</code> matcher will only succeed if you compare apples to apples.</p> <p>Syntax:</p> <p><code>ut.expect( a_actual ).to_equal( a_expected [, a_nulls_are_equal])[.advanced_options]</code> Example usage <pre><code>declare\n  l_actual   varchar2(20);\n  l_expected varchar2(20);\nbegin\n  --Arrange\n  l_actual := 'a dog';\n  --Assert\n  ut.expect( l_actual ).to_equal( 'other_dog' );\n  ut.expect( l_actual ).to_equal( '' );\n  ut.expect( l_actual ).to_equal( 1 );\n\n  l_actual := null;\n  ut.expect( l_actual ).to_equal( '' );\n  ut.expect( l_actual ).to_equal( '', a_nulls_are_equal =&gt; false );\n  ut.expect( l_actual ).not_to_equal( '' );\n  ut.expect( sysdate ).to_equal( sysdate );\n  ut.expect( sysdate ).to_equal( current_timestamp );\n  ut.expect( current_timestamp ).to_equal( systimestamp );\n  ut.expect( to_clob('varchar') ).to_equal( 'varchar' );\n  ut.expect( to_blob('aa') ).to_equal( to_blob('aa') );\n  ut.expect( to_clob('aa') ).to_equal( to_clob('aa') );\n  ut.expect( to_blob('aa') ).to_equal( to_clob('aa') );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: 'a dog' (varchar2) was expected to equal: 'other_dog' (varchar2)\n  at \"anonymous block\", line 8\nFAILURE\n  Actual: 'a dog' (varchar2) was expected to equal: NULL (varchar2)\n  at \"anonymous block\", line 9\nFAILURE\n  Actual (varchar2) cannot be compared to Expected (number) using matcher 'equal'.\n  at \"anonymous block\", line 10\nSUCCESS\n  Actual: NULL (varchar2) was expected to equal: NULL (varchar2)\nFAILURE\n  Actual: NULL (varchar2) was expected to equal: NULL (varchar2)\n  at \"anonymous block\", line 14\nFAILURE\n  Actual: NULL (varchar2) was expected not to equal: NULL (varchar2)\n  at \"anonymous block\", line 15\nSUCCESS\n  Actual: 2019-07-07T22:50:21 (date) was expected to equal: 2019-07-07T22:50:21 (date)\nFAILURE\n  Actual (date) cannot be compared to Expected (timestamp with time zone) using matcher 'equal'.\n  at \"anonymous block\", line 17\nFAILURE\n  Actual: 2019-07-07T23:50:21.159268000 +01:00 (timestamp with time zone) was expected to equal: 2019-07-07T22:50:21.159296000 +00:00 (timestamp with time zone)\n  at \"anonymous block\", line 18\nFAILURE\n  Actual (clob) cannot be compared to Expected (varchar2) using matcher 'equal'.\n  at \"anonymous block\", line 19\nSUCCESS\n  Actual: 'AA' (blob) was expected to equal: 'AA' (blob)\nSUCCESS\n  Actual: 'aa' (clob) was expected to equal: 'aa' (clob)\nFAILURE\n  Actual (blob) cannot be compared to Expected (clob) using matcher 'equal'.\n  at \"anonymous block\", line 22\n</code></pre></p> <p>Note</p> <p>by default, comparing NULL to NULL gives success The <code>a_nulls_are_equal</code> parameter controls the behavior of a <code>null = null</code> comparison. To change the behavior of <code>NULL = NULL</code> comparison pass the <code>a_nulls_are_equal =&gt; false</code> to the <code>equal</code> matcher.  </p>"},{"location":"userguide/expectations.html#contain","title":"contain","text":"<p>This matcher supports only compound data-types comparison. It check if the actual set contains all values of expected subset.</p> <p>When comparing data using the <code>contain</code> matcher, the data-types of columns for compared compound types must be exactly the same.</p> <p>The matcher supports all advanced comparison options as <code>equal</code> like: <code>include</code> , <code>exclude</code>, <code>join_by</code> etc..</p> <p>The matcher is successful when actual data set contains all of the values from expected results.</p> <p>The matcher will cause a test to fail if actual data set does not contain some of expected values.</p> <p></p> <p>Example 1. <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  --Arrange\n  open l_actual  for select rownum as rn  from dual a connect by level &lt; 10;\n  open l_expected for select rownum as rn from dual a connect by level &lt; 4\n  union all select rownum as rn from dual a connect by level &lt; 4;\n\n  --Act\n  ut.expect(l_actual).to_contain(l_expected);\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: refcursor [ count = 9 ] was expected to contain: refcursor [ count = 6 ]\n  Diff:\n  Rows: [ 3 differences ]\n  Missing:  &lt;RN&gt;1&lt;/RN&gt;\n  Missing:  &lt;RN&gt;2&lt;/RN&gt;\n  Missing:  &lt;RN&gt;3&lt;/RN&gt;\n  at \"anonymous block\", line 11\n</code></pre></p> <p>When duplicate rows are present in expected data set, actual data set must also include the same amount of duplicates.</p> <p>Example 2. <pre><code>declare\n  l_actual   ut_varchar2_list;\n  l_expected ut_varchar2_list;\nbegin\n  l_actual := ut_varchar2_list( 1, 2, 3, 4, 5, 6, 7, 8, 1 );\n  l_expected := ut_varchar2_list( 1, 2, 1, 2 );\n  ut.expect( anydata.convertCollection( l_actual ) ).to_contain( anydata.convertCollection( l_expected ) );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: ut3.ut_varchar2_list [ count = 9 ] was expected to contain: ut3.ut_varchar2_list [ count = 4 ]\n  Diff:\n  Rows: [ 1 differences ]\n  Missing:  &lt;UT_VARCHAR2_LIST&gt;2&lt;/UT_VARCHAR2_LIST&gt;\n  at \"anonymous block\", line 7\n</code></pre></p> <p>The negated version of <code>contain</code> ( <code>not_to_contain</code> ) is successful only when all values from expected set are not part of actual (they are disjoint and there is no overlap).</p> <p></p> <p>Example 3. <pre><code>declare\n  l_actual   ut_varchar2_list;\n  l_expected ut_varchar2_list;\nbegin\n  l_actual   := ut_varchar2_list( 'A', 'B', 'C' );\n  l_expected := ut_varchar2_list( 'A', 'B', 'E' );\n  ut.expect( anydata.convertCollection( l_actual ) ).to_contain( anydata.convertCollection( l_expected ) );\n  ut.expect( anydata.convertCollection( l_actual ) ).not_to_contain( anydata.convertCollection( l_expected ) );\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: ut3.ut_varchar2_list [ count = 3 ] was expected to contain: ut3.ut_varchar2_list [ count = 3 ]\n  Diff:\n  Rows: [ 1 differences ]\n  Missing:  &lt;UT_VARCHAR2_LIST&gt;E&lt;/UT_VARCHAR2_LIST&gt;\n  at \"anonymous block\", line 7\nFAILURE\n  Actual: (ut3.ut_varchar2_list [ count = 3 ])\n      Data-types:\n      &lt;UT_VARCHAR2_LIST&gt;VARCHAR2&lt;/UT_VARCHAR2_LIST&gt;\n      Data:\n      &lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;A&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;B&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;C&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;\n   was expected not to contain:(ut3.ut_varchar2_list [ count = 3 ])\n      Data-types:\n      &lt;UT_VARCHAR2_LIST&gt;VARCHAR2&lt;/UT_VARCHAR2_LIST&gt;\n      Data:\n      &lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;A&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;B&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;E&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;\n  at \"anonymous block\", line 8\n</code></pre></p> <p>Example 4.</p> <pre><code>declare\n  l_actual   ut_varchar2_list;\n  l_expected ut_varchar2_list;\nbegin\n  l_actual   := ut_varchar2_list( 'A', 'B', 'C', 'D' );\n  l_expected := ut_varchar2_list( 'A', 'B', 'D' );\n  ut.expect( anydata.convertCollection( l_actual ) ).to_contain( anydata.convertCollection( l_expected ) );\n  ut.expect( anydata.convertCollection( l_actual ) ).not_to_contain( anydata.convertCollection( l_expected ) );\nend;\n/\n</code></pre> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: ut3.ut_varchar2_list [ count = 4 ] was expected to contain: ut3.ut_varchar2_list [ count = 3 ]\nFAILURE\n  Actual: (ut3.ut_varchar2_list [ count = 4 ])\n      Data-types:\n      &lt;UT_VARCHAR2_LIST&gt;VARCHAR2&lt;/UT_VARCHAR2_LIST&gt;\n      Data:\n      &lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;A&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;B&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;C&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;D&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;\n   was expected not to contain:(ut3.ut_varchar2_list [ count = 3 ])\n      Data-types:\n      &lt;UT_VARCHAR2_LIST&gt;VARCHAR2&lt;/UT_VARCHAR2_LIST&gt;\n      Data:\n      &lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;A&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;B&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;D&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;\n  at \"anonymous block\", line 8\n</code></pre></p> <p>Example 5.</p> <pre><code>declare\n  l_actual   ut_varchar2_list;\n  l_expected ut_varchar2_list;\nbegin\n  l_actual   := ut_varchar2_list( 'A', 'B', 'C' );\n  l_expected := ut_varchar2_list( 'D', 'E', 'F' );\n  ut.expect( anydata.convertCollection( l_actual ) ).to_contain( anydata.convertCollection( l_expected ) );\n  ut.expect( anydata.convertCollection( l_actual ) ).not_to_contain( anydata.convertCollection( l_expected ) );\nend;\n/\n</code></pre> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: ut3.ut_varchar2_list [ count = 3 ] was expected to contain: ut3.ut_varchar2_list [ count = 3 ]\n  Diff:\n  Rows: [ 3 differences ]\n  Missing:  &lt;UT_VARCHAR2_LIST&gt;D&lt;/UT_VARCHAR2_LIST&gt;\n  Missing:  &lt;UT_VARCHAR2_LIST&gt;E&lt;/UT_VARCHAR2_LIST&gt;\n  Missing:  &lt;UT_VARCHAR2_LIST&gt;F&lt;/UT_VARCHAR2_LIST&gt;\n  at \"anonymous block\", line 7\nSUCCESS\n  Actual: (ut3.ut_varchar2_list [ count = 3 ])\n      Data-types:\n      &lt;UT_VARCHAR2_LIST&gt;VARCHAR2&lt;/UT_VARCHAR2_LIST&gt;\n      Data:\n      &lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;A&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;B&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;C&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;\n   was expected not to contain:(ut3.ut_varchar2_list [ count = 3 ])\n      Data-types:\n      &lt;UT_VARCHAR2_LIST&gt;VARCHAR2&lt;/UT_VARCHAR2_LIST&gt;\n      Data:\n      &lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;D&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;E&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;&lt;ROW&gt;&lt;UT_VARCHAR2_LIST&gt;F&lt;/UT_VARCHAR2_LIST&gt;&lt;/ROW&gt;\n</code></pre></p>"},{"location":"userguide/expectations.html#to_be_within-of","title":"to_be_within of","text":"<p>Determines whether expected value is within range (tolerance) from another value.</p> <p>The logical formual used for calcuating the matcher is:  <pre><code>    result := ( abs( expected - actual ) &lt;= distance )\n</code></pre> The actual formula used for calculation is more complex to handle different data-types of expected/actual values as well as differnet types of distance value. The matcher will fail if the <code>expected</code> and <code>actual</code> are more than <code>distance</code> apart from each other. The matcher will fail if the dataypes of <code>expected</code> and <code>actual</code> are not the same.</p> <p>The matcher works with data-types: <code>number</code>, <code>date</code>, <code>timestamp</code>, <code>timestamp with time zone</code>, <code>timestamp with local time zone</code> The data-types of compared values must match exactly and if type does not match, the expectation will fail. </p> expected/actualdata-type distance data-type number number date interval day to second date interval year to month timestamp interval day to second timestamp interval year to month timestamp with time zone interval day to second timestamp with time zone interval year to month timestamp with local time zone interval day to second timestamp with local time zone interval year to month <p>The distance must be expressed as a non-negative number or non-negative interval.</p> <p>Note: Interval year-to-moth as a distance is giving sucess if the distance between the given dates/timestamps evaluates to value less or equal of the specified interval Keep in mind that a checking for distance of <code>interval '0-1' year to month</code> will actuall be successful if the distance is less than a month and 15 days. This is due to how oracle evaluates conversion between timestamp difference converted to <code>year to month interval</code>.  The behavior is similar to a call to <code>months_between()</code> function with results rounded to full monts ie. round(months_between(date, date))</p> <p>Example 1. <pre><code>begin\n  ut.expect(3).to_be_within(1).of_(4);\nend;\n/\n</code></pre></p> <p>Example 2. <pre><code>begin\n  ut.expect(3).to_be_within(1).of_(5);\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>Failures:\n\n  1) wihtin_test\n      Actual: 3 (number) was expected to be within 1 of 5 (number)\n      at \"UT3_DEVELOP.UT_BE_WITHIN.OF_\", line 48 l_result.expectation.to_(l_result );        \n      at \"UT3_DEVELOP.TEST_BETWNSTR.WIHTIN_TEST\", line 5\n</code></pre></p> <p>Example 3. <pre><code>begin\n  ut.expect(sysdate).to_be_within(interval '1' day).of_(sysdate+2);\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>Failures:\n\n  1) wihtin_test\n      Actual: 2020-06-07T13:32:58 (date) was expected to be within 1 day of 2020-06-09T13:32:58 (date)\n      at \"UT3_DEVELOP.UT_BE_WITHIN.OF_\", line 55 l_result.expectation.to_(l_result );    \n      at \"UT3_DEVELOP.TEST_BETWNSTR.WIHTIN_TEST\", line 5\n</code></pre></p>"},{"location":"userguide/expectations.html#to_be_within_pct-of","title":"to_be_within_pct of","text":"<p>Determines whether actual value is within percentage range of expected value.  The matcher only works with <code>number</code> data-type.</p> <p>The percentage deviation (distance) must be expressed as a non-negative number. The formula used for calcuation of expectation is: <pre><code>  result := ( ( distance ) * expected &gt;= abs( expected - actual ) * 100 ) \n</code></pre></p> <p>Example 1. <pre><code>begin\n  ut.expect(9).to_be_within_pct(10).of_(10);\nend;\n/\n</code></pre></p> <pre><code>SUCCESS\n  Actual: 9 (number) was expected to be within 10 % of 10 (number)\n</code></pre>"},{"location":"userguide/expectations.html#comparing-cursors-object-types-nested-tables-and-varrays","title":"Comparing cursors, object types, nested tables and varrays","text":"<p>utPLSQL is capable of comparing compound data-types including:</p> <ul> <li>ref cursors </li> <li>object types</li> <li>nested table/varray types</li> </ul>"},{"location":"userguide/expectations.html#notes-on-comparison-of-compound-data","title":"Notes on comparison of compound data","text":"<ul> <li>Compound data can contain elements of any data-type. This includes blob, clob, object type, nested table, varray or even a nested-cursor within a cursor.</li> <li>Attributes in nested table and array types are compared as ordered lists of elements. If order of attributes in nested table and array differ, expectation will fail.</li> <li>Columns in compound data are compared as ordered list of elements by default. Use <code>unordered_columns</code> option when order of columns in cursor is not relevant</li> <li>Comparison of compound data is data-type aware. So a column <code>ID NUMBER</code> in a cursor is not the same as <code>ID VARCHAR2(100)</code>, even if they both hold the same numeric values.</li> <li>Comparison of cursor columns containing <code>DATE</code> will only compare date part and ignore time by default. See Comparing cursor data containing DATE fields to check how to enable date-time comparison in cursors.</li> <li>Comparison of cursor returning <code>TIMESTAMP</code> columns against cursor returning <code>TIMESTAMP</code> bind variables requires variables to be cast to proper precision. This is an Oracle SQL - PLSQL compatibility issue and usage of CAST is the only known workaround for now. See Comparing cursor data containing TIMESTAMP bind variables for examples.    </li> <li>To compare nested table/varray type you need to convert it to <code>anydata</code> by using <code>anydata.convertCollection()</code> </li> <li>To compare object type you need to convert it to <code>anydata</code> by using <code>anydata.convertObject()</code> </li> <li>It is possible to compare PL/SQL records, collections, varrays and associative arrays. To compare this types of data, use cursor comparison feature of utPLSQL and TABLE operator in SQL query<ul> <li>On Oracle 11g Release 2 - pipelined table functions are needed (see section Implicit (Shadow) Types in this artcile)</li> <li>On Oracle 12c and above - use TABLE function on nested tables/varrays/associative arrays of PL/SQL records </li> </ul> </li> <li>utPLSQL is not able to distinguish between NULL and whitespace-only column/attribute value when comparing compound data. This is due to Oracle limitation on of XMLType.   See issue #880 for details. Note: This behavior might be fixed in future releases, when utPLSQL is no longer depending on XMLType for compound data comparison.</li> </ul> <p>utPLSQL offers advanced data-comparison options, for comparing compound data-types. The options allow you to:</p> <ul> <li>define columns/attributes to exclude from comparison</li> <li>define columns/attributes to include in comparison</li> <li>and more ...</li> </ul> <p>For details on available options and how to use them, read the advanced data comparison guide.   </p>"},{"location":"userguide/expectations.html#diff-functionality-for-compound-data-types","title":"Diff functionality for compound data-types","text":"<p>When comparing compound data, utPLSQL will determine the difference between the expected and the actual data. The diff includes:</p> <ul> <li>differences in column names, column positions and column data-type for cursor data</li> <li>only data in columns/rows that differ</li> </ul> <p>The diff aims to make it easier to identify what is not expected in the actual data.</p> <p>Consider the following expected cursor data</p> ID (NUMBER) FIRST_NAME (VARCHAR2) LAST_NAME (VARCHAR2) SALARY (NUMBER) 1 JACK SPARROW 10000 2 LUKE SKYWALKER 1000 3 TONY STARK 1000000 <p>And the actual cursor data: </p> GENDER (VARCHAR2) FIRST_NAME (VARCHAR2) LAST_NAME (VARCHAR2) SALARY (VARCHAR2) ID (NUMBER) M JACK SPARROW 25000 1 M TONY STARK 1000000 3 F JESSICA JONES 2345 4 M LUKE SKYWALKER 1000 2 <p>The two data-sets above have the following differences:</p> <ul> <li>column ID is misplaced (should be first column but is last)</li> <li>column SALARY has data-type VARCHAR2 but should be NUMBER</li> <li>column GENDER exists in actual but not in the expected (it is an Extra column)</li> <li>data in column SALARY for row number 1 in actual is not matching expected </li> <li>row number 2 in actual (ID=3) is not matching expected </li> <li>row number 3 in actual (ID=4) is not matching expected</li> <li>row number 4 in actual (ID=2) is not expected in results (Extra row in actual)  </li> </ul> <p>utPLSQL will report all of the above differences in a readable format to help you identify what is not correct in the compared dataset.</p> <p>Below example illustrates, how utPLSQL will report such differences. <pre><code>declare\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  open l_expected for\n    select 1 as ID, 'JACK' as FIRST_NAME, 'SPARROW' AS LAST_NAME, 10000 AS SALARY\n      from dual union all\n    select 2 as ID, 'LUKE' as FIRST_NAME, 'SKYWALKER' AS LAST_NAME, 1000 AS SALARY\n      from dual union all\n    select 3 as ID, 'TONY' as FIRST_NAME, 'STARK' AS LAST_NAME, 100000 AS SALARY\n      from dual;\n  open l_actual for\n    select 'M' AS GENDER, 'JACK' as FIRST_NAME, 'SPARROW' AS LAST_NAME, 1 as ID, '25000' AS SALARY\n      from dual union all\n    select 'M' AS GENDER, 'TONY' as FIRST_NAME, 'STARK' AS LAST_NAME, 3 as ID, '100000' AS SALARY\n      from dual union all\n    select 'F' AS GENDER, 'JESSICA' as FIRST_NAME, 'JONES' AS LAST_NAME, 4 as ID, '2345' AS SALARY\n      from dual union all\n    select 'M' AS GENDER, 'LUKE' as FIRST_NAME, 'SKYWALKER' AS LAST_NAME, 2 as ID, '1000' AS SALARY\n      from dual;\n  ut.expect(l_actual).to_equal(l_expected);\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: refcursor [ count = 4 ] was expected to equal: refcursor [ count = 3 ]\n  Diff:\n  Columns:\n    Column &lt;ID&gt; is misplaced. Expected position: 1, actual position: 4.\n    Column &lt;SALARY&gt; data-type is invalid. Expected: NUMBER, actual: VARCHAR2.\n    Column &lt;GENDER&gt; [position: 1, data-type: CHAR] is not expected in results.\n  Rows: [ 4 differences ]\n    Row No. 1 - Actual:   &lt;SALARY&gt;25000&lt;/SALARY&gt;\n    Row No. 1 - Expected: &lt;SALARY&gt;10000&lt;/SALARY&gt;\n    Row No. 2 - Actual:   &lt;FIRST_NAME&gt;TONY&lt;/FIRST_NAME&gt;&lt;LAST_NAME&gt;STARK&lt;/LAST_NAME&gt;&lt;ID&gt;3&lt;/ID&gt;&lt;SALARY&gt;100000&lt;/SALARY&gt;\n    Row No. 2 - Expected: &lt;ID&gt;2&lt;/ID&gt;&lt;FIRST_NAME&gt;LUKE&lt;/FIRST_NAME&gt;&lt;LAST_NAME&gt;SKYWALKER&lt;/LAST_NAME&gt;&lt;SALARY&gt;1000&lt;/SALARY&gt;\n    Row No. 3 - Actual:   &lt;FIRST_NAME&gt;JESSICA&lt;/FIRST_NAME&gt;&lt;LAST_NAME&gt;JONES&lt;/LAST_NAME&gt;&lt;ID&gt;4&lt;/ID&gt;&lt;SALARY&gt;2345&lt;/SALARY&gt;\n    Row No. 3 - Expected: &lt;ID&gt;3&lt;/ID&gt;&lt;FIRST_NAME&gt;TONY&lt;/FIRST_NAME&gt;&lt;LAST_NAME&gt;STARK&lt;/LAST_NAME&gt;&lt;SALARY&gt;100000&lt;/SALARY&gt;\n    Row No. 4 - Extra:    &lt;GENDER&gt;M&lt;/GENDER&gt;&lt;FIRST_NAME&gt;LUKE&lt;/FIRST_NAME&gt;&lt;LAST_NAME&gt;SKYWALKER&lt;/LAST_NAME&gt;&lt;ID&gt;2&lt;/ID&gt;&lt;SALARY&gt;1000&lt;/SALARY&gt;\n    Row No. 4 - Extra:    &lt;GENDER&gt;M&lt;/GENDER&gt;&lt;FIRST_NAME&gt;LUKE&lt;/FIRST_NAME&gt;&lt;LAST_NAME&gt;SKYWALKER&lt;/LAST_NAME&gt;&lt;ID&gt;2&lt;/ID&gt;&lt;SALARY&gt;1000&lt;/SALARY&gt;\n  at \"anonymous block\", line 21\n</code></pre></p> <p>utPLSQL identifies and reports on columns:</p> <ul> <li>column misplacement</li> <li>column data-type mismatch</li> <li>extra/missing columns</li> </ul> <p>When comparing rows utPLSQL:</p> <ul> <li>reports only mismatched columns when rows match</li> <li>reports columns existing in both data-sets when whole row is not matching</li> <li>reports whole extra (not expected) row from actual when actual has extra rows </li> <li>reports whole missing (expected) row from expected when expected has extra rows </li> </ul>"},{"location":"userguide/expectations.html#object-and-nested-table-data-type-comparison-examples","title":"Object and nested table data-type comparison examples","text":"<p>When comparing object type / nested table / varray, utPLSQL will check:</p> <ul> <li>if data-types match</li> <li>if data in the compared elements is the same.</li> </ul> <p>The diff functionality for objects / nested tables / varrays is similar to diff on cursors. When diffing, utPLSQL will not check name and data-type of individual attribute as the type itself defines the underlying structure.  </p> <p>Below examples demonstrate how to compare object and nested table data-types. </p> <p>Object type comparison. <pre><code>create type department as object(name varchar2(30))\n/\n\ncreate or replace function get_dept return department is \nbegin\n return department('IT');\nend;\n/\n\nexec ut.expect( anydata.convertObject( get_dept() ) ).to_equal( anydata.convertObject( department('HR') ) );\n\ndrop function get_dept;\ndrop type department;\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: ut3.department was expected to equal: ut3.department\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Actual:   &lt;NAME&gt;IT&lt;/NAME&gt;\n    Row No. 1 - Expected: &lt;NAME&gt;HR&lt;/NAME&gt;\n  at \"anonymous block\", line 1\n</code></pre></p> <p>Table type comparison. <pre><code>create type department as object(name varchar2(30))\n/\ncreate type departments as table of department\n/\ncreate or replace function get_depts return departments is \nbegin\n return departments( department('IT'), department('HR') );\nend;\n/\n\ndeclare\n  v_expected departments;\nbegin\n  v_expected := departments(department('HR'), department('IT') );\n  ut.expect( anydata.convertCollection( get_depts() ) ).to_equal( anydata.convertCollection( v_expected ) );\nend;\n/\n\ndrop type function get_depts;\ndrop type departments;\ndrop type department;\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: ut3.departments [ count = 2 ] was expected to equal: ut3.departments [ count = 2 ]\n  Diff:\n  Rows: [ 2 differences ]\n    Row No. 1 - Actual:   &lt;NAME&gt;IT&lt;/NAME&gt;\n    Row No. 1 - Expected: &lt;NAME&gt;HR&lt;/NAME&gt;\n    Row No. 2 - Actual:   &lt;NAME&gt;HR&lt;/NAME&gt;\n    Row No. 2 - Expected: &lt;NAME&gt;IT&lt;/NAME&gt;\n  at \"anonymous block\", line 5\n</code></pre></p> <p>Some of the possible combinations of anydata and their results: <pre><code>clear screen\nset serverout on\nset feedback off\n\ncreate or replace type t_tab_varchar is table of varchar2(1)\n/\ncreate or replace type dummy_obj as object (\n  id number,\n  \"name\"  varchar2(30),\n  \"Value\" varchar2(30)\n)\n/\ncreate or replace type dummy_obj_lst as table of dummy_obj\n/\ncreate or replace type t_varray is varray(1) of number\n/\n\nexec ut.expect( anydata.convertObject( dummy_obj( 1, 'A', '0' ) ) ).to_equal( anydata.convertObject( dummy_obj(1, 'A', '0') ) ); \nexec ut.expect( anydata.convertCollection( t_tab_varchar('A') ) ).to_equal( anydata.convertCollection( t_tab_varchar('A') ) );\nexec ut.expect( anydata.convertCollection( t_tab_varchar('A') ) ).to_equal( anydata.convertCollection( t_tab_varchar('B') ) );\nexec ut.expect( anydata.convertCollection( t_tab_varchar() ) ).to_be_null();\nexec ut.expect( anydata.convertCollection( t_tab_varchar() ) ).to_equal( anydata.convertCollection( t_tab_varchar() ) );                      \nexec ut.expect( anydata.convertCollection( t_tab_varchar() ) ).to_equal( anydata.convertCollection( t_tab_varchar('A') ) );                    \nexec ut.expect( anydata.convertCollection( t_tab_varchar() ) ).to_have_count(0);\nexec ut.expect( anydata.convertCollection( t_tab_varchar() ) ).to_equal( anydata.convertCollection( t_tab_varchar() ) );                       \nexec ut.expect( anydata.convertCollection( t_tab_varchar() ) ).to_equal( anydata.convertCollection( t_tab_varchar('A') ) );                    \nexec ut.expect( anydata.convertCollection( dummy_obj_lst( dummy_obj( 1, 'A', '0' ) ) ) ).to_equal( anydata.convertCollection( dummy_obj_lst( dummy_obj( 1, 'A', '0' ) ) ) );\nexec ut.expect( anydata.convertCollection( dummy_obj_lst( dummy_obj( 1, 'A', '0' ) ) ) ).to_equal( anydata.convertCollection( dummy_obj_lst( dummy_obj( 2, 'A', '0' ) ) ) ); \nexec ut.expect( anydata.convertCollection( dummy_obj_lst() ) ).to_equal( anydata.convertCollection( dummy_obj_lst( dummy_obj( 1, 'A', '0' ) ) ) ); \nexec ut.expect( anydata.convertCollection( dummy_obj_lst() ) ).to_be_null();                                \nexec ut.expect( anydata.convertCollection( dummy_obj_lst() ) ).to_equal( anydata.convertCollection( dummy_obj_lst() ) );                         \nexec ut.expect( anydata.convertCollection( dummy_obj_lst() ) ).to_have_count(0);                             \nexec ut.expect( anydata.convertCollection( dummy_obj_lst() ) ).to_equal( anydata.convertCollection( dummy_obj_lst(dummy_obj(1, 'A', '0') ) ) ); \nexec ut.expect( anydata.convertCollection( dummy_obj_lst() ) ).to_equal( anydata.convertCollection( dummy_obj_lst() ) );                       \nexec ut.expect( anydata.convertCollection( t_varray() ) ).to_be_null();                                \nexec ut.expect( anydata.convertCollection( t_varray() ) ).to_equal( anydata.convertCollection( t_varray() ) );                              \nexec ut.expect( anydata.convertCollection( t_varray() ) ).to_equal( anydata.convertCollection( t_varray(1) ) );                           \nexec ut.expect( anydata.convertCollection( t_varray() ) ).to_have_count(0);                             \nexec ut.expect( anydata.convertCollection( t_varray() ) ).to_equal( anydata.convertCollection( t_varray() ) );                            \nexec ut.expect( anydata.convertCollection( t_varray() ) ).to_equal( anydata.convertCollection( t_varray(1) ) );                           \nexec ut.expect( anydata.convertCollection( t_varray(1) ) ).to_equal( anydata.convertCollection( t_varray(1) ) );                           \nexec ut.expect( anydata.convertCollection( t_varray(1) ) ).to_equal( anydata.convertCollection( t_varray(2) ) );                           \n\ndrop type t_varray;\ndrop type dummy_obj_lst;\ndrop type dummy_obj;\ndrop type t_tab_varchar;\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: ut3.dummy_obj was expected to equal: ut3.dummy_obj\n\nSUCCESS\n  Actual: ut3.t_tab_varchar [ count = 1 ] was expected to equal: ut3.t_tab_varchar [ count = 1 ]\n\nFAILURE\n  Actual: ut3.t_tab_varchar [ count = 1 ] was expected to equal: ut3.t_tab_varchar [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Actual:   &lt;T_TAB_VARCHAR&gt;A&lt;/T_TAB_VARCHAR&gt;\n    Row No. 1 - Expected: &lt;T_TAB_VARCHAR&gt;B&lt;/T_TAB_VARCHAR&gt;\n  at \"anonymous block\", line 1\n\nFAILURE\n  Actual: (ut3.t_tab_varchar [ count = 0 ])\n      Data-types:\n      &lt;T_TAB_VARCHAR&gt;VARCHAR2&lt;/T_TAB_VARCHAR&gt;\n      Data:\n   was expected to be null\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: ut3.t_tab_varchar [ count = 0 ] was expected to equal: ut3.t_tab_varchar [ count = 0 ]\n\nFAILURE\n  Actual: ut3.t_tab_varchar [ count = 0 ] was expected to equal: ut3.t_tab_varchar [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Missing:  &lt;T_TAB_VARCHAR&gt;A&lt;/T_TAB_VARCHAR&gt;\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: (ut3.t_tab_varchar [ count = 0 ]) was expected to have [ count = 0 ]\n\nSUCCESS\n  Actual: ut3.t_tab_varchar [ count = 0 ] was expected to equal: ut3.t_tab_varchar [ count = 0 ]\n\nFAILURE\n  Actual: ut3.t_tab_varchar [ count = 0 ] was expected to equal: ut3.t_tab_varchar [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Missing:  &lt;T_TAB_VARCHAR&gt;A&lt;/T_TAB_VARCHAR&gt;\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: ut3.dummy_obj_lst [ count = 1 ] was expected to equal: ut3.dummy_obj_lst [ count = 1 ]\n\nFAILURE\n  Actual: ut3.dummy_obj_lst [ count = 1 ] was expected to equal: ut3.dummy_obj_lst [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Actual:   &lt;ID&gt;1&lt;/ID&gt;\n    Row No. 1 - Expected: &lt;ID&gt;2&lt;/ID&gt;\n  at \"anonymous block\", line 1\n\nFAILURE\n  Actual: ut3.dummy_obj_lst [ count = 0 ] was expected to equal: ut3.dummy_obj_lst [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Missing:  &lt;DUMMY_OBJ&gt;&lt;ID&gt;1&lt;/ID&gt;&lt;name&gt;A&lt;/name&gt;&lt;Value&gt;0&lt;/Value&gt;&lt;/DUMMY_OBJ&gt;\n  at \"anonymous block\", line 1\n\nFAILURE\n  Actual: (ut3.dummy_obj_lst [ count = 0 ])\n      Data-types:\n      &lt;DUMMY_OBJ&gt;DUMMY_OBJ&lt;/DUMMY_OBJ&gt;\n      Data:\n   was expected to be null\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: ut3.dummy_obj_lst [ count = 0 ] was expected to equal: ut3.dummy_obj_lst [ count = 0 ]\n\nSUCCESS\n  Actual: (ut3.dummy_obj_lst [ count = 0 ]) was expected to have [ count = 0 ]\n\nFAILURE\n  Actual: ut3.dummy_obj_lst [ count = 0 ] was expected to equal: ut3.dummy_obj_lst [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Missing:  &lt;DUMMY_OBJ&gt;&lt;ID&gt;1&lt;/ID&gt;&lt;name&gt;A&lt;/name&gt;&lt;Value&gt;0&lt;/Value&gt;&lt;/DUMMY_OBJ&gt;\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: ut3.dummy_obj_lst [ count = 0 ] was expected to equal: ut3.dummy_obj_lst [ count = 0 ]\n\nFAILURE\n  Actual: (ut3.t_varray [ count = 0 ])\n      Data-types:\n      &lt;T_VARRAY&gt;NUMBER&lt;/T_VARRAY&gt;\n      Data:\n   was expected to be null\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: ut3.t_varray [ count = 0 ] was expected to equal: ut3.t_varray [ count = 0 ]\n\nFAILURE\n  Actual: ut3.t_varray [ count = 0 ] was expected to equal: ut3.t_varray [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Missing:  &lt;T_VARRAY&gt;1&lt;/T_VARRAY&gt;\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: (ut3.t_varray [ count = 0 ]) was expected to have [ count = 0 ]\n\nSUCCESS\n  Actual: ut3.t_varray [ count = 0 ] was expected to equal: ut3.t_varray [ count = 0 ]\n\nFAILURE\n  Actual: ut3.t_varray [ count = 0 ] was expected to equal: ut3.t_varray [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Missing:  &lt;T_VARRAY&gt;1&lt;/T_VARRAY&gt;\n  at \"anonymous block\", line 1\n\nSUCCESS\n  Actual: ut3.t_varray [ count = 1 ] was expected to equal: ut3.t_varray [ count = 1 ]\n\nFAILURE\n  Actual: ut3.t_varray [ count = 1 ] was expected to equal: ut3.t_varray [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Actual:   &lt;T_VARRAY&gt;1&lt;/T_VARRAY&gt;\n    Row No. 1 - Expected: &lt;T_VARRAY&gt;2&lt;/T_VARRAY&gt;\n  at \"anonymous block\", line 1\n</code></pre></p>"},{"location":"userguide/expectations.html#comparing-cursor-data-containing-date-fields","title":"Comparing cursor data containing DATE fields","text":"<p>Important</p> <p>utPLSQL uses XMLType internally to represent rows of the cursor data. This is by far the most flexible method and allows comparison of cursors containing LONG, CLOB, BLOB, user defined types and even nested cursors. Due to the way Oracle handles DATE data type when converting from cursor data to XML, utPLSQL has no control over the DATE formatting. The NLS_DATE_FORMAT setting from the moment the cursor was opened determines the formatting of dates used for cursor data comparison. By default, Oracle NLS_DATE_FORMAT is timeless, so data of DATE datatype, will be compared ignoring the time component.</p> <p>You should surround cursors and expectations with procedures <code>ut.set_nls</code>, <code>ut.reset_nls</code>. This way, the DATE data in cursors will be properly formatted for comparison using date-time format.</p> <p>The example below makes use of <code>ut.set_nls</code>, <code>ut.reset_nls</code>, so that the date in <code>l_expected</code> and <code>l_actual</code> is compared using date-time formatting. <pre><code>clear screen\nalter session set nls_date_format='yyyy-mm-dd';\nset serverout on\nset feedback off\ncreate table events ( description varchar2(4000), event_date  date )\n/\ndeclare\n  c_description constant varchar2(30) := 'Test event';\n  c_event_date  constant date := to_date('2016-09-08 06:51:22','yyyy-mm-dd hh24:mi:ss');\n  c_second      constant number := 1/24/60/60;\n  l_actual   sys_refcursor;\n  l_expected sys_refcursor;\nbegin\n  --Arrange\n  insert into events (description, event_date) values (c_description, c_event_date);\n\n  begin\n    -- Change the NLS settings for date to be ISO date-time 'YYYY-MM-DD HH24:MI:SS'\n    ut.set_nls(); \n    --Act\n    open l_expected for select c_description as description, c_event_date + c_second as event_date from dual;\n    open l_actual   for select description, event_date from events;\n    --Assert\n    ut.expect( l_actual ).not_to_equal( l_expected );\n    -- Reset the NLS settings to their default values after cursor data was processed\n    ut.reset_nls(); \n  end;\n\n  begin\n    --Act\n    open l_expected for select c_description as description, c_event_date + c_second as event_date from dual;\n    open l_actual   for select description, event_date from events;\n    --Assert\n    ut.expect( l_actual ).not_to_equal( l_expected );\n  end;\n  --Cleanup\n  rollback;\nend;\n/\n\ndrop table events;\n</code></pre></p> <p>In the above example:</p> <ul> <li>The first expectation is successful, as the <code>l_expected</code> cursor contains different date-time then the cursor returned by <code>get_events</code> function call</li> <li>The second expectation fails, as the column <code>event_date</code> will get compared as DATE without TIME (using default current session NLS date format)</li> </ul> <p>Output via DBMS_OUTPUT from the above example: <pre><code>SUCCESS\n  Actual: (refcursor [ count = 1 ])\n      Data-types:\n      &lt;DESCRIPTION&gt;VARCHAR2&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;DATE&lt;/EVENT_DATE&gt;\n      Data:\n      &lt;ROW&gt;&lt;DESCRIPTION&gt;Test event&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;2016-09-08T06:51:22&lt;/EVENT_DATE&gt;&lt;/ROW&gt;\n   was expected not to equal: (refcursor [ count = 1 ])\n      Data-types:\n      &lt;DESCRIPTION&gt;VARCHAR2&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;DATE&lt;/EVENT_DATE&gt;\n      Data:\n      &lt;ROW&gt;&lt;DESCRIPTION&gt;Test event&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;2016-09-08T06:51:23&lt;/EVENT_DATE&gt;&lt;/ROW&gt;\nFAILURE\n  Actual: (refcursor [ count = 1 ])\n      Data-types:\n      &lt;DESCRIPTION&gt;VARCHAR2&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;DATE&lt;/EVENT_DATE&gt;\n      Data:\n      &lt;ROW&gt;&lt;DESCRIPTION&gt;Test event&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;2016-09-08&lt;/EVENT_DATE&gt;&lt;/ROW&gt;\n   was expected not to equal: (refcursor [ count = 1 ])\n      Data-types:\n      &lt;DESCRIPTION&gt;VARCHAR2&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;DATE&lt;/EVENT_DATE&gt;\n      Data:\n      &lt;ROW&gt;&lt;DESCRIPTION&gt;Test event&lt;/DESCRIPTION&gt;&lt;EVENT_DATE&gt;2016-09-08&lt;/EVENT_DATE&gt;&lt;/ROW&gt;\n  at \"anonymous block\", line 28\n</code></pre></p>"},{"location":"userguide/expectations.html#comparing-cursor-data-containing-timestamp-bind-variables","title":"Comparing cursor data containing TIMESTAMP bind variables","text":"<p>To properly compare <code>timestamp</code> column data returned by cursor against bind variable data from another cursor, a conversion needs to be done.</p> <p>This applies to <code>timestamp</code>,<code>timestamp with timezone</code>, <code>timestamp with local timezone</code> data types.</p> <p>Example below illustrates usage of <code>cast</code> operator to assure appropriate precision is applied on timestamp bind-variables in cursor result-set   </p> <pre><code>clear screen\nset serverout on\nset feedback off\n\ncreate table timestamps (\n  ts3 timestamp (3),\n  ts6 timestamp (6),\n  ts9 timestamp (9)\n);\n\ndeclare\n  l_time     timestamp(9);\n  l_expected sys_refcursor;\n  l_actual   sys_refcursor;\nbegin\n  --Arrange\n  l_time := systimestamp;\n\n  insert into timestamps (ts3, ts6, ts9) values (l_time, l_time, l_time);\n\n  begin\n    --Act\n    open l_expected for\n      select\n        cast(l_time as timestamp(3)) as ts3, \n        cast(l_time as timestamp(6)) as ts6,  \n        cast(l_time as timestamp(9)) as ts9\n        from dual;\n\n    open l_actual for select ts3, ts6, ts9 from timestamps;\n\n    --Assert\n    ut.expect (l_actual).to_equal (l_expected);\n  end;\n  begin\n    open l_expected for\n      select l_time as ts3, l_time as ts6, l_time as ts9 from dual;  \n\n    open l_actual for select ts3, ts6, ts9 from timestamps;\n\n    --Assert\n    ut.expect (l_actual).to_equal (l_expected);\n  end;\nend;\n/\n\ndrop table timestamps;\n</code></pre> <p>Returns following output via DBMS_OUTPUT: <pre><code>SUCCESS\n  Actual: refcursor [ count = 1 ] was expected to equal: refcursor [ count = 1 ]\nFAILURE\n  Actual: refcursor [ count = 1 ] was expected to equal: refcursor [ count = 1 ]\n  Diff:\n  Rows: [ 1 differences ]\n    Row No. 1 - Actual:   &lt;TS3&gt;2019-07-08T22:08:41.899&lt;/TS3&gt;&lt;TS6&gt;2019-07-08T22:08:41.899319&lt;/TS6&gt;\n    Row No. 1 - Expected: &lt;TS3&gt;2019-07-08T22:08:41.899319000&lt;/TS3&gt;&lt;TS6&gt;2019-07-08T22:08:41.899319000&lt;/TS6&gt;\n  at \"anonymous block\", line 32\n</code></pre></p>"},{"location":"userguide/expectations.html#comparing-json-objects","title":"Comparing Json objects","text":"<p>utPLSQL is capable of comparing json data-types of <code>json_element_t</code> on Oracle 12.2 and above, and also <code>json</code> on Oracle 21 and above</p> <p>Note</p> <p>Whenever a database is upgraded to compatible version the utPLSQL needs to be reinstalled to pick up json changes. E.g. upgrade from 18c to 21c to enable <code>json</code> type compare. </p>"},{"location":"userguide/expectations.html#notes-on-comparison-of-json-data","title":"Notes on comparison of json data","text":"<ul> <li>Json data can contain objects, scalar or arrays.</li> <li>During comparison of json objects the order doesn't matter.</li> <li>During comparison of json arrays the index of element is taken into account</li> <li>To compare json you have to make sure its type of  <code>json_element_t</code> or its subtypes</li> <li>From version 21 and above a native <code>json</code> type is supported.</li> </ul> <p>Compare JSON example using <code>json_element_t</code>: <pre><code>declare\n  l_expected json_element_t;\n  l_actual   json_element_t;\nbegin\n  l_expected := json_element_t.parse('\n    {\n      \"Actors\": [\n        {\n          \"name\": \"Tom Cruise\",\n          \"age\": 56,\n          \"Birthdate\": \"July 3, 1962\",\n          \"hasChildren\": true,\n          \"children\": [\n            \"Connor\"\n          ]\n        },\n        {\n          \"name\": \"Robert Downey Jr.\",\n          \"age\": 53,\n          \"Birthdate\": \"April 4, 1965\",\n          \"hasChildren\": true,\n          \"children\": [\n            \"Exton Elias\"\n          ]\n        }\n      ]\n    }'\n  );\n\n  l_actual   := json_element_t.parse('\n    {\n      \"Actors\": [\n        {\n          \"name\": \"Tom Cruise\",\n          \"age\": 56,\n          \"Birthdate\": \"1962.07.03\",\n          \"hasChildren\": true,\n          \"children\": [\n            \"Suri\",\n            \"Isabella Jane\",\n            \"Connor\"\n          ]\n        },\n        {\n          \"name\": \"Jr., Robert Downey\",\n          \"age\": 53,\n          \"Birthdate\": \"April 4, 1965\",\n          \"hasChildren\": true,\n          \"children\": [\n            \"Indio Falconer\",\n            \"Avri Roel\",\n            \"Exton Elias\"\n          ]\n        }\n      ]\n    }'\n  );\n\n  ut.expect( l_actual ).to_equal( l_expected );\n\nend;\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: json was expected to equal: json\n  Diff: 8 differences found\n  4 unequal values, 4 missing properties\n    Extra   property: \"Avri Roel\" on path: $.\"Actors\"[1].\"children\"[1]\n    Extra   property: \"Isabella Jane\" on path: $.\"Actors\"[0].\"children\"[1]\n    Extra   property: \"Connor\" on path: $.\"Actors\"[0].\"children\"[2]\n    Extra   property: \"Exton Elias\" on path: $.\"Actors\"[1].\"children\"[2]\n    Actual value: \"Robert Downey Jr.\" was expected to be: \"Jr., Robert Downey\" on path: $.\"Actors\"[1].\"name\"\n    Actual value: \"July 3, 1962\" was expected to be: \"1962.07.03\" on path: $.\"Actors\"[0].\"Birthdate\"\n    Actual value: \"Connor\" was expected to be: \"Suri\" on path: $.\"Actors\"[0].\"children\"[0]\n    Actual value: \"Exton Elias\" was expected to be: \"Indio Falconer\" on path: $.\"Actors\"[1].\"children\"[0]\n  at \"anonymous block\", line 59\n</code></pre></p> <p>Comparing parts of JSON example using <code>json_element_t</code> subtypes: <pre><code>declare\n  l_actual         json_object_t;\n  l_actual_extract json_array_t;\n  l_expected       json_array_t;\nbegin\n  -- Arrange\n  l_expected := json_array_t.parse('\n    [\n      \"Indio Falconer\",\n      \"Avri Roel\",\n      \"Exton Elias\"\n    ]'\n  );\n\n  l_actual := json_object_t.parse('\n    {\n      \"Actors\": [\n         {\n            \"name\": \"Tom Cruise\",\n          \"age\": 56,\n           \"Born At\": \"Syracuse, NY\",\n          \"Birthdate\": \"July 3, 1962\",\n          \"photo\": \"https://jsonformatter.org/img/tom-cruise.jpg\",\n          \"wife\": null,\n          \"weight\": 67.5,\n          \"hasChildren\": true,\n          \"hasGreyHair\": false,\n          \"children\": [\n            \"Suri\",\n            \"Isabella Jane\",\n            \"Connor\"\n          ]\n        },\n        {\n            \"name\": \"Robert Downey Jr.\",\n          \"age\": 53,\n          \"Born At\": \"New York City, NY\",\n          \"Birthdate\": \"April 4, 1965\",\n          \"photo\": \"https://jsonformatter.org/img/Robert-Downey-Jr.jpg\",\n          \"wife\": \"Susan Downey\",\n           \"weight\": 77.1,\n          \"hasChildren\": true,\n          \"hasGreyHair\": false,\n          \"children\": [\n            \"Indio Falconer\",\n            \"Exton Elias\"\n          ]\n        }\n      ]\n    }'\n  );\n\n  l_actual_extract   := json_array_t(json_query(l_actual.stringify,'$.Actors[1].children'));\n  --Act\n  ut.expect(l_actual_extract).to_equal(l_expected);\n\nend;\n/\n</code></pre></p> <p>Returns following output via DBMS_OUTPUT: <pre><code>FAILURE\n  Actual: json was expected to equal: json\n  Diff: 2 differences found\n  1 unequal values, 1 missing properties\n    Missing property: \"Exton Elias\" on path: $[2]\n    Actual value: \"Avri Roel\" was expected to be: \"Exton Elias\" on path: $[1]\n  at \"anonymous block\", line 55\n</code></pre></p>"},{"location":"userguide/getting-started.html","title":"Getting Started","text":""},{"location":"userguide/getting-started.html#getting-started-with-tdd-and-utplsql","title":"Getting started with TDD and utPLSQL","text":"<p>utPLSQL is designed in a way that allows you to follow  Test Driven Development (TDD) software development process.</p> <p>Below is an example of building a simple function with TDD.</p>"},{"location":"userguide/getting-started.html#gather-requirements","title":"Gather requirements","text":"<p>We have a requirement to build a function that will return a substring of a string that is passed to the function.</p> <p>The function should accept three parameters:</p> <ul> <li>input_string</li> <li>start_position</li> <li>end_position</li> </ul>"},{"location":"userguide/getting-started.html#create-a-test","title":"Create a test","text":"<p>We will start from the bare minimum and move step by step, executing tests every time we make minimal progress. This way, we assure we don't jump ahead too much and produce code that is untested or untestable.</p>"},{"location":"userguide/getting-started.html#create-test-package","title":"Create test package","text":"<pre><code>create or replace package test_betwnstr as\n\n  --%suite(Between string function)\n\nend;\n/\n</code></pre> <p>Execute all tests: <code>begin ut.run(); end;</code></p> <p>Test results: <pre><code>Between string function\n\nFinished in .451423 seconds\n0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p>"},{"location":"userguide/getting-started.html#define-specification-for-the-test","title":"Define specification for the test","text":"<pre><code>create or replace package test_betwnstr as\n\n  --%suite(Between string function)\n\n  --%test(Returns substring from start position to end position)\n  procedure basic_usage;\n\nend;\n/\n</code></pre> <p>Execute test package: <code>begin ut.run('test_betwnstr'); end;</code></p> <p>Test results: <pre><code>Between string function\n  Returns substring from start position to end position (FAILED - 1)\n\nFailures:\n\n  1) basic_usage\n      ORA-04067: not executed, package body \"UT3_USER.TEST_BETWNSTR\" does not exist\n      ORA-06508: PL/SQL: could not find program unit being called: \"UT3_USER.TEST_BETWNSTR\"\n      ORA-06512: at line 6\nFinished in .509673 seconds\n1 tests, 0 failed, 1 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Well our test is failing as the package specification requires a body.</p>"},{"location":"userguide/getting-started.html#define-body-of-first-test","title":"Define body of first test","text":"<pre><code>create or replace package body test_betwnstr as\n\n  procedure basic_usage is\n  begin\n    ut.expect( betwnstr( '1234567', 2, 5 ) ).to_equal('2345');\n  end;\n\nend;\n/\n</code></pre> <p>Execute test package: <code>begin ut.run('test_betwnstr'); end;</code></p> <p>Test results: <pre><code>Between string function\n  Returns substring from start position to end position (FAILED - 1)\n\nFailures:\n\n  1) basic_usage\n      ORA-04063: package body \"UT3_USER.TEST_BETWNSTR\" has errors\n      ORA-06508: PL/SQL: could not find program unit being called: \"UT3_USER.TEST_BETWNSTR\"\n      ORA-06512: at line 6\nFinished in .415851 seconds\n1 tests, 0 failed, 1 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Our test is failing as the test suite package body is invalid. Looks like we need to define the function we want to test.</p>"},{"location":"userguide/getting-started.html#implement-code-to-fulfill-the-requirement","title":"Implement code to fulfill the requirement","text":""},{"location":"userguide/getting-started.html#define-tested-function","title":"Define tested function","text":"<pre><code>create or replace function betwnstr( a_string varchar2, a_start_pos integer, a_end_pos integer ) return varchar2\nis\nbegin\n  return substr( a_string, a_start_pos, a_end_pos - a_start_pos );\nend;\n/\n</code></pre> <p>Execute test package: <code>begin ut.run('test_betwnstr'); end;</code></p> <p>Test results: <pre><code>Between string function\n  Returns substring from start position to end position (FAILED - 1)\n\nFailures:\n\n  1) basic_usage\n      Actual: '234' (varchar2) was expected to equal: '2345' (varchar2) \n      at \"\"UT3_USER.TEST_BETWNSTR\"\", line 5 \n\nFinished in .375178 seconds\n1 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>So now we see that our test works but the function does not return the expected results. Let us fix this and continue from here.</p>"},{"location":"userguide/getting-started.html#fix-the-tested-function","title":"Fix the tested function","text":"<p>The function returned a string one character short, so we need to add 1 to the substr parameter.</p> <pre><code>create or replace function betwnstr( a_string varchar2, a_start_pos integer, a_end_pos integer ) return varchar2 \nis\nbegin\n  return substr( a_string, a_start_pos, a_end_pos - a_start_pos + 1 );\nend;\n/\n</code></pre> <p>Execute test package: <code>begin ut.run('test_betwnstr'); end;</code></p> <p>Test results: <pre><code>Between string function\n  Returns substring from start position to end position\n\nFinished in .006077 seconds\n1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>So our test is now passing, great!</p>"},{"location":"userguide/getting-started.html#refactor","title":"Refactor","text":"<p>Once our tests are passing, we can safely refactor (restructure) the code as we have a safety harness  in place to ensure that after the restructuring and cleanup of the code, everything is still working.</p> <p>One thing worth mentioning is that refactoring of tests is as important as refactoring of code. Maintainability of both is equally important.</p>"},{"location":"userguide/getting-started.html#further-requirements","title":"Further requirements","text":"<p>It seems like our work is done. We have a function that returns a substring from start position to end position. As we move through the process of adding tests, it's very important to think about edge cases.</p> <p>Here is a list of edge cases for our function:</p> <ul> <li>start position zero</li> <li>input string is null</li> <li>start position is null</li> <li>end position is null</li> <li>start position is negative</li> <li>start position is bigger than end position</li> <li>start position is negative</li> <li>end position is negative</li> </ul> <p>We should define expected behavior for each of these edge cases. Once defined we can start implementing tests for those behaviors and adjust the tested function to meet the requirements specified in the tests.</p>"},{"location":"userguide/getting-started.html#add-test-for-additional-requirement","title":"Add test for additional requirement","text":"<p>A new requirement was added:    Start position zero - should be treated as start position one</p> <pre><code>create or replace package test_betwnstr as\n\n  --%suite(Between string function)\n\n  --%test(Returns substring from start position to end position)\n  procedure basic_usage;\n\n  --%test(Returns substring when start position is zero)\n  procedure zero_start_position;\n\nend;\n/\n\ncreate or replace package body test_betwnstr as\n\n  procedure basic_usage is\n  begin\n    ut.expect( betwnstr( '1234567', 2, 5 ) ).to_equal('2345');\n  end;\n\n  procedure zero_start_position is\n  begin\n    ut.expect( betwnstr( '1234567', 0, 5 ) ).to_equal('12345');\n  end;\n\nend;\n/\n</code></pre> <p>Execute test package: <code>begin ut.run('test_betwnstr'); end;</code></p> <p>Test results: <pre><code>Between string function\n  Returns substring from start position to end position\n  Returns substring when start position is zero (FAILED - 1)\n\nFailures:\n\n  1) zero_start_position\n      Actual: '123456' (varchar2) was expected to equal: '12345' (varchar2) \n      at \"\"UT3_USER.TEST_BETWNSTR\"\", line 10 \n\nFinished in .232584 seconds\n2 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Looks like our function does not work as expected for zero start position.</p>"},{"location":"userguide/getting-started.html#implementing-the-requirement","title":"Implementing the requirement","text":"<p>Let's fix our function so that the new requirement is met</p> <pre><code>create or replace function betwnstr( a_string varchar2, a_start_pos integer, a_end_pos integer ) return varchar2 \nis\nbegin\n  if a_start_pos = 0 then\n    return substr( a_string, a_start_pos, a_end_pos - a_start_pos );\n  else\n    return substr( a_string, a_start_pos, a_end_pos - a_start_pos + 1);\n  end if;\nend;\n/\n</code></pre> <p>Execute test package: <code>begin ut.run('test_betwnstr'); end;</code></p> <p>Test results: <pre><code>Between string function\n  Returns substring from start position to end position\n  Returns substring when start position is zero\n\nFinished in .012718 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre></p> <p>Great! We have made some visible progress.</p>"},{"location":"userguide/getting-started.html#refactoring","title":"Refactoring","text":"<p>When all tests are passing we can proceed with a safe cleanup of our code.</p> <p>The function works well, but we use the <code>return</code> twice, which is not the best coding practice.</p> <p>An alternative implementation could be cleaner. <pre><code>create or replace function betwnstr( a_string varchar2, a_start_pos integer, a_end_pos integer ) return varchar2\nis\nbegin\n  return substr( a_string, a_start_pos, a_end_pos - greatest( a_start_pos, 1 ) + 1 );\nend;\n/\n</code></pre></p> <p>As we refactor we should probably run our tests as often as we compile code, so we know not only that the code compiles, but also works as expected.</p> <pre><code>Between string function\n  Returns substring from start position to end position\n  Returns substring when start position is zero\n\nFinished in .013739 seconds\n2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)\n</code></pre>"},{"location":"userguide/getting-started.html#remaining-requirements","title":"Remaining requirements","text":"<p>You may continue on with the remaining edge cases from here.</p> <ul> <li>identify requirement</li> <li>define requirement with test</li> <li>run test to check if requirement is met</li> <li>implement code to meet requirement</li> <li>run test to check if requirement is met</li> <li>refactor/cleanup code and tests</li> </ul> <p>Hope you will enjoy it as much as we do.</p>"},{"location":"userguide/install.html","title":"Installation","text":""},{"location":"userguide/install.html#supported-database-versions","title":"Supported database versions","text":"<p>utPLSQL is continuously tested against following versions of Oracle databases</p> <ul> <li>11g R2 </li> <li>12c</li> <li>12c R2</li> <li>18c</li> <li>19c</li> </ul> <p>We do our best to assure full compatibility with supported versions of Oracle databases See</p>"},{"location":"userguide/install.html#requirements","title":"Requirements","text":"<p>utPLSQL will run on any Oracle Database version 11g relase 2 or above.</p>"},{"location":"userguide/install.html#licensed-features-required","title":"Licensed features required","text":"<p>utPLSQL doesn't require any extra licensed features of Oracle database. It can be installed on any Standard Edition Oracle Database.</p> <p>In fact, it even supports Oracle 11g XE which is a free Oracle Database version with minimal features and storage limits.</p>"},{"location":"userguide/install.html#storage-requirements","title":"Storage requirements","text":"<p>utPLSQL will use tablespace for the following: - storage of annotation cache - storage of suite cache - storage of profiler results - storage for staging utPLSQL reports outputs</p> <p>utPLSQL purges the staging storage for reports while fetching reports to screen / saving reports to files.</p> <p>Suite and annotation cache storage requirements are minimal and unless you have hundreds of thousands of tests, you'll probably not even notice the space used. </p> <p>Profiler results may require regular purging to assure low space consumption. utPLSQl does not purge profiler tables as those tables can can be shared with other tools.</p>"},{"location":"userguide/install.html#downloading-utplsql","title":"Downloading utPLSQL","text":""},{"location":"userguide/install.html#manual-download","title":"Manual download","text":"<ul> <li>Go to GitHub releases page for utPLSQL <code>https://github.com/utPLSQL/utPLSQL/releases</code></li> <li>Choose the version to download - latest is always greatest</li> <li>Download one of files<ul> <li>utPLSQL.tar.gz</li> <li>utPLSQL.zip</li> </ul> </li> </ul> <p>The files have identical content but use different compression (tar / zip ) so choose whichever you prefer depending on your platform (Win/Mac/Unix/Linux). </p>"},{"location":"userguide/install.html#scripted-download-of-latest-utplsql-version","title":"Scripted download of latest utPLSQL version","text":"<p>The below snippets can be used to download latest version of utPLSQL from github releases.</p> <p>After downloading follow the installation instructions in next sections of this document.</p>"},{"location":"userguide/install.html#unixlinux","title":"Unix/Linux","text":"<pre><code>#!/bin/bash\n# Get the url to latest release \"zip\" file\nUTPLSQL_DOWNLOAD_URL=$(curl --silent https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest | awk '/browser_download_url/ { print $2 }' | grep \".zip\\\"\" | sed 's/\"//g')\n# Download the latest release \"zip\" file\ncurl -Lk \"${UTPLSQL_DOWNLOAD_URL}\" -o utPLSQL.zip\n# Extract downloaded \"zip\" file\nunzip -q utPLSQL.zip\n</code></pre> <p>You may download with a one-liner if that is more convenient. <pre><code>#!/bin/bash\ncurl -LOk $(curl --silent https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest | awk '/browser_download_url/ { print $2 }' | grep \".zip\\\"\" | sed 's/\"//g') \n</code></pre></p>"},{"location":"userguide/install.html#windows","title":"Windows","text":"<p>To run the script on windows you will need PowerShell 3.0 or above.  You will also need .NET 4.0 Framework or above.</p> <pre><code>$archiveName = 'utPLSQL.zip'\n$latestRepo = Invoke-WebRequest https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest\n$repo = $latestRepo.Content | Convertfrom-Json\n\n$urlList = $repo.assets.browser_download_url\n\nAdd-Type -assembly \"system.io.compression.filesystem\"\n\nforeach ($i in $urlList) {\n\n   $fileName = $i.substring($i.LastIndexOf(\"/\") + 1)\n\n   if ( $fileName.substring($fileName.LastIndexOf(\".\") + 1) -eq 'zip' ) {\n      Invoke-WebRequest $i -OutFile $archiveName\n      $fileLocation = Get-ChildItem | where {$_.Name -eq $archiveName}\n\n      if ($fileLocation) {\n         [io.compression.zipfile]::ExtractToDirectory($($fileLocation.FullName),$($fileLocation.DirectoryName))   \n      }\n   }\n}\n</code></pre>"},{"location":"userguide/install.html#headless-installation","title":"Headless installation","text":"<p>utPLSQL can be installed with DDL trigger, to enable tracking of DDL changes to your unit test packages. This is the recommended installation approach, when you want to compile and run unit test packages in a schema containing huge amount of database packages (for example Oracle EBS installation schema). The reason for having DDL trigger is to enable in-time annotation parsing for utPLSQL. Without DDL trigger, utPLSQL needs to investigate your schema objects last_ddl_timestamp each time tests are executed to check if any of DB packages were changed in given schema and if they need scanning for annotation changes. This process can be time-consuming if DB schema is large.     </p> <p>The headless scripts accept three optional parameters that define: - username to create as owner of utPLSQL (default <code>ut3</code>) - password for owner of utPLSQL (default <code>XNtxj8eEgA6X6b6f</code>) - tablespace to use for storage of profiler and utPLSQL cache data (default <code>users</code>)  </p> <p>The scripts need to be executed by <code>SYSDBA</code>, in order to grant access to <code>DBMS_LOCK</code> and <code>DBMS_CRYPTO</code> system packages.</p> <p>Important</p> <ul> <li><code>DBMS_LOCK</code> is required for session synchronization between main session and session consuming realtime reports.</li> <li>The user performing the installation must have the <code>ADMINISTER DATABASE TRIGGER</code> privilege. This is required for installation of trigger that is responsible for parsing annotations at at compile-time of a package.</li> <li>When installed with DDL trigger, utPLSQL will not be registering unit tests for any of oracle-maintained schemas.<ul> <li>For Oracle 11g following users are excluded:     ANONYMOUS, APPQOSSYS, AUDSYS, DBSFWUSER, DBSNMP, DIP, GGSYS, GSMADMIN_INTERNAL, GSMCATUSER, GSMUSER, ORACLE_OCM, OUTLN, REMOTE_SCHEDULER_AGENT, SYS, SYS$UMF, SYSBACKUP, SYSDG, SYSKM, SYSRAC, SYSTEM, WMSYS, XDB, XS$NULL </li> <li>For Oracle 12c and above the users returned by below query are excluded by utPLSQL: <code>select username from all_users where oracle_maintained='Y';</code> </li> </ul> </li> </ul>"},{"location":"userguide/install.html#installation-without-ddl-trigger","title":"Installation without DDL trigger","text":"<p>To install the utPLSQL into a new database schema and grant it to public, execute the script <code>install_headless.sql</code> as SYSDBA.</p> <p>Example invocation of the script from command line: <pre><code>cd source\nsqlplus sys/sys_pass@db as sysdba @install_headless.sql  \n</code></pre></p> <p>Invoking script with parameters: <pre><code>cd source\nsqlplus sys/sys_pass@db as sysdba @install_headless.sql utp3 my_verySecret_password utp3_tablespace   \n</code></pre></p>"},{"location":"userguide/install.html#installation-with-ddl-trigger","title":"Installation with DDL trigger","text":"<p>To install the utPLSQL into a new database schema and grant it to public, execute the script <code>install_headless_with_trigger.sql</code> as SYSDBA.</p> <p>Example invocation of the script from command line: <pre><code>cd source\nsqlplus sys/sys_pass@db as sysdba @install_headless_with_trigger.sql  \n</code></pre></p> <p>Invoking script with parameters: <pre><code>cd source\nsqlplus sys/sys_pass@db as sysdba @install_headless_with_trigger.sql utp3 my_verySecret_password utp3_tablespace   \n</code></pre></p>"},{"location":"userguide/install.html#recommended-schema","title":"Recommended Schema","text":"<p>It is highly recommended to install utPLSQL in it's own schema. You are free to choose any name for this schema. Installing uPLSQL into a shared schema is really not recommended as you loose isolation of framework.</p> <p>If the installing user and utPLSQL owner is one and the same, the user must have the following Oracle system permissions before you can proceed with the installation.</p> <ul> <li>CREATE SESSION</li> <li>CREATE PROCEDURE</li> <li>CREATE TYPE</li> <li>CREATE TABLE</li> <li>CREATE SEQUENCE</li> <li>CREATE VIEW</li> <li>CREATE SYNONYM</li> <li>ALTER SESSION</li> <li>CREATE TRIGGER</li> </ul> <p>In addition, the user must be granted the execute privilege on <code>DBMS_LOCK</code> and <code>DBMS_CRYPTO</code> packages.</p> <p>utPLSQL is using DBMS_PROFILER tables for code coverage. The tables required by DBMS_PROFILER will be created in the installation schema unless they already exist.</p> <p>It is up to DBA to maintain the storage of the profiler tables.</p>"},{"location":"userguide/install.html#manual-installation-procedure","title":"Manual installation procedure","text":""},{"location":"userguide/install.html#creating-schema-for-utplsql","title":"Creating schema for utPLSQL","text":"<p>To create the utPLSQL schema and grant all the required privileges execute script <code>create_utplsql_owner.sql</code> from the <code>source</code> directory with parameters:</p> <ul> <li><code>user name</code> - the name of the user that will own of utPLSQL object</li> <li><code>password</code>  - the password to be set for that user</li> <li><code>tablespace name</code> - the tablespace name to hold data created during test execution</li> </ul> <p>Example invocation: <pre><code>cd source\nsqlplus sys/sys_password@database as sysdba @create_utPLSQL_owner.sql ut3 ut3 users  \n</code></pre></p>"},{"location":"userguide/install.html#installing-utplsql","title":"Installing utPLSQL","text":"<p>To install the utPLSQL framework into your database, go to <code>source</code> directory, run the <code>install.sql</code> providing the <code>schema_name</code> for utPLSQL as parameter. Schema must be created prior to calling the <code>install</code> script. You may install utPLSQL from any account that has sufficient privileges to create objects in other users schema.  </p> <p>Example invocation: <pre><code>cd source\nsqlplus admin/admins_password@database @install.sql ut3  \n</code></pre></p>"},{"location":"userguide/install.html#installing-ddl-trigger","title":"Installing DDL trigger","text":"<p>To minimize startup time of utPLSQL framework (especially on a database with large schema) it is recommended to install utPLSQL DDL trigger to enable utPLSQL annotation to be updated at compile-time.</p> <p>It's recommended to install DDL trigger when connected as <code>SYSDBA</code> user. Trigger is created in utPLSQL schema. If using the owner schema of utPLSQL to install trigger, the owner needs to have <code>ADMINISTER DATABASE TRIGGER</code> and <code>CREATE TRIGGER</code> system privileges.  If using different user to install trigger, the user needs to have <code>ADMINISTER DATABASE TRIGGER</code> and <code>CREATE ANY TRIGGER</code> system privileges. </p> <p>To install DDL trigger go to <code>source</code> directory, run the <code>install_ddl_trigger.sql</code> providing the <code>schema_name</code> for utPLSQL as parameter.</p> <p>Example invocation: <pre><code>cd source\nsqlplus admin/admins_password@database @install_ddl_trigger.sql ut3  \n</code></pre></p> <p>Note</p> <p>Trigger can be installed ant any point in time after the utPLSQL installation. The framework will detect the presence of DDL trigger and act accordingly.</p>"},{"location":"userguide/install.html#allowing-other-users-to-access-the-utplsql-framework","title":"Allowing other users to access the utPLSQL framework","text":"<p>In order to allow other users to access utPLSQL, synonyms must be created and privileges granted. You have two options:</p> <ul> <li>use grants and synonyms to public, to allow all users to access the framework</li> <li>use synonyms and grants for individual users to limit the access to the framework</li> </ul> <p>To grant utPLSQL to public execute script <code>source/create_synonyms_and_grants_for_public.sql</code> and provide <code>schema_name</code> where utPLSQL is installed. </p> <p>Example invocation: <pre><code>cd source\nsqlplus admin/admins_password@database @create_synonyms_and_grants_for_public.sql ut3  \n</code></pre> To grant utPLSQL to an individual user, execute scripts <code>source/create_user_grants.sql</code> and <code>source/create_user_synonyms.sql</code>, provide <code>schema_name</code> where utPLSQL is installed and <code>user_name</code> to grant access for.</p> <p>Example invocation: <pre><code>cd source\nsqlplus ut3_owner_schema/ut3_password@database @create_user_grants.sql ut3 hr\nsqlplus user/user_password@database @create_user_synonyms.sql ut3 hr\n</code></pre></p> <p>The following tools that support the SQL*Plus commands can be used to run the installation script:</p> <ul> <li>SQL*Plus</li> <li>SQLcl</li> <li>Oracle SQL Developer</li> </ul>"},{"location":"userguide/install.html#checking-environment-and-utplsql-version","title":"Checking environment and utPLSQL version","text":"<p>To check the framework version execute the following query: <pre><code>select substr(ut.version(),1,60) as ut_version from dual;\n</code></pre></p> <p>Additionally you may retrieve more information about your environment by executing the following query: <pre><code>select \n  xmlserialize( content xmltype(ut_run_info()) as clob indent size = 2 )\n  from dual;\n</code></pre></p>"},{"location":"userguide/install.html#additional-requirements","title":"Additional requirements","text":"<p>In order to use the Code Coverage functionality of utPLSQL, users executing the tests must have the CREATE privilege on the PLSQL code that the coverage is gathered on. This is a requirement of DBMS_PROFILER package.</p> <p>In practice, user running tests for PLSQL code that he does not own, needs to have CREATE ANY PROCEDURE/CREATE ANY TRIGGER privileges. Running code coverage on objects that the user does not own will not produce any coverage information without those privileges.</p>"},{"location":"userguide/install.html#uninstalling-utplsql","title":"Uninstalling utPLSQL","text":"<p>To uninstall run <code>uninstall.sql</code> and provide <code>schema_name</code> where utPLSQL is installed.</p> <p>Example invocation: <pre><code>cd source\nsqlplus admin/admins_password@database @uninstall.sql ut3\n</code></pre></p> <p>The uninstall script will remove all the objects installed by the installation script. Additionally, all the public and private synonyms pointing to the objects in the utPLSQL schema will be removed.</p> <p>If you have extended any utPLSQL types such as a custom reporter, these will need to be dropped before the uninstall, otherwise the uninstall script might fail.</p> <p>The uninstall script does not drop the schema.</p> <p>In order for the uninstall to be successful, you need to use the uninstall script that was provided with the exact utPLSQL version installed on your database. i.e. the uninstall script provided with version 3.1.11 will not work correctly  if you want to remove version 3.0.0 from your database.</p> <p>Alternatively you can drop the user that owns utPLSQL and re-create it using headless install.</p>"},{"location":"userguide/install.html#version-upgrade","title":"Version upgrade","text":"<p>Currently, the only way to upgrade version of utPLSQL v3.0.0 and above is to remove the previous version and install the new version.</p>"},{"location":"userguide/install.html#working-with-utplsql-v2","title":"Working with utPLSQL v2","text":"<p>If you are using utPLSQL v2, you can still install utPLSQL v3. The only requirement is that utPLSQL v3 needs to be installed in a different schema than utPLSQL v2.</p> <p>utPLSQL v3 and utPLSQL v2 do not collide on public synonym names. </p>"},{"location":"userguide/querying_suites.html","title":"Querying for test suites","text":""},{"location":"userguide/querying_suites.html#obtaining-information-about-suites","title":"Obtaining information about suites","text":"<p>utPLSQL framework provides ability to read inforamtion about unit test suites that exist in a schema.</p> <p>Pipelined table function <code>ut_runner.get_suites_info(a_owner, a_package_name)</code> allows you to retrieve information about:</p> <ul> <li>all suites that exist in a given user/schema</li> <li>individual test suite pacakage</li> </ul> <p>Querying the data from function provides the follwing details:</p> <ul> <li><code>object_owner</code>     - the owner of test suite packages</li> <li><code>object_name</code>      - the name of test suite package</li> <li><code>item_name</code>        - the name of suite/test</li> <li><code>item_description</code> - the description of suite/suite item</li> <li><code>item_type</code>        - the type of item (UT_SUITE/UT_SUITE_CONTEXT/UT_TEST/UT_LOGICAL_SUITE)</li> <li><code>item_line_no</code>     - line_number where annotation identifying the item exists</li> <li><code>path</code>             - suitepath of the item</li> <li><code>disabled_flag</code>    - (0/1) indicator if item is disabled by --%disabled annotation</li> <li><code>tags</code>     - tags associated with suites</li> </ul> <p>To get list of all test suites in current schema  <pre><code>select * from table(ut_runner.get_suites_info()) where item_type = 'UT_SUITE';\n</code></pre></p> <p>To get list of all tests for test suite <code>TEST_STUFF</code> in current user schema <pre><code>select * from table(ut_runner.get_suites_info(USER, 'TEST_STUFF')) where item_type = 'UT_TEST';\n</code></pre></p> <p>To get a full information about suite <code>TEST_STUFF</code> including suite description, all contexts and tests in a suite <pre><code>select * from table(ut_runner.get_suites_info(USER, 'TEST_STUFF')) where item_type = 'UT_TEST';\n</code></pre></p> <p>To get a full information about suites that have a path like  <code>ut3:tests.test_package_*</code> including suite description, all contexts and tests in a suite  <pre><code>select * from table(ut_runner.get_suites_info('ut3:tests.test_package_*') where item_type = 'UT_TEST';\n</code></pre></p> <p>To get a full information about suites that have object name like  <code>test_package_*</code> including suite description, all contexts and tests in a suite  <pre><code>select * from table(ut_runner.get_suites_info('test_package_*'));\n</code></pre></p>"},{"location":"userguide/querying_suites.html#checking-if-schema-contains-tests","title":"Checking if schema contains tests","text":"<p>Function <code>ut_runner.has_suites(a_owner)</code> returns boolean value indicating if given schema contains test suites.</p> <p>Example: <pre><code>begin\n  if ut_runner.has_suites(USER) then\n    dbms_output.put_line( 'User '||USER||' owns test suites' );\n  else\n    dbms_output.put_line( 'User '||USER||' does not own test suites' );\n  end if;\nend;\n</code></pre></p>"},{"location":"userguide/querying_suites.html#checking-if-package-is-a-test-suite","title":"Checking if package is a test suite","text":"<p>Function <code>ut_runner.is_suite(a_owner, a_package_name)</code> returns boolean value indicating if given package is a test suites.</p> <p>Example: <pre><code>begin\n  if ut_runner.is_suite(USER,'TEST_STUFF') then\n    dbms_output.put_line( 'Package '||USER||'.TEST_STUFF is a test suite' );\n  else\n    dbms_output.put_line( 'Package '||USER||'.TEST_STUFF is not a test suite' );\n  end if;\nend;\n</code></pre></p>"},{"location":"userguide/querying_suites.html#checking-if-procedure-is-a-test-within-a-suite","title":"Checking if procedure is a test within a suite","text":"<p>Function <code>ut_runner.is_test(a_owner, a_package_name, a_procedure_name)</code> returns boolean value indicating if given package is a test suites.</p> <p>Example: <pre><code>begin\n  if ut_runner.is_test(USER,'TEST_STUFF','A_TEST_TO_CHECK_STUFF') then\n    dbms_output.put_line( 'Procedure '||USER||'.TEST_STUFF.A_TEST_TO_CHECK_STUFF is a test' );\n  else\n    dbms_output.put_line( 'Procedure '||USER||'.TEST_STUFF.A_TEST_TO_CHECK_STUFF is not a test' );\n  end if;\nend;\n</code></pre></p>"},{"location":"userguide/reporters.html","title":"Using reporters","text":"<p>utPLSQL provides several reporting formats. The sections below describe most of them. </p>"},{"location":"userguide/reporters.html#documentation-reporter","title":"Documentation reporter","text":"<p>The <code>ut_documentation_reporter</code> is the default reporting format used by the framework. It provides a human readable test results.</p> <p>To invoke tests with documentation reporter use one of following calls from sql console (SQLPlus)  </p> <p><code>exec ut.run();</code></p> <p><code>exec ut.run(ut_documentation_reporter());</code></p> <p>Example outputs from documentation reporter.</p> <p></p> <p>Documentation reporter provides the following information.</p> <ul> <li>Test suite name or test package name  (nested with suitepath if suitepath is used)</li> <li>Test description name or test procedure name</li> <li>Information about test failing <code>(FAILED - n)</code> </li> <li>Information about disabled test <code>(IGNORED)</code> </li> <li>List of all errors and failures</li> <li>Summary with total number of tests, number of tests with status and timing for the execution </li> </ul>"},{"location":"userguide/reporters.html#color-output-from-documentation-reporter","title":"Color output from documentation reporter","text":"<p>When invoking tests with documentation reporter and your command line supports ANSICONSOLE (default on Unix) available for Windows, you can obtain the coloured outputs from the documentation reporter.</p> <p>To invoke tests with documentation reporter in color mode use one of following calls.  </p> <p><code>exec ut.run(a_color_console=&gt;true);</code></p> <p><code>exec ut.run(ut_documentation_reporter(), a_color_console=&gt;true);</code></p> <p>Example outputs from documentation reporter.</p> <p></p>"},{"location":"userguide/reporters.html#junit-reporter","title":"JUnit reporter","text":"<p>Most of continuous integration servers (like Jenkins) are capable of consuming unit test execution results in JUnit format. The <code>ut_junit_reporter</code> in earlier version referred as <code>ut_xunit_reporter</code> is producing outcomes as JUnit-compatible XML unit test report, that can be used by CI servers to display their custom reports and provide metrics (like tests execution trends). Please note that in previous versions it was called ut_xunit_reporter and for backward compatibility that name still exists.</p> <p>Invocation of tests with JUnit reporter.  </p> <p><code>exec ut.run(ut_junit_reporter());</code></p> <p>The <code>ut_junit_reporter</code> doesn't accept any arguments.</p> <p>Example of junit report integrated with Jenkins CI</p> <p></p> <p>Example of failure report details</p> <p></p>"},{"location":"userguide/reporters.html#teamcity-reporter","title":"Teamcity reporter","text":"<p>Teamcity is a CI server by Jetbrains. It supports JUnit reporting and additionally has it's own format of reporting that allows tracking of progress of a CI step/task as it executes. The TeamCity format developed by Jetbrains is supported by utPLSQL with <code>ut_teamcity_reporter</code>.</p> <p>Invocation of tests with Teamcity reporter.  </p> <p><code>exec ut.run(ut_teamcity_reporter());</code></p> <p>The <code>ut_teamcity_reporter</code> doesn't accept any arguments.</p> <p>Example of unit test report from Teamcity CI server.</p> <p></p> <p>Example of failure report details</p> <p></p>"},{"location":"userguide/reporters.html#sonar-test-reporter","title":"Sonar test reporter","text":"<p>If you are using SonarQube or SonarCloud to do static code analysis for you PLSQL projects, your code analysis can benefit from code coverage and test results. utPLSQL provides two reporters to for SonarQube:</p> <ul> <li><code>ut_sonar_test_reporter</code> - provides an XML output of each test executed per each project test file (package) </li> <li><code>ut_coverage_sonar_reporter</code> - provides XML output of code coverage per each project source file </li> </ul> <p><code>ut_sonar_test_reporter</code> needs to be called with a list of paths to test files (packages). The paths to files can be relative to the project root directory (recommended) or be absolute. </p> <p><code>ut_coverage_sonar_reporter</code> needs to be called with a list of paths to source files for your project. The paths to files can be relative to the project root directory (recommended) or be absolute.</p> <p>Providing invalid paths or paths to non-existing files will result in failure when publishing test results/coverage results to sonar server.</p> <p>For details on how to invoke reporter with paths, see the Code coverage section.</p>"},{"location":"userguide/reporters.html#tfs-vsts-reporter","title":"TFS / VSTS Reporter","text":"<p>If you are using TFS or VSTS to do static code analysis for you PLSQL projects and run builds,  your code analysis can benefit from code coverage and test results. TFS reporter is designed specifically to work with Microsoft Team Fundation Server report format which is very old version of JUnit. Main difference between standard JUnit is that  elements cannot be nested and attribute skipped is not present. <p>utPLSQL provides a dedicated <code>ut_tfs_junit_reporter</code> reporter to for TFS / VSTS servers. The reporter provides an XML output of each test executed per each project test file (package). Example of test report from TFS CI server.</p> <p>Summary:</p> <p></p> <p>Details:</p> <p></p>"},{"location":"userguide/reporters.html#coverage-reporters","title":"Coverage reporters","text":"<p>utPLSQL comes with a set of build-in coverage reporters. Code coverage section describes in details how to use configure and use code coverage.</p>"},{"location":"userguide/reporters.html#debug-reporter","title":"Debug reporter","text":"<p>The <code>ut_debug_reporter</code> provides a highly verbose output containing thorough details about framework and test execution.</p> <p>Use this reporter only when you need to investigate framework issues or raise a bug report to utPLSQL team.</p> <p>Usage of this reporter might have impact on performance of test-suite execution.</p> <p>Amongst others, reporter provides the following information:</p> <ul> <li>framework version</li> <li>database version</li> <li>database OS</li> <li>database, instance and session NLS settings</li> <li>timing of each event</li> <li>time between events logged</li> <li>time from start of the run</li> <li>stack trace</li> <li>information about input parameters for the run including<ul> <li>run paths</li> <li>source file mappings</li> <li>test file mappings</li> <li>coverage schemas</li> <li>coverage exclusions and inclusions</li> <li>client character set</li> </ul> </li> <li>information about every step of the run including<ul> <li>every suite and context</li> <li>every before/after procedure</li> <li>every test</li> <li>every expectation and it's result</li> </ul> </li> </ul> <p>Some information in debug log might be redundant.</p> <p>Note</p> <p>Some information in debug log may be sensitive. In particular:  - expectation results and messages (logged even for successful runs)  - test structure  - db object names  - etc.</p>"},{"location":"userguide/reporters.html#custom-reporters","title":"Custom reporters","text":"<p>It is possible to add your own reporters by creating an appropriate object type.  In principle, it has to be a subtype of <code>ut_reporter_base</code>. However, if the reporter is expected to produce output consumable by a client oustside of the database (e.g. the data has to be reported to the screen or to a file), then you should base it on <code>ut_output_reporter_base</code> (which is a subtype of <code>ut_reporter_base</code>). In contrast, if you would like to create a reporter that, for example, saves the data to a database table, then it should be based directly on <code>ut_reporter_base</code>. (Currently, all reporters in the utPLSQL framework are based on <code>ut_output_reporter_base</code>.) Coverage reporters are based on <code>ut_coverage_reporter_base</code> (a subtype of <code>ut_output_reporter_base</code>).</p> <p>If you need to produce a colored text output from the custom reporter, then you can build it basing on <code>ut_console_reporter_base</code> (a subtype of <code>ut_output_reporter_base</code>). In many cases it may also be more convenient to create the custom reporter type under a more specialized type, like <code>ut_documentation_reporter</code> or <code>ut_junit_reporter</code>, and override just some of the functionality.</p> <p>It is recommended to create the reporter type in the schema where utPLSQL is installed (by default it is the <code>UT3</code> schema). Note that before running the utPLSQL uninstall scripts, all custom reporters should be dropped (cf. the installation documentation). In particular, when upgrading to a newer version of utPLSQL, one has to drop the custom reporters and recreate them after the upgrade.</p> <p>Note</p> <p>It is possible, but cumbersome, to use another schema for storing the custom reporters. This requires to create a synonym for the base reporter type in the schema that is going to own the custom reporter, and to provide appropriate grants both to the owner of the custom reporter and to the user running the reporter. After upgrading or reinstalling utPLSQL, the extra privileges need to be recreated. This approach is not recommended.</p> <p>Assuming that the custom reporter type is created in the <code>UT3</code> schema, to run the tests using a custom reporter just call: <code>exec ut.run(ut3.custom_reporter_name());</code>, optionally providing parameter values to the <code>custom_reporter_name</code> constructor.</p> <p>One may get acquainted with the source code of the standard reporters bundled with utPLSQL (including the coverage reporters) by browsing the <code>source/reporters/</code> directory. The base reporter types <code>ut_reporter_base</code>, <code>ut_output_reporter_base</code> and <code>ut_console_reporter_base</code> are defined in <code>source/core/types</code>. The base coverage reporter type <code>ut_coverage_reporter_base</code> is in <code>source/core/coverage</code>. There are also two examples of custom reporters in <code>examples/custom_reporters/</code>, both extending the functionality of <code>ut_documentation_reporter</code>:</p> <ul> <li><code>ut_custom_reporter</code> accepts an integer parameter <code>a_tab_size</code>; it alters the behaviour of <code>ut_documentation_reporter</code> by changing the size of the indentation according to the parameter value (by default the indentation is increased).</li> <li><code>ut_expectations_reporter</code> accepts a <code>varchar2</code> parameter <code>a_report_all_expectations</code>; if its value is <code>'Y'</code> (which is the default), then the reporter shows the results of all expectations that are run. This stays in contrast with <code>ut_documentation_reporter</code>, which shows the results of all tests that are run, but only of the expectations that failed (keep in mind that a single test may consist of several expectations).</li> </ul>"},{"location":"userguide/running-unit-tests.html","title":"Running unit tests","text":"<p>utPLSQL framework provides two main entry points to run unit tests from within the database: </p> <ul> <li><code>ut.run</code> procedures and functions</li> <li><code>ut_runner.run</code> procedures</li> </ul> <p>These two entry points differ in purpose and behavior. Most of the time you will want to use <code>ut.run</code> as <code>ut_runner.run</code> is designed for API integration and does not display the results to the screen.</p>"},{"location":"userguide/running-unit-tests.html#running-from-ci-servers-and-command-line","title":"Running from CI servers and command line","text":"<p>The best way to run your tests from CI server or command line is to use the utPLSQL-cli command line client.</p> <p>Amongst many benefits it provides ability to: * see the progress of test execution for long-running tests - real-time reporting * use many reporting formats simultaneously and save reports to files (publish) * map your project source files and test files into database objects </p> <p>You may download the latest release of the command line client from here or do it automatically using the command below (Unix).</p> <pre><code>#!/bin/bash\n# Get the url to latest release \"zip\" file\nDOWNLOAD_URL=$(curl --silent https://api.github.com/repos/utPLSQL/utPLSQL-cli/releases/latest | awk '/browser_download_url/ { print $2 }' | grep \".zip\\\"\" | sed 's/\"//g')\n# Download the latest release \"zip\" file\ncurl -Lk \"${DOWNLOAD_URL}\" -o utplsql-cli.zip\n# Extract downloaded \"zip\" file\nunzip -q utplsql-cli.zip\n</code></pre>"},{"location":"userguide/running-unit-tests.html#utrun","title":"ut.run","text":"<p>The <code>ut</code> package contains overloaded <code>run</code> procedures and functions. The <code>run</code> API is designed to be called directly by a developer when using an IDE/SQL console to execute unit tests. The main benefit of using this API is it's simplicity. A single line call is enough to execute a set of tests from one or more schemes.</p> <p>The procedures execute the specified tests and produce output to DBMS_OUTPUT using the specified reporter. The functions can only be used in SELECT statements. They execute the specified tests and produce outputs as a pipelined data stream to be consumed by a select statement.</p>"},{"location":"userguide/running-unit-tests.html#utrun-procedures","title":"ut.run procedures","text":"<p>The examples below illustrate different ways and options to invoke <code>ut.run</code> procedures. You can use a wildcard character <code>*</code> to call tests by part of their name or to call tests that are located on paths matched by part of path string. Wildcard character can be placed anywhere on the path and can occur mutliple times. Schema name cannot contain a wildcard character whether is in a suitepath call or call by object name.</p> <p><pre><code>alter session set current_schema=hr;\nset serveroutput on\nbegin\n  ut.run();\nend;\n</code></pre> Executes all tests in current schema (HR).</p> <p><pre><code>set serveroutput on\nbegin\n  ut.run('HR');\nend;\n</code></pre> Executes all tests in specified schema (HR).</p> <pre><code>set serveroutput on\nbegin\n  ut.run('hr:com.my_org.my_project');\nend;\n</code></pre> <p>Executes all tests from all packages that are on the com.my_org.my_project suitepath. Check the annotations documentation to find out about suitepaths and how they can be used to organize test packages for your project.</p> <pre><code>set serveroutput on\nbegin\n  ut.run('hr:com*');\nend;\n</code></pre> <p>Executes all tests in schema <code>hr</code> from all packages that are on suitepath starting with <code>com</code>.</p> <pre><code>set serveroutput on\nbegin\n  ut.run('hr:co*.my_*.my_*');\nend;\n</code></pre> <p>Executes all tests in schema <code>hr</code> from all packages that starting with <code>my_</code> and all tests starting with <code>my_*</code> that are on suitepath starting with <code>co</code> .</p> <p><pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus');\nend;\n</code></pre> Executes all tests from package hr.test_apply_bonus. </p> <p><pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus.bonus_cannot_be_negative');\nend;\n</code></pre> Executes single test procedure hr.test_apply_bonus.bonus_cannot_be_negative.</p> <p><pre><code>set serveroutput on\nbegin\n  ut.run(ut_varchar2_list('hr.test_apply_bonus','cust'));\nend;\n</code></pre> Executes all tests from package hr.test_apply_bonus and all tests from schema cust (passing individual items to be executed as elements of the ut_varchar2_list table type).</p> <p><pre><code>set serveroutput on\nbegin\n  ut.run(ut_varchar2_list('hr.test_apply_bonus,cust'));\nend;\n</code></pre> Executes all tests from package hr.test_apply_bonus and all tests from schema cust (passing all items as a comma-separated-list of values into a single element of the ut_varchar2_list table type).</p> <pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus,cust');\nend;\n</code></pre> <p>Executes all tests from package hr.test_apply_bonus and all tests from schema cust (no explicit ut_varchar2_list table type).</p> <p>Using a list of items to execute allows you to execute a fine-grained set of tests.</p> <p>List can be passed as a comma separated list or a list of ut_varchar2_list objects or as a list within ut_varchar2_list.</p> <p><pre><code>set serveroutput on\nbegin\n  ut.run('hr.test*');\nend;\n</code></pre> Executes all tests in schema <code>hr</code> located in packages starting with name <code>test</code>.</p> <p><pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus.bonus_*');\nend;\n</code></pre> Executes test procedures with names starting with <code>bonus</code> in package <code>hr.test_apply_bonus</code> .</p> <p>Note:</p> <p><code>ut_documentation_reporter</code> is the default reporter for all APIs defined for running unit tests.</p> <p>The <code>ut.run</code> procedures and functions accept <code>a_reporter</code> attribute that defines the reporter to be used in the run. You can execute any set of tests with any of the predefined reporters.</p> <p><pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus', ut_junit_reporter());\nend;\n</code></pre> Executes all tests from package HR.TEST_APPLY_BONUS and provide outputs to DBMS_OUTPUT using the JUnit reporter. </p> <p>For details on build-in reporters look at reporters documentation.</p>"},{"location":"userguide/running-unit-tests.html#utrun-functions","title":"ut.run functions","text":"<p>The <code>ut.run</code> functions provide exactly the same functionality as the <code>ut.run</code> procedures.  You may use the same sets of parameters with both functions and procedures.  The only difference is the output of the results. Functions provide output as a pipelined stream and therefore need to be executed as select statements.</p> <p>Note:</p> <p>When running tests with <code>ut.run</code> functions, whole test run is executed as autonomous transaction. At the end of the run, the transaction is automatically rolled-back and all uncommitted changes are reverted.   </p> <p>Example. <pre><code>select * from table(ut.run('hr.test_apply_bonus', ut_junit_reporter()));\n</code></pre></p>"},{"location":"userguide/running-unit-tests.html#ut_runnerrun-procedures","title":"ut_runner.run procedures","text":"<p>The <code>ut_runner</code> package provides an API for integrating utPLSQL with other products. Maven, Jenkins, SQL Develper, PL/SQL Developer, TOAD and others can leverage this API to call utPLSQL.</p> <p>The main difference compared to the <code>ut.run</code> API is that <code>ut_runner.run</code> does not print output to the screen.</p> <p><code>ut_runner.run</code> accepts multiple reporters. Each reporter pipes to a separate output (uniquely identified by output_id). Outputs of multiple reporters can be consumed in parallel. This allows for live reporting of test execution progress with threads and several database sessions.</p> <p><code>ut_runner.run</code> API is used by utPLSQL-cli, utPLSQL-SQLDeveloper extension and utPLSQL-maven-plugin and allows for: - deciding on the scope of test run (by schema names, object names, suite paths or tags ) - running tests with several concurrent reporters - real-time reporting of test execution progress - controlling colored text output to the screen - controlling scope of code coverage reports - mapping of database source code to project files - controlling behavior on test-failures - controlling client character set for HTML and XML reports - controlling rollback behavior of test-run - controlling random order of test execution</p> <p>Running with multiple reporters.</p> <ul> <li>in the main thread (session), define the reporters to be used. Each reporter has it's output_id and so you need to extract and store those output_ids.</li> <li>as a separate thread, start <code>ut_runner.run</code> and pass reporters with previously defined output_ids.</li> <li>for each reporter start a separate thread and read outputs from the <code>reporter.get_lines</code> table function or from <code>reporter.get_lines_cursor()</code> by providing the <code>reporter_id</code> defined in the main thread.</li> <li>each reporter for each test-run must have a unique <code>reporter_id</code>. The <code>reporter_id</code> is used between two sessions to identify the data stream </li> </ul> <p>Example: <pre><code>--main test run ( session 1 )\ndeclare\n  l_reporter      ut_realtime_reporter := ut_realtime_reporter();\nbegin\n  l_reporter.set_reporter_id( 'd8a79e85915640a6a4e1698fdf90ba74' );\n  l_reporter.output_buffer.init();\n  ut_runner.run (ut_varchar2_list ('ut3_tester','ut3_user'), ut_reporters( l_reporter ) );\nend;\n/\n</code></pre></p> <pre><code>--report consumer ( session 2 )\nset arraysize 1\nset pagesize 0\n\nselect * \n  from table(\n         ut_realtime_reporter()\n           .set_reporter_id('d8a79e85915640a6a4e1698fdf90ba74')\n           .get_lines()\n  );\n</code></pre> <pre><code>--alternative version of report consumer ( session 2 )\nset arraysize 1\nset pagesize 0\n\nselect\n    ut_realtime_reporter()\n      .set_reporter_id('d8a79e85915640a6a4e1698fdf90ba74')\n      .get_lines_cursor()\n  from dual;\n</code></pre>"},{"location":"userguide/running-unit-tests.html#order-of-test-execution","title":"Order of test execution","text":""},{"location":"userguide/running-unit-tests.html#default-order","title":"Default order","text":"<p>When unit tests are executed without random order, they are ordered by: - schema name - suite path or test package name if <code>--%suitepath</code> was not specified for that package - <code>--%test</code> line number in package</p>"},{"location":"userguide/running-unit-tests.html#random-order","title":"Random order","text":"<p>You can force a test run to execute tests in random order by providing one of options to <code>ut.run</code>: - <code>a_random_test_order</code> - true/false for procedures and 1/0 for functions - <code>a_random_test_order_seed</code> - positive number in range of 1 .. 1 000 000 000 </p> <p>When tests are executed with random order, randomization is applied to single level of suitepath hierarchy tree. This is needed to maintain visibility and accessibility of common setup/cleanup <code>beforeall</code>/<code>afterall</code> in tests.</p> <p>Example: <pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus', a_random_test_order =&gt; true);\nend;\n</code></pre></p> <pre><code>select * from table(ut.run('hr.test_apply_bonus', a_random_test_order =&gt; 1));\n</code></pre> <p>When running with random order, the default report (<code>ut_documentation_reporter</code>) will include information about the random test run seed. Example output: <pre><code>...\nFinished in .12982 seconds\n35 tests, 0 failed, 0 errored, 1 disabled, 0 warning(s)\nTests were executed with random order seed '302980531'.\n</code></pre></p> <p>If you want to re-run tests using previously generated seed, you may do so by running them with parameter <code>a_random_test_order_seed</code> Example: <pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus', a_random_test_order_seed =&gt; 302980531);\nend;\n</code></pre></p> <pre><code>select * from table(ut.run('hr.test_apply_bonus', a_random_test_order_seed =&gt; 302980531));\n</code></pre> <p>Note</p> <p>Random order seed must be a positive number within range of 1 .. 1 000 000 000. </p>"},{"location":"userguide/running-unit-tests.html#run-by-tags","title":"Run by Tags","text":"<p>In addition to the path, you can filter the tests to be run by specifying tags. Tags are defined in the test / context / suite with the <code>--%tags</code>-annotation (Read more). Multiple tags are separated by comma. </p>"},{"location":"userguide/running-unit-tests.html#tag-expressions","title":"Tag Expressions","text":"<p>Tag expressions are boolean expressions created by combining tags with the <code>!</code>, <code>&amp;</code>, <code>|</code> operators. Tag expressions can be grouped using <code>(</code> and <code>)</code> braces. Grouping tag expressions affects operator precedence.</p> <p>Two reserved keywords, <code>any</code> and <code>none</code>, can be used when creating a tag expression to run tests. - <code>any</code> keyword represents tests and suites with any tags - <code>none</code> keyword represents tests and suites without tags</p> <p>These keywords may be combined with other expressions just like normal tags.</p> <p>Note</p> <p>When specifying <code>none</code>, be aware that it will exclude any tests/suites/contexts contained within a tagged suite.</p> Operator Meaning ! not &amp; and | or <p>If you are tagging your tests across multiple dimensions, tag expressions help you to select which tests to execute. When tagging by test type (e.g., micro, integration, end-to-end) and feature (e.g., product, catalog, shipping), the following tag expressions can be useful.</p> Tag Expression Selection product all tests for product catalog | shipping all tests for catalog plus all tests for shipping catalog &amp; shipping all tests that are tagged with both <code>catalog</code> and <code>shipping</code> tags product &amp; !end-to-end all tests tagged <code>product</code>, except the tests tagged <code>end-to-end</code> (micro | integration) &amp; (product | shipping) all micro or integration tests for product or shipping <p>Taking the last expression above <code>(micro | integration) &amp; (product | shipping)</code></p> --%tags included in run micro no integration no micro no product no shipping no micro no micro, integration no product, shipping no micro, product yes micro, shipping yes integration, product yes integration, shipping yes integration, micro, shipping yes integration, micro, product yes integration, shipping ,product yes micro, shipping ,product yes integration, micro, shipping ,product yes"},{"location":"userguide/running-unit-tests.html#sample-execution-of-test-with-tags","title":"Sample execution of test with tags.","text":"<p>Execution of the test with tag expressions is done using the parameter <code>a_tags</code>. Given a test package <code>ut_sample_test</code> defined below </p> <pre><code>create or replace package ut_sample_test is\n\n   --%suite(Sample Test Suite)\n   --%tags(api)\n\n   --%test(Compare Ref Cursors)\n   --%tags(complex,fast)\n   procedure ut_refcursors1;\n\n   --%test(Run equality test)\n   --%tags(simple,fast)\n   procedure ut_test;\n\nend ut_sample_test;\n/\n\ncreate or replace package body ut_sample_test is\n\n   procedure ut_refcursors1 is\n      v_actual   sys_refcursor;\n      v_expected sys_refcursor;\n   begin\n    open v_expected for select 1 as test from dual;\n    open v_actual   for select 2 as test from dual;\n\n      ut.expect(v_actual).to_equal(v_expected);\n   end;\n\n   procedure ut_test is\n   begin\n       ut.expect(1).to_equal(0);\n   end;\n\nend ut_sample_test;\n/\n</code></pre> <p><pre><code>select * from table(ut.run(a_path =&gt; 'ut_sample_test',a_tags =&gt; 'api'));\n</code></pre> The above call will execute all tests from <code>ut_sample_test</code> package as the whole suite is tagged with <code>api</code></p> <p><pre><code>select * from table(ut.run(a_tags =&gt; 'fast&amp;complex'));\n</code></pre> The above call will execute only the <code>ut_sample_test.ut_refcursors1</code> test, as only the test <code>ut_refcursors1</code> is tagged with <code>complex</code> and <code>fast</code></p> <p><pre><code>select * from table(ut.run(a_tags =&gt; 'fast'));\n</code></pre> The above call will execute both <code>ut_sample_test.ut_refcursors1</code> and <code>ut_sample_test.ut_test</code> tests, as both tests are tagged with <code>fast</code></p>"},{"location":"userguide/running-unit-tests.html#excluding-testssuites-by-tags","title":"Excluding tests/suites by tags","text":"<p>It is possible to exclude parts of test suites with tags. In order to do so, prefix the tag name to exclude with a <code>!</code> (exclamation) sign when invoking the test run which is equivalent of <code>-</code> (dash) in legacy notation. Examples (based on above sample test suite)</p> <pre><code>select * from table(ut.run(a_tags =&gt; '(api|fast)&amp;!complex'));\n</code></pre> <p>or </p> <pre><code>select * from table(ut.run(a_tags =&gt; '(api|fast)&amp;!complex&amp;!test1'));\n</code></pre> <p>which is equivalent of exclusion on whole expression</p> <pre><code>select * from table(ut.run(a_tags =&gt; '(api|fast)&amp;!(complex|test1)'));\n</code></pre> <p>The above calls  will execute all suites/contexts/tests that are marked with any of tags <code>api</code> or <code>fast</code> except those suites/contexts/tests that are marked as <code>complex</code> and except those suites/contexts/tests that are marked as <code>test1</code>.  Given the above example package <code>ut_sample_test</code>, only <code>ut_sample_test.ut_test</code> will be executed.  </p>"},{"location":"userguide/running-unit-tests.html#sample-execution-with-any-and-none","title":"Sample execution with <code>any</code> and <code>none</code>","text":"<p>Given a sample test package:</p> <pre><code>create or replace package ut_sample_test is\n\n   --%suite(Sample Test Suite)\n\n   --%test(Compare Ref Cursors)\n   --%tags(complex,fast)\n   procedure ut_refcursors1;\n\n   --%test(Run equality test)\n   --%tags(simple,fast)\n   procedure ut_test;\n\n   --%test(Run equality test no tag)   \n   procedure ut_test_no_tag;\n\nend ut_sample_test;\n/\n\ncreate or replace package body ut_sample_test is\n\n   procedure ut_refcursors1 is\n      v_actual   sys_refcursor;\n      v_expected sys_refcursor;\n   begin\n    open v_expected for select 1 as test from dual;\n    open v_actual   for select 2 as test from dual;\n\n      ut.expect(v_actual).to_equal(v_expected);\n   end;\n\n   procedure ut_test is\n   begin\n       ut.expect(1).to_equal(0);\n   end;\n\n   procedure ut_test_no_tag is\n   begin\n       ut.expect(1).to_equal(0);\n   end;   \n\nend ut_sample_test;\n/\n</code></pre> <pre><code>select * from table(ut.run(a_path =&gt; 'ut_sample_test',a_tags =&gt; 'none'));\n</code></pre> <p>The above call will execute tests <code>ut_test_no_tag</code></p> <pre><code>select * from table(ut.run(a_path =&gt; 'ut_sample_test',a_tags =&gt; 'any'));\n</code></pre> <p>The above call will execute tests <code>ut_test</code> and <code>ut_refcursors1</code></p> <pre><code>select * from table(ut.run(a_path =&gt; 'ut_sample_test',a_tags =&gt; 'none|simple'));\n</code></pre> <p>The above call will execute tests <code>ut_test_no_tag</code> and <code>ut_test</code> </p> <pre><code>select * from table(ut.run(a_tags =&gt; 'none|!simple'));\n</code></pre> <p>The above call will execute tests <code>ut_test_no_tag</code> and <code>ut_refcursors1</code> </p>"},{"location":"userguide/running-unit-tests.html#keeping-uncommitted-data-after-test-run","title":"Keeping uncommitted data after test-run","text":"<p>utPLSQL by default runs tests in autonomous transaction and performs automatic rollback to assure that tests do not impact one-another and do not have impact on the current session in your IDE.</p> <p>If you would like to keep your uncommitted data persisted after running tests, you can do so by using <code>a_force_manual_rollback</code> flag. Setting this flag to true has following side-effects:</p> <ul> <li>test execution is done in current transaction - if while running tests commit or rollback is issued your current session data will get commited too.</li> <li>automatic rollback is forced to be disabled in test-run even if it was explicitly enabled by using annotation `--%rollback(manual)</li> </ul> <p>Example invocation: <pre><code>set serveroutput on\nbegin\n  ut.run('hr.test_apply_bonus', a_force_manual_rollback =&gt; true);\nend;\n</code></pre></p> <p>Note:</p> <p>This option is not available when running tests using <code>ut.run</code> as a table function.</p>"},{"location":"userguide/running-unit-tests.html#reports-character-set-encoding","title":"Reports character-set encoding","text":"<p>To get properly encoded reports, when running utPLSQL with HTML/XML reports on data containing national characters you need to provide your client character set when calling <code>ut.run</code> functions and procedures.</p> <p>If you run your tests using <code>utPLSQL-cli</code>, this is done automatically and no action needs to be taken.</p> <p>To make sure that the reports will display your national characters properly when running from IDE like SQLDeveloper/TOAD/SQLPlus or sqlcl you need to provide the charaterset manualy to <code>ut.run</code>.</p> <p>Example call with characterset provided: <pre><code>begin\n  ut.run('hr.test_apply_bonus', ut_junit_reporter(), a_client_character_set =&gt; 'Windows-1251');\nend;\n</code></pre></p>"},{"location":"userguide/upgrade.html","title":"Upgrade utPLSQL","text":""},{"location":"userguide/upgrade.html#upgrading-from-version-2","title":"Upgrading from version 2","text":"<p>utPLSQL v3 is a total rewrite of the framework. To make utPLSQL v2 packages run on v3 framework you need to install and execute migration utility. See the utPLSQL-v2-v3-migration project for details on how to install and execute the migration.</p>"}]}