{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction to utPLSQL \u00b6 utPLSQL is a Unit Testing framework for Oracle PL/SQL. The framework follows industry standards and best patterns of modern Unit Testing frameworks like JUnit and RSpec User Guide Installation Getting Started Annotations Expectations Advanced data comparison Running unit tests Testing best pracitces Upgrade utPLSQL Reporting Using reporters Reporting errors Code coverage Cheat-sheet About Project Details License Support Authors Demo project \u00b6 Have a look at our demo project . It uses Travis CI to build on every commit, runs all tests, publishes test results and code coverage to SonarQube . Three steps \u00b6 With just three simple steps you can define and run your unit tests for PLSQL code. Install the utPLSQL framework Create Unit Tests to for the code Run the tests Here is how you can simply create tested code, unit tests and execute the tests using SQL Developer Check out the sections on annotations and expectations to see how to define your tests. Command line \u00b6 You can use the utPLSQL command line client utPLSQL-cli to run tests without the need for Oracle Client or any IDE like SQLDeveloper/TOAD etc. Amongst many benefits they provide ability to: * see the progress of test execution for long-running tests - real-time reporting * use many reporting formats simultaneously and save reports to files (publish) * map your project source files and test files into database objects Just download the latest client , download Oracle jdbc driver you are good to go. See project readme for details. Coverage \u00b6 If you want to have code coverage gathered on your code , it's best to use ut_run to execute your tests with multiple reporters and have both test execution report as well as coverage report saved to a file. Check out the coverage documentation for options of coverage reporting","title":"Introduction to utPLSQL"},{"location":"index.html#introduction-to-utplsql","text":"utPLSQL is a Unit Testing framework for Oracle PL/SQL. The framework follows industry standards and best patterns of modern Unit Testing frameworks like JUnit and RSpec User Guide Installation Getting Started Annotations Expectations Advanced data comparison Running unit tests Testing best pracitces Upgrade utPLSQL Reporting Using reporters Reporting errors Code coverage Cheat-sheet About Project Details License Support Authors","title":"Introduction to utPLSQL"},{"location":"index.html#demo-project","text":"Have a look at our demo project . It uses Travis CI to build on every commit, runs all tests, publishes test results and code coverage to SonarQube .","title":"Demo project"},{"location":"index.html#three-steps","text":"With just three simple steps you can define and run your unit tests for PLSQL code. Install the utPLSQL framework Create Unit Tests to for the code Run the tests Here is how you can simply create tested code, unit tests and execute the tests using SQL Developer Check out the sections on annotations and expectations to see how to define your tests.","title":"Three steps"},{"location":"index.html#command-line","text":"You can use the utPLSQL command line client utPLSQL-cli to run tests without the need for Oracle Client or any IDE like SQLDeveloper/TOAD etc. Amongst many benefits they provide ability to: * see the progress of test execution for long-running tests - real-time reporting * use many reporting formats simultaneously and save reports to files (publish) * map your project source files and test files into database objects Just download the latest client , download Oracle jdbc driver you are good to go. See project readme for details.","title":"Command line"},{"location":"index.html#coverage","text":"If you want to have code coverage gathered on your code , it's best to use ut_run to execute your tests with multiple reporters and have both test execution report as well as coverage report saved to a file. Check out the coverage documentation for options of coverage reporting","title":"Coverage"},{"location":"about/authors.html","text":"utPLSQL v3 Major Contributors \u00b6 Listed Alphabetically Name GitHub account David Pyke Shoelace Jacek Gebal jgebal Pavel Kaplya Pazus Robert Love rlove Vinicius Avellar viniciusam Samuel Nitsche pesse Lukasz Wasylow lwasylow Many thanks to all the contributors Special thanks to prior major contributors \u00b6 Steven Feuerstein - Original Author Chris Rimmer Patrick Barel Paul Walker","title":"Authors"},{"location":"about/authors.html#utplsql-v3-major-contributors","text":"Listed Alphabetically Name GitHub account David Pyke Shoelace Jacek Gebal jgebal Pavel Kaplya Pazus Robert Love rlove Vinicius Avellar viniciusam Samuel Nitsche pesse Lukasz Wasylow lwasylow Many thanks to all the contributors","title":"utPLSQL v3 Major Contributors"},{"location":"about/authors.html#special-thanks-to-prior-major-contributors","text":"Steven Feuerstein - Original Author Chris Rimmer Patrick Barel Paul Walker","title":"Special thanks to prior major contributors"},{"location":"about/license.html","text":"Version Information \u00b6 utPLSQL version 3 is licensed under Apache 2.0 External code used in the development of this project, but is not required for use. Tool License Purpose Travis-Oracle ISC Install Oracle for Travis Builds mkDocs BSD Produce HTML version of documentation Note: Version 1 & 2 of utPLSQL were licensed under GPL, version 3 was a complete rewrite from scratch which a allowed us to change the license to be more permissive.","title":"License"},{"location":"about/license.html#version-information","text":"utPLSQL version 3 is licensed under Apache 2.0 External code used in the development of this project, but is not required for use. Tool License Purpose Travis-Oracle ISC Install Oracle for Travis Builds mkDocs BSD Produce HTML version of documentation Note: Version 1 & 2 of utPLSQL were licensed under GPL, version 3 was a complete rewrite from scratch which a allowed us to change the license to be more permissive.","title":"Version Information"},{"location":"about/project-details.html","text":"utPLSQL Project Details \u00b6 utPLSQL is open source project hosted on GitHub . Contributions, help and constructive feedback is always appreciated. If you are interested in helping please read our contributing guide","title":"Project Details"},{"location":"about/project-details.html#utplsql-project-details","text":"utPLSQL is open source project hosted on GitHub . Contributions, help and constructive feedback is always appreciated. If you are interested in helping please read our contributing guide","title":"utPLSQL Project Details"},{"location":"about/support.html","text":"How to get support \u00b6 Feel free to post questions, bugs or issues in the issues area of GitHub Join developers at the utPLSQL team on Slack","title":"Support"},{"location":"about/support.html#how-to-get-support","text":"Feel free to post questions, bugs or issues in the issues area of GitHub Join developers at the utPLSQL team on Slack","title":"How to get support"},{"location":"userguide/advanced_data_comparison.html","text":"Advanced data comparison \u00b6 utPLSQL expectations incorporates advanced data comparison options when comparing compound data-types: refcursor object type nested table and varray Advanced data-comparison options are available for the equal matcher. Syntax \u00b6 ut.expect( a_actual {data-type} ).to_( equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]); ut.expect( a_actual {data-type} ).not_to( equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]) ); ut.expect( a_actual {data-type} ).to_equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]); ut.expect( a_actual {data-type} ).not_to_equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]] ); extended_option can be one of: include(a_items varchar2) - item or comma separated list of items to include exclude(a_items varchar2) - item or comma separated list of items to exclude include(a_items ut_varchar2_list) - table of items to include exclude(a_items ut_varchar2_list) - table of items to exclude unordered - perform compare on unordered set of data, return only missing or actual join_by(a_columns varchar2) - columns or comma seperated list of columns to join two cursors by join_by(a_columns ut_varchar2_list) - table of columns to join two cursors by Each item in the comma separated list can be: - a column name of cursor to be compared - an attribute name of object type to be compared - an attribute name of object type within a table of objects to be compared - an XPath expression representing column/attribute - Include and exclude option will not support implicit colum names that starts with single quota, or in fact any other special characters e.g. <, >, & Each element in ut_varchar2_list nested table can be an item or a comma separated list of items. When specifying column/attribute names, keep in mind that the names are case sensitive . XPath expressions with comma are not supported. Excluding elements from data comparison \u00b6 Consider the following example procedure test_cursors_skip_columns is l_expected sys_refcursor ; l_actual sys_refcursor ; begin open l_expected for select 'text' ignore_me , d . * from user_tables d ; open l_actual for select sysdate \"ADate\" , d . * from user_tables d ; ut . expect ( l_actual ). to_equal ( l_expected ). exclude ( 'IGNORE_ME,ADate' ); end ; Columns 'ignore_me' and \"ADate\" will get excluded from cursor comparison. The cursor data is equal, when those columns are excluded. This option is useful in scenarios, when you need to exclude incomparable/unpredictable column data like CREATE_DATE of a record that is maintained by default value on a table column. Selecting columns for data comparison \u00b6 Consider the following example procedure include_columns_as_csv is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL from dual a connect by level < 4 ; open l_actual for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL , a . * from all_objects a where rownum < 4 ; ut . expect ( l_actual ). to_equal ( l_expected ). include ( 'RN,A_Column,SOME_COL' ); end ; Combining include/exclude options \u00b6 You can chain the advanced options in an expectation and mix the varchar2 with ut_varchar2_list arguments. When doing so, the fianl list of items to include/exclude will be a concatenation of all items. procedure include_columns_as_csv is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL from dual a connect by level < 4 ; open l_actual for select rownum as rn , 'a' as \"A_Column\" , 'Y' SOME_COL , a . * from all_objects a where rownum < 4 ; ut . expect ( l_actual ). to_equal ( l_expected ) . include ( 'RN' ) . include ( ut_varchar2_list ( 'A_Column' , 'SOME_COL' ) ) . exclude ( 'SOME_COL' ); end ; Only the columns 'RN', \"A_Column\" will be compared. Column 'SOME_COL' is excluded. This option can be useful in scenarios where you need to narrow-down the scope of test so that the test is only focused on very specific data. Unordered \u00b6 Unordered option allows for quick comparison of two cursors without need of ordering them in any way. Result of such comparison will be limited to only information about row existing or not existing in given set without actual information about exact differences. procedure unordered_tst is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select username , user_id from all_users union all select 'TEST' username , - 600 user_id from dual order by 1 desc ; open l_actual for select username , user_id from all_users union all select 'TEST' username , - 610 user_id from dual order by 1 asc ; ut . expect ( l_actual ). to_equal ( l_expected ). unordered ; end ; Above test will result in two differences of one row extra and one row missing. Diff : Rows : [ 2 differences ] Missing : < ROW >< USERNAME > TEST </ USERNAME >< USER_ID >- 600 </ USER_ID ></ ROW > Extra : < ROW >< USERNAME > TEST </ USERNAME >< USER_ID >- 610 </ USER_ID ></ ROW > Join By option \u00b6 You can now join two cursors by defining a primary key or composite key that will be used to uniquely identify and compare rows. This option allows us to exactly show which rows are missing, extra and which are different without ordering clause. In the situation where the join key is not unique, join will partition set over rows with a same key and join on row number as well as given join key. The extra rows or missing will be presented to user as well as not matching rows. Join by option can be used in conjunction with include or exclude options. However if any of the join keys is part of exclude set, comparison will fail and report to user that sets could not be joined on specific key (excluded). procedure join_by_username is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select username , user_id from all_users union all select 'TEST' username , - 600 user_id from dual order by 1 desc ; open l_actual for select username , user_id from all_users union all select 'TEST' username , - 610 user_id from dual order by 1 asc ; ut . expect ( l_actual ). to_equal ( l_expected ). join_by ( 'USERNAME' ); end ; This will show you difference in row 'TEST' regardless of order. Rows : [ 1 differences ] PK < USERNAME > TEST </ USERNAME > - Expected : < USER_ID >- 600 </ USER_ID > PK < USERNAME > TEST </ USERNAME > - Actual : < USER_ID >- 610 </ USER_ID > Assumption is that join by is made by column name so that what will be displayed as part of results. Join by options currently doesn't support nested table inside cursor comparison, however is still possible to compare a collection as a whole. Example. procedure compare_collection_in_rec is l_actual sys_refcursor ; l_expected sys_refcursor ; l_actual_tab ut3 . ut_annotated_object ; l_expected_tab ut3 . ut_annotated_object ; l_expected_message varchar2 ( 32767 ); l_actual_message varchar2 ( 32767 ); begin select ut3 . ut_annotated_object ( 'TEST' , 'TEST' , 'TEST' , ut3 . ut_annotations ( ut3 . ut_annotation ( 1 , 'test' , 'test' , 'test' ), ut3 . ut_annotation ( 2 , 'test' , 'test' , 'test' )) ) into l_actual_tab from dual ; select ut3 . ut_annotated_object ( 'TEST' , 'TEST' , 'TEST' , ut3 . ut_annotations ( ut3 . ut_annotation ( 1 , 'test' , 'test' , 'test' ), ut3 . ut_annotation ( 2 , 'test' , 'test' , 'test' )) ) into l_expected_tab from dual ; --Arrange open l_actual for select l_actual_tab as nested_table from dual ; open l_expected for select l_expected_tab as nested_table from dual ; --Act ut3 . ut . expect ( l_actual ). to_equal ( l_expected ). join_by ( 'NESTED_TABLE/ANNOTATIONS' ); end ; In case when a there is detected collection inside cursor and we cannot join key. Comparison will present a failed joins and also a message about collection being detected. Actual : refcursor [ count = 1 ] was expected to equal : refcursor [ count = 1 ] Diff : Unable to join sets : Join key NESTED_TABLE / ANNOTATIONS / TEXT does not exists in expected Join key NESTED_TABLE / ANNOTATIONS / TEXT does not exists in actual Please make sure that your join clause is not refferring to collection element Please note that .join_by option will take longer to process due to need of parsing via primary keys. Defining item as XPath \u00b6 When using XPath expression, keep in mind the following: cursor columns are nested under <ROW> element object type attributes are nested under <OBJECTY_TYPE> element nested table and varray items type attributes are nested under <ARRAY><OBJECTY_TYPE> elements Example of a valid XPath parameter to include columns: RN , A_Column , SOME_COL in data comparison. procedure include_columns_as_xpath is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL from dual a connect by level < 4 ; open l_actual for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL , a . * from all_objects a where rownum < 4 ; ut . expect ( l_actual ). to_equal ( l_expected ). include ( '/ROW/RN|/ROW/A_Column|/ROW/SOME_COL' ); end ;","title":"Advanced data comparison"},{"location":"userguide/advanced_data_comparison.html#advanced-data-comparison","text":"utPLSQL expectations incorporates advanced data comparison options when comparing compound data-types: refcursor object type nested table and varray Advanced data-comparison options are available for the equal matcher.","title":"Advanced data comparison"},{"location":"userguide/advanced_data_comparison.html#syntax","text":"ut.expect( a_actual {data-type} ).to_( equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]); ut.expect( a_actual {data-type} ).not_to( equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]) ); ut.expect( a_actual {data-type} ).to_equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]]); ut.expect( a_actual {data-type} ).not_to_equal( a_expected {data-type})[.extendend_option()[.extendend_option()[...]]] ); extended_option can be one of: include(a_items varchar2) - item or comma separated list of items to include exclude(a_items varchar2) - item or comma separated list of items to exclude include(a_items ut_varchar2_list) - table of items to include exclude(a_items ut_varchar2_list) - table of items to exclude unordered - perform compare on unordered set of data, return only missing or actual join_by(a_columns varchar2) - columns or comma seperated list of columns to join two cursors by join_by(a_columns ut_varchar2_list) - table of columns to join two cursors by Each item in the comma separated list can be: - a column name of cursor to be compared - an attribute name of object type to be compared - an attribute name of object type within a table of objects to be compared - an XPath expression representing column/attribute - Include and exclude option will not support implicit colum names that starts with single quota, or in fact any other special characters e.g. <, >, & Each element in ut_varchar2_list nested table can be an item or a comma separated list of items. When specifying column/attribute names, keep in mind that the names are case sensitive . XPath expressions with comma are not supported.","title":"Syntax"},{"location":"userguide/advanced_data_comparison.html#excluding-elements-from-data-comparison","text":"Consider the following example procedure test_cursors_skip_columns is l_expected sys_refcursor ; l_actual sys_refcursor ; begin open l_expected for select 'text' ignore_me , d . * from user_tables d ; open l_actual for select sysdate \"ADate\" , d . * from user_tables d ; ut . expect ( l_actual ). to_equal ( l_expected ). exclude ( 'IGNORE_ME,ADate' ); end ; Columns 'ignore_me' and \"ADate\" will get excluded from cursor comparison. The cursor data is equal, when those columns are excluded. This option is useful in scenarios, when you need to exclude incomparable/unpredictable column data like CREATE_DATE of a record that is maintained by default value on a table column.","title":"Excluding elements from data comparison"},{"location":"userguide/advanced_data_comparison.html#selecting-columns-for-data-comparison","text":"Consider the following example procedure include_columns_as_csv is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL from dual a connect by level < 4 ; open l_actual for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL , a . * from all_objects a where rownum < 4 ; ut . expect ( l_actual ). to_equal ( l_expected ). include ( 'RN,A_Column,SOME_COL' ); end ;","title":"Selecting columns for data comparison"},{"location":"userguide/advanced_data_comparison.html#combining-includeexclude-options","text":"You can chain the advanced options in an expectation and mix the varchar2 with ut_varchar2_list arguments. When doing so, the fianl list of items to include/exclude will be a concatenation of all items. procedure include_columns_as_csv is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL from dual a connect by level < 4 ; open l_actual for select rownum as rn , 'a' as \"A_Column\" , 'Y' SOME_COL , a . * from all_objects a where rownum < 4 ; ut . expect ( l_actual ). to_equal ( l_expected ) . include ( 'RN' ) . include ( ut_varchar2_list ( 'A_Column' , 'SOME_COL' ) ) . exclude ( 'SOME_COL' ); end ; Only the columns 'RN', \"A_Column\" will be compared. Column 'SOME_COL' is excluded. This option can be useful in scenarios where you need to narrow-down the scope of test so that the test is only focused on very specific data.","title":"Combining include/exclude options"},{"location":"userguide/advanced_data_comparison.html#unordered","text":"Unordered option allows for quick comparison of two cursors without need of ordering them in any way. Result of such comparison will be limited to only information about row existing or not existing in given set without actual information about exact differences. procedure unordered_tst is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select username , user_id from all_users union all select 'TEST' username , - 600 user_id from dual order by 1 desc ; open l_actual for select username , user_id from all_users union all select 'TEST' username , - 610 user_id from dual order by 1 asc ; ut . expect ( l_actual ). to_equal ( l_expected ). unordered ; end ; Above test will result in two differences of one row extra and one row missing. Diff : Rows : [ 2 differences ] Missing : < ROW >< USERNAME > TEST </ USERNAME >< USER_ID >- 600 </ USER_ID ></ ROW > Extra : < ROW >< USERNAME > TEST </ USERNAME >< USER_ID >- 610 </ USER_ID ></ ROW >","title":"Unordered"},{"location":"userguide/advanced_data_comparison.html#join-by-option","text":"You can now join two cursors by defining a primary key or composite key that will be used to uniquely identify and compare rows. This option allows us to exactly show which rows are missing, extra and which are different without ordering clause. In the situation where the join key is not unique, join will partition set over rows with a same key and join on row number as well as given join key. The extra rows or missing will be presented to user as well as not matching rows. Join by option can be used in conjunction with include or exclude options. However if any of the join keys is part of exclude set, comparison will fail and report to user that sets could not be joined on specific key (excluded). procedure join_by_username is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select username , user_id from all_users union all select 'TEST' username , - 600 user_id from dual order by 1 desc ; open l_actual for select username , user_id from all_users union all select 'TEST' username , - 610 user_id from dual order by 1 asc ; ut . expect ( l_actual ). to_equal ( l_expected ). join_by ( 'USERNAME' ); end ; This will show you difference in row 'TEST' regardless of order. Rows : [ 1 differences ] PK < USERNAME > TEST </ USERNAME > - Expected : < USER_ID >- 600 </ USER_ID > PK < USERNAME > TEST </ USERNAME > - Actual : < USER_ID >- 610 </ USER_ID > Assumption is that join by is made by column name so that what will be displayed as part of results. Join by options currently doesn't support nested table inside cursor comparison, however is still possible to compare a collection as a whole. Example. procedure compare_collection_in_rec is l_actual sys_refcursor ; l_expected sys_refcursor ; l_actual_tab ut3 . ut_annotated_object ; l_expected_tab ut3 . ut_annotated_object ; l_expected_message varchar2 ( 32767 ); l_actual_message varchar2 ( 32767 ); begin select ut3 . ut_annotated_object ( 'TEST' , 'TEST' , 'TEST' , ut3 . ut_annotations ( ut3 . ut_annotation ( 1 , 'test' , 'test' , 'test' ), ut3 . ut_annotation ( 2 , 'test' , 'test' , 'test' )) ) into l_actual_tab from dual ; select ut3 . ut_annotated_object ( 'TEST' , 'TEST' , 'TEST' , ut3 . ut_annotations ( ut3 . ut_annotation ( 1 , 'test' , 'test' , 'test' ), ut3 . ut_annotation ( 2 , 'test' , 'test' , 'test' )) ) into l_expected_tab from dual ; --Arrange open l_actual for select l_actual_tab as nested_table from dual ; open l_expected for select l_expected_tab as nested_table from dual ; --Act ut3 . ut . expect ( l_actual ). to_equal ( l_expected ). join_by ( 'NESTED_TABLE/ANNOTATIONS' ); end ; In case when a there is detected collection inside cursor and we cannot join key. Comparison will present a failed joins and also a message about collection being detected. Actual : refcursor [ count = 1 ] was expected to equal : refcursor [ count = 1 ] Diff : Unable to join sets : Join key NESTED_TABLE / ANNOTATIONS / TEXT does not exists in expected Join key NESTED_TABLE / ANNOTATIONS / TEXT does not exists in actual Please make sure that your join clause is not refferring to collection element Please note that .join_by option will take longer to process due to need of parsing via primary keys.","title":"Join By option"},{"location":"userguide/advanced_data_comparison.html#defining-item-as-xpath","text":"When using XPath expression, keep in mind the following: cursor columns are nested under <ROW> element object type attributes are nested under <OBJECTY_TYPE> element nested table and varray items type attributes are nested under <ARRAY><OBJECTY_TYPE> elements Example of a valid XPath parameter to include columns: RN , A_Column , SOME_COL in data comparison. procedure include_columns_as_xpath is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL from dual a connect by level < 4 ; open l_actual for select rownum as rn , 'a' as \"A_Column\" , 'x' SOME_COL , a . * from all_objects a where rownum < 4 ; ut . expect ( l_actual ). to_equal ( l_expected ). include ( '/ROW/RN|/ROW/A_Column|/ROW/SOME_COL' ); end ;","title":"Defining item as XPath"},{"location":"userguide/annotations.html","text":"Annotations \u00b6 Annotations are used to configure tests and suites in a declarative way similar to modern OOP languages. This way, test configuration is stored along with the test logic inside the test package. No configuration files or tables are needed. The annotation names are based on popular testing frameworks such as JUnit. The framework runner searches for all the suitable annotated packages, automatically configures suites, forms the suite hierarchy, executes it and reports results in specified formats. Annotations are interpreted only in the package specification and are case-insensitive. We strongly recommend using lower-case annotations as described in this documentation. There are two distinct types of annotations, identified by their location in package: - Procedure level annotations - placed directly before a procedure ( --%test , --%beforeall , --%beforeeach etc.). - Package level annotations - placed at any place in package except directly before procedure ( --%suite , --%suitepath etc.). We strongly recommend putting package level annotations at the very top of package except for the --%context annotations (described below) Supported annotations \u00b6 Annotation Level Description --%suite(<description>) Package Mandatory. Marks package as a test suite. Optional suite description can be provided (see displayname ). --%suitepath(<path>) Package Similar to java package. The annotation allows logical grouping of suites into hierarchies. --%displayname(<description>) Package/procedure Human-readable and meaningful description of a suite/test. %displayname(Name of the suite/test) . The annotation is provided for flexibility and convenience only. It has exactly the same meaning as <description> in test and suite annotations. If description is provided using both suite / test and displayname , then the one defined as last takes precedence. --%test(<description>) Procedure Denotes that the annotated procedure is a unit test procedure. Optional test description can by provided (see displayname ). --%throws(<exception>[,...]) Procedure Denotes that the annotated test procedure must throw one of the exceptions provided. Supported forms of exceptions are: numeric literals, numeric contant names, exception constant names, predefined Oracle exception names. --%beforeall Procedure Denotes that the annotated procedure should be executed once before all elements of the suite. --%beforeall([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed once before all elements of the suite. --%afterall Procedure Denotes that the annotated procedure should be executed once after all elements of the suite. --%afterall([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed once after all elements of the suite. --%beforeeach Procedure Denotes that the annotated procedure should be executed before each %test procedure in the suite. --%beforeeach([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed before each %test procedure in the suite. --%aftereach Procedure Denotes that the annotated procedure should be executed after each %test procedure in the suite. --%aftereach([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed after each %test procedure in the suite. --%beforetest([[<owner>.]<package>.]<procedure>[,...]) Procedure Denotes that mentioned procedure(s) should be executed before the annotated %test procedure. --%aftertest([[<owner>.]<package>.]<procedure>[,...]) Procedure Denotes that mentioned procedure(s) should be executed after the annotated %test procedure. --%rollback(<type>) Package/procedure Defines transaction control. Supported values: auto (default) - a savepoint is created before invocation of each \"before block\" is and a rollback to specific savepoint is issued after each \"after\" block; manual - rollback is never issued automatically. Property can be overridden for child element (test in suite) --%disabled Package/procedure Used to disable a suite or a test. Disabled suites/tests do not get executed, they are however marked and reported as disabled in a test run. --%context(<name>) Package Denotes start of a named context (sub-suite) in a suite package --%endcontext Package Denotes end of a nested context (sub-suite) in a suite package Suite \u00b6 The --%suite annotation denotes PLSQL package as a unit test suite. It accepts an optional description that will be visible when running the tests. When description is not provided, package name is displayed on report. Note Package is considered a test-suite only when package specification contains the --%suite annotation at the package level. Some annotations like --%suite , --%test and --%displayname accept parameters. The parameters for annotations need to be placed in brackets. Values for parameters should be provided without any quotation marks. If the parameters are placed without brackets or with incomplete brackets, they will be ignored. Example: --%suite(The name of suite without closing bracket Example: --%suite The name of suite without brackets Suite package without description. create or replace package test_package as --%suite end ; / exec ut . run ( 'test_package' ); test_package Finished in .002415 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Suite package with description. create or replace package test_package as --%suite(Tests for a package) end ; / exec ut . run ( 'test_package' ); Tests for a package Finished in .001646 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) When multiple --%suite annotations are specified in package, the first annotation will be used and a warning message will appear indicating duplicate annotation. create or replace package test_package as --%suite(Tests for a package) --%suite(Bad annotation) end ; / exec ut . run ( 'test_package' ); Tests for a package Warnings: 1) test_package Duplicate annotation \"--%suite\". Annotation ignored. at \"TESTS_OWNER.TEST_PACKAGE\", line 3 Finished in .003318 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 1 warning(s) When --%suite annotation is bound to procedure, it is ignored and results in package not getting recognized as test suite. create or replace package test_package as --%suite(Tests for a package) procedure some_proc ; end ; / exec ut . run ( 'test_package' ); ORA-20204: Suite package TESTS_OWNER.test_package not found ORA-06512: at \"UT3.UT_RUNNER\", line 106 ORA-06512: at \"UT3.UT\", line 115 ORA-06512: at \"UT3.UT\", line 306 ORA-06512: at \"UT3.UT\", line 364 ORA-06512: at line 1 Test \u00b6 The --%test annotation denotes procedure withing test suite as a unit test. It accepts an optional description that will be reported when the test is executed. When description is not provided, procedure name is displayed on report. If --%test raises an unhandled exception the following will happen: - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite Test procedure without description. create or replace package test_package as --%suite(Tests for a package) --%test procedure some_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package some_test [.003 sec] Finished in .004109 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Test procedure with description. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.005 sec] Finished in .006828 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) When multiple --%test annotations are specified for a procedure, the first annotation will be used and a warning message will appear indicating duplicate annotation. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) --%test(Duplicate description) procedure some_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.007 sec] Warnings: 1) test_package Duplicate annotation \"--%test\". Annotation ignored. at \"TESTS_OWNER.TEST_PACKAGE.SOME_TEST\", line 5 Finished in .008815 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 1 warning(s) Disabled \u00b6 Marks annotated suite package or test procedure as disabled. Disabling suite. create or replace package test_package as --%suite(Tests for a package) --%disabled --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [0 sec] (DISABLED) Description of another behavior [0 sec] (DISABLED) Finished in .001441 seconds 2 tests, 0 failed, 0 errored, 2 disabled, 0 warning(s) Disabling individual test(s). create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) --%disabled procedure other_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.004 sec] Description of another behavior [0 sec] (DISABLED) Finished in .005868 seconds 2 tests, 0 failed, 0 errored, 1 disabled, 0 warning(s) Beforeall \u00b6 There are two possible ways to use the --%beforeall annotation. As a procedure level annotation: --%suite(Some test suite) --%beforeall procedure to_be_executed_before_all ; --%test procedure some_test ; Marks annotated procedure to be executed before all test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%beforeall(to_be_executed_before_all, other_package.some_setup) --%test procedure some_test ; procedure to_be_executed_before_all ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed before all test procedures in a suite. If --%beforeall raises an exception, suite content cannot be safely executed as the setup was not executed successfully for the suite. If --%beforeall raises an exception the following will happen: - the --%beforeall procedures that follow the failed one, will not be executed - all --%test procedures and their --%beforeeach , --%aftereach , --%beforetest and --%aftertest procedures within suite package will not be executed - all --%test procedures will be marked as failed - the --%afterall procedures will be executed - test execution will continue uninterrupted for other suite packages When multiple --%beforeall procedures are defined in a suite package, all of them will be executed before invoking any test. For multiple --%beforeall procedures order of execution is defined by annotation position in the package specification. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%beforeall procedure setup_stuff ; end ; / create or replace package body test_package as procedure setup_stuff is begin dbms_output . put_line ( '--- SETUP_STUFF invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package --- SETUP_STUFF invoked --- Description of tested behavior [.004 sec] Description of another behavior [.003 sec] Finished in .012292 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) In the below example a combination pacakge and procedure level --%beforeall annotations is used. The order of execution of the beforeall procedures is determined by the annotation position in package. All of the --%beforeall procedures get invoked before any test is executed in a suite. create or replace package test_package as --%suite(Tests for a package) --%beforeall(initial_setup,test_package.another_setup) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%beforeall procedure next_setup ; --%beforeall(one_more_setup) procedure another_setup ; procedure one_more_setup ; procedure initial_setup ; end ; / create or replace package body test_package as procedure one_more_setup is begin dbms_output . put_line ( '--- ONE_MORE_SETUP invoked ---' ); end ; procedure next_setup is begin dbms_output . put_line ( '--- NEXT_SETUP invoked ---' ); end ; procedure another_setup is begin dbms_output . put_line ( '--- ANOTHER_SETUP invoked ---' ); end ; procedure initial_setup is begin dbms_output . put_line ( '--- INITIAL_SETUP invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); ``` Tests for a package --- INITIAL_SETUP invoked --- --- ANOTHER_SETUP invoked --- --- NEXT_SETUP invoked --- --- ONE_MORE_SETUP invoked --- Description of tested behavior [.003 sec] Description of another behavior [.002 sec] Finished in .018944 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) ``` When multiple --%beforeall annotations are specified for a procedure, the first annotation will be used and a warning message will appear indicating duplicate annotation. When procedure is annotated as both --%beforeall and --%test , the procedure will become a test and a warning message will appear indicating invalid annotation combination. create or replace package test_package as --%suite(Tests for a package) --%beforeall --%beforeall procedure initial_setup ; --%test(Description of tested behavior) --%beforeall procedure some_test ; --%test(Description of another behavior) procedure other_test ; end ; / create or replace package body test_package as procedure initial_setup is begin dbms_output . put_line ( '--- INITIAL_SETUP invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); ``` Tests for a package --- INITIAL_SETUP invoked --- Description of tested behavior [.003 sec] Description of another behavior [.004 sec] Warnings: 1) test_package Duplicate annotation \"--%beforeall\". Annotation ignored. at \"UT3_TESTER.TEST_PACKAGE.INITIAL_SETUP\", line 5 2) test_package Annotation \"--%beforeall\" cannot be used with annotation: \"--%test\" at \"UT3_TESTER.TEST_PACKAGE.SOME_TEST\", line 9 Finished in .012158 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 2 warning(s) ``` Afterall \u00b6 There are two possible ways to use the --%afterall annotation. As a procedure level annotation: --%suite(Some test suite) --%afterall procedure to_be_executed_after_all ; --%test procedure some_test ; Marks annotated procedure to be executed after all test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%afterall(to_be_executed_after_all, other_package.some_cleanup) --%test procedure some_test ; procedure to_be_executed_after_all ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed after all test procedures in a suite. If --%afterall raises an exception the following will happen: - a warning will be raised, indicating that --%afterall procedure has failed - execution will continue uninterrupted for rest of the suite If --%afterall raises an exception, it can have negative impact on other tests, as the environment was not cleaned-up after the tests. This however doesn't have direct impact on test execution within current suite, as the tests are already complete by the time --%afterall is called. When multiple --%afterall procedures are defined in a suite, all of them will be executed after invoking all tests from the suite. For multiple --%afterall procedures order of execution is defined by annotation position in the package specification. All rules defined for --%beforeall also apply for --%afterall annotation. See beforeall for more details. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%afterall procedure cleanup_stuff ; end ; / create or replace package body test_package as procedure cleanup_stuff is begin dbms_output . put_line ( '---CLEANUP_STUFF invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.003 sec] Description of another behavior [.005 sec] ---CLEANUP_STUFF invoked --- Finished in .014161 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Beforeeach \u00b6 The procedure annotated as --%beforeeach is getting executed before each test in a suite. That means that the procedure will be executed as many times as there are test in suite package. There are two possible ways to use the --%beforeeach annotation. As a procedure level annotation: --%suite(Some test suite) --%beforeeach procedure to_be_executed_before_each ; --%test procedure some_test ; Marks annotated procedure to be executed before each test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%beforeeach(to_be_executed_before_each, other_package.some_setup) --%test procedure some_test ; procedure to_be_executed_before_each ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed before each test procedure in a suite. If a test is marked as disabled the --%beforeeach procedure is not invoked for that test. If --%beforeeach raises an unhandled exception the following will happen: - the following --%beforeeach as well as all --%beforetest for that test will not be executed - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite As a rule, the --%beforeeach execution gets aborted if preceding --%beforeeach failed. When multiple --%beforeeach procedures are defined in a suite, all of them will be executed before invoking each test. For multiple --%beforeeach procedures order of execution is defined by annotation position in the package specification. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%beforeeach procedure setup_for_test ; --%beforeall procedure setup_stuff ; end ; / create or replace package body test_package as procedure setup_stuff is begin dbms_output . put_line ( '---SETUP_STUFF invoked ---' ); end ; procedure setup_for_test is begin dbms_output . put_line ( '---SETUP_FOR_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package ---SETUP_STUFF invoked --- Description of tested behavior [.004 sec] ---SETUP_FOR_TEST invoked --- ---SOME_TEST invoked --- Description of another behavior [.006 sec] ---SETUP_FOR_TEST invoked --- ---OTHER_TEST invoked --- Finished in .014683 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) See beforeall for more examples. Aftereach \u00b6 Marks annotated procedure to be executed after each test procedure in a suite. The procedure annotated as --%aftereach is getting executed after each test in a suite. That means that the procedure will be executed as many times as there are test in suite package. There are two possible ways to use the --%aftereach annotation. As a procedure level annotation: --%suite(Some test suite) --%aftereach procedure to_be_executed_after_each ; --%test procedure some_test ; Marks annotated procedure to be executed after each test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%aftereach(to_be_executed_after_each, other_package.some_setup) --%test procedure some_test ; procedure to_be_executed_after_each ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed after each test procedure in a suite. If a test is marked as disabled the --%aftereach procedure is not invoked for that test. If --%aftereach raises an unhandled exception the following will happen: - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite When multiple --%aftereach procedures are defined in a suite, all of them will be executed after invoking each test. For multiple --%aftereach procedures order of execution is defined by the annotation position in the package specification. As a rule, the --%aftereach gets executed even if the associated --%beforeeach , --%beforetest , --%test or other --%aftereach procedures have raised unhandled exceptions. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%aftereach procedure cleanup_for_test ; --%afterall procedure cleanup_stuff ; end ; / create or replace package body test_package as procedure cleanup_stuff is begin dbms_output . put_line ( '---CLEANUP_STUFF invoked ---' ); end ; procedure cleanup_for_test is begin dbms_output . put_line ( '---CLEANUP_FOR_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.006 sec] ---SOME_TEST invoked --- ---CLEANUP_FOR_TEST invoked --- Description of another behavior [.006 sec] ---OTHER_TEST invoked --- ---CLEANUP_FOR_TEST invoked --- ---CLEANUP_STUFF invoked --- Finished in .018115 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) See beforeall for more examples. Beforetest \u00b6 Indicates specific setup procedure(s) to be executed for a test. The procedure(s) can be located either: - within current package (package name is optional) - within another package The annotation need to be placed alongside --%test annotation. The --%beforetest procedures are executed after invoking all --%beforeeach for a test. If a test is marked as disabled the --%beforetest procedures are not invoked for that test. If --%beforetest raises an unhandled exception the following will happen: - the following --%beforetest for that test will not be executed - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite When multiple --%beforetest procedures are defined for a test, all of them will be executed before invoking the test. The order of execution for --%beforetest procedures is defined by: - position of procedure on the list within single annotation - annotation position As a rule, the --%beforetest execution gets aborted if preceding --%beforeeach or --%beforetest failed. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) --%beforetest(test_package.setup_for_a_test) --%beforetest(another_setup_for_a_test) procedure some_test ; --%test(Description of another behavior) --%beforetest(test_package.setup_for_a_test, another_setup_for_a_test) procedure other_test ; procedure another_setup_for_a_test ; procedure setup_for_a_test ; end ; / create or replace package body test_package as procedure setup_for_a_test is begin dbms_output . put_line ( '---SETUP_FOR_A_TEST invoked ---' ); end ; procedure another_setup_for_a_test is begin dbms_output . put_line ( '---ANOTHER_SETUP_FOR_A_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.008 sec] ---SETUP_FOR_A_TEST invoked --- ---ANOTHER_SETUP_FOR_A_TEST invoked --- ---SOME_TEST invoked --- Description of another behavior [.005 sec] ---SETUP_FOR_A_TEST invoked --- ---ANOTHER_SETUP_FOR_A_TEST invoked --- ---OTHER_TEST invoked --- Finished in .015185 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Aftertest \u00b6 Indicates specific cleanup procedure(s) to be executed for a test. The procedure(s) can be located either: - within current package (package name is optional) - within another package The annotation need to be placed alongside --%test annotation. If a test is marked as disabled the --%aftertest procedures are not invoked for that test. If --%aftertest raises an unhandled exception the following will happen: - the test will be marked as errored and exception stack trace will be captured and reported - the following --%aftertest and all --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite When multiple --%aftertest procedures are defined for a test, all of them will be executed before invoking the test. The order of execution for --%aftertest procedures is defined by: - position of procedure on the list within single annotation - annotation position As a rule, the --%aftertest gets executed even if the associated --%beforeeach , --%beforetest , --%test or other --%aftertest procedures have raised unhandled exceptions. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) --%aftertest(test_package.cleanup_for_a_test) --%aftertest(another_cleanup_for_a_test) procedure some_test ; --%test(Description of another behavior) --%aftertest(test_package.cleanup_for_a_test, another_cleanup_for_a_test) procedure other_test ; procedure another_cleanup_for_a_test ; procedure cleanup_for_a_test ; end ; / create or replace package body test_package as procedure cleanup_for_a_test is begin dbms_output . put_line ( '---CLEANUP_FOR_A_TEST invoked ---' ); end ; procedure another_cleanup_for_a_test is begin dbms_output . put_line ( '---ANOTHER_CLEANUP_FOR_A_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.008 sec] ---SOME_TEST invoked --- ---CLEANUP_FOR_A_TEST invoked --- ---ANOTHER_CLEANUP_FOR_A_TEST invoked --- Description of another behavior [.006 sec] ---OTHER_TEST invoked --- ---CLEANUP_FOR_A_TEST invoked --- ---ANOTHER_CLEANUP_FOR_A_TEST invoked --- Finished in .016873 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Context \u00b6 In most of the cases, the code to be tested is consisting of PLSQL packages containing procedures and functions. When creating test suites, it's quite common to maintain one to one relationship between test suite packages and tested code. When it comes to test procedures themselves, it is best practice to have one test procedure for one tested behavior of the code that is tested. The relationship between test procedure and tested procedure/function will be therefore many to one in most of the cases. With this comes a challenge. How to group tests, related to one tested procedure, so that it is obvious that they relate to the same code. This is where utPLSQL contexts come handy. Contexts allow for creating sub-suites within a suite package and they allow for grouping of tests that are somehow related. In essence, context behaves like a suite within a suite. Context have following characteristics: - start with the --%context annotation and ends with --%endcontext - can have a name provided as parameter for example --%context(remove_rooms_by_name) - when no name is provided for context, the context is names context_N where N is the number of the context in suite - can have their own --%beforeall , --%beforeeach , --%afterall and --%aftereach procedures - --%beforeall , --%beforeeach , --%afterall and --%aftereach procedures defined at suite level, propagate to context - test suite package can have multiple contexts in it - contexts cannot be nested The below example illustrates usage of --%context for separating tests for individual procedures of package. Tested tables and code create table rooms ( room_key number primary key , name varchar2 ( 100 ) not null ); create table room_contents ( contents_key number primary key , room_key number not null , name varchar2 ( 100 ) not null , create_date timestamp default current_timestamp not null , constraint fk_rooms foreign key ( room_key ) references rooms ( room_key ) ); create or replace package rooms_management is procedure remove_rooms_by_name ( a_name rooms . name % type ); procedure add_rooms_content ( a_room_name rooms . name % type , a_content_name room_contents . name % type ); end ; / create or replace package body rooms_management is procedure remove_rooms_by_name ( a_name rooms . name % type ) is begin if a_name is null then raise program_error ; end if ; delete from rooms where name like a_name ; end ; procedure add_rooms_content ( a_room_name rooms . name % type , a_content_name room_contents . name % type ) is l_room_key rooms . room_key % type ; begin select room_key into l_room_key from rooms where name = a_room_name ; insert into room_contents ( contents_key , room_key , name ) select nvl ( max ( contents_key ) + 1 , 1 ) as contents_key , l_room_key , a_content_name from room_contents ; end ; end ; / Below test suite defines: - --%beforeall outside of context, that will be executed before all tests - --%context(remove_rooms_by_name) to group tests for remove_rooms_by_name procedure - --%context(add_rooms_content) to group tests for add_rooms_content procedure create or replace package test_rooms_management is gc_null_value_exception constant integer : = - 1400 ; --%suite(Rooms management) --%beforeall procedure setup_rooms ; --%context(remove_rooms_by_name) --%description(Remove rooms by name) --%test(Removes a room without content in it) procedure remove_empty_room ; --%test(Raises exception when null room name given) --%throws(-6501) procedure null_room_name ; --%endcontext --%context(add_rooms_content) --%description(Add content to a room) --%test(Fails when room name is not valid) --%throws(no_data_found) procedure fails_on_room_name_invalid ; --%test(Fails when content name is null) --%throws(gc_null_value_exception) procedure fails_on_content_null ; --%test(Adds a content to existing room) procedure add_content_success ; --%endcontext end ; / create or replace package body test_rooms_management is procedure setup_rooms is begin insert all into rooms values ( 1 , 'Dining Room' ) into rooms values ( 2 , 'Living Room' ) into rooms values ( 3 , 'Bathroom' ) select 1 from dual ; insert all into room_contents values ( 1 , 1 , 'Table' , sysdate ) into room_contents values ( 3 , 1 , 'Chair' , sysdate ) into room_contents values ( 4 , 2 , 'Sofa' , sysdate ) into room_contents values ( 5 , 2 , 'Lamp' , sysdate ) select 1 from dual ; dbms_output . put_line ( '---SETUP_ROOMS invoked ---' ); end ; procedure remove_empty_room is l_rooms_not_named_b sys_refcursor ; l_remaining_rooms sys_refcursor ; begin open l_rooms_not_named_b for select * from rooms where name not like 'B%' ; remove_rooms_by_name ( 'B%' ); open l_remaining_rooms for select * from rooms ; ut . expect ( l_remaining_rooms ). to_equal ( l_rooms_not_named_b ); end ; procedure room_with_content is begin remove_rooms_by_name ( 'Living Room' ); end ; procedure null_room_name is begin remove_rooms_by_name ( NULL ); end ; procedure fails_on_room_name_invalid is begin add_rooms_content ( 'bad room name' , 'Chair' ); end ; procedure fails_on_content_null is begin --Act add_rooms_content ( 'Dining Room' , null ); --Assert done by --%throws annotation end ; procedure add_content_success is l_expected room_contents . name % type ; l_actual room_contents . name % type ; begin --Arrange l_expected : = 'Table' ; --Act add_rooms_content ( 'Dining Room' , l_expected ); --Assert select name into l_actual from room_contents where contents_key = ( select max ( contents_key ) from room_contents ); ut . expect ( l_actual ). to_equal ( l_expected ); end ; end ; / When te tests are executed exec ut . run ( 'test_package' ); The following report is displayed Rooms management ---SETUP_ROOMS invoked --- remove_rooms_by_name Removes a room without content in it [.015 sec] Raises exception when null room name given [.002 sec] add_rooms_content Fails when room name is not valid [.003 sec] Fails when content name is null [.003 sec] Adds a content to existing room [.003 sec] Finished in .035261 seconds 5 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Suitepath \u00b6 It is very likely that the application for which you are going to introduce tests consists of many different packages, procedures and functions. Usually procedures can be logically grouped inside a package, there also might be several logical groups of procedures in a single package and packages might be grouped into modules and modules into subject areas. As your project grows, the codebase will grow to. utPLSQL allows you to group packages into modules and also allows for nesting modules. Let's say you have a complex insurance application that deals with policies, claims and payments. The payment module contains several packages for payment recognition, charging, planning etc. The payment recognition module among others contains a complex recognize_payment procedure that associates received money to the policies. If you want to create tests for your application it is recommended to structure your tests similarly to the logical structure of your application. So you end up with something like: * Integration tests * Policy tests * Claim tests * Payment tests * Payments recognition * Payments set off The %suitepath annotation is used for such grouping. Even though test packages are defined in a flat structure the %suitepath is used by the framework to form them into a hierarchical structure. Your payments recognition test package might look like: create or replace package test_payment_recognition as --%suite(Payment recognition tests) --%suitepath(payments) --%test(Recognize payment by policy number) procedure test_recognize_by_num ; --%test(Recognize payment by payment purpose) procedure test_recognize_by_purpose ; --%test(Recognize payment by customer) procedure test_recognize_by_customer ; end test_payment_recognition ; And payments set off test package: create or replace package test_payment_set_off as --%suite(Payment set off tests) --%suitepath(payments) --%test(Creates set off) procedure test_create_set_off ; --%test(Cancels set off) procedure test_cancel_set_off ; end test_payment_set_off ; When you execute tests for your application, the framework constructs a test suite for each test package. Then it combines suites into grouping suites by the %suitepath annotation value so that the fully qualified path to the recognize_by_num procedure is USER:payments.test_payment_recognition.test_recognize_by_num . If any of its expectations fails then the test is marked as failed, also the test_payment_recognition suite, the parent suite payments and the whole run is marked as failed. The test report indicates which expectation has failed on the payments module. The payments recognition submodule is causing the failure as recognize_by_num has not met the expectations of the test. Grouping tests into modules and submodules using the %suitepath annotation allows you to logically organize your project's flat structure of packages into functional groups. An additional advantage of such grouping is the fact that every element level of the grouping can be an actual unit test package containing a common module level setup for all of the submodules. So in addition to the packages mentioned above you could have the following package. create or replace package payments as --%suite(Payments) --%beforeall procedure set_common_payments_data ; --%afterall procedure reset_common_paymnets_data ; end payments ; A %suitepath can be provided in three ways: * schema - execute all tests in the schema * [schema]:suite1[.suite2][.suite3]...[.procedure] - execute all tests in all suites from suite1[.suite2][.suite3]...[.procedure] path. If schema is not provided, then the current schema is used. Example: :all.rooms_tests * [schema.]package[.procedure] - execute all tests in the specified test package. The whole hierarchy of suites in the schema is built before all before/after hooks or part suites for the provided suite package are executed as well. Example: tests.test_contact.test_last_name_validator or simply test_contact.test_last_name_validator if tests is the current schema. Rollback \u00b6 By default, changes performed by every setup, cleanup and test procedure are isolated by savepoints. This solution is suitable for use-cases where the code that is being tested as well as the unit tests themselves do not use transaction control (commit/rollback) or DDL commands. In general, your unit tests should not use transaction control as long as the code you are testing is not using it too. Keeping the transactions uncommitted allows your changes to be isolated and the execution of tests does not impact others who might be using a shared development database. If you are in a situation where the code you are testing uses transaction control (common case with ETL code), then your tests probably should not use the default automatic transaction control. In that case use the annotation --%rollback(manual) on the suite level to disable automatic transaction control for the entire suite. If you are using nested suites, you need to make sure that the entire suite all the way to the root is using manual transaction control. It is possible with utPLSQL to change the transaction control on individual suites or tests that are part of complex suite. It is strongly recommended not to have mixed transaction control in a suite. Mixed transaction control settings will not work properly when your suites are using shared setup/cleanup with beforeall, afterall, beforeeach or aftereach annotations. Your suite will most likely fail with error or warning on execution. Some of the automatic rollbacks will probably fail to execute depending on the configuration you have. In some cases it is necessary to perform DDL as part of setup or cleanup for the tests. It is recommended to move such DDL statements to a procedure with pragma autonomous_transaction to eliminate implicit commits in the main session that is executing all your tests. Doing so allows your tests to use the framework's automatic transaction control and releases you from the burden of manual cleanup of data that was created or modified by test execution. When you are testing code that performs explicit or implicit commits, you may set the test procedure to run as an autonomous transaction with pragma autonomous_transaction . Keep in mind that when your test runs as autonomous transaction it will not see the data prepared in a setup procedure unless the setup procedure committed the changes. Note The --%suitepath annotation, when used, must be provided with a value of path. The path in suitepath cannot contain spaces. Dot (.) identifies individual elements of the path. Example: --%suitepath(org.utplsql.core.utils) Throws \u00b6 The --%throws annotation allows you to specify a list of exceptions as one of: - number literals - example --%throws(-20134) - variables of type exception defined in a package specification - example --%throws(exc_pkg.c_exception_No_variable) - variables of type number defined in a package specification - example --%throws(exc_pkg.c_some_exception) - predefined oracle exceptions - example --%throws(no_data_found) The annotation is ignored, when no valid arguments are provided. Examples of invalid annotations --%throws() , --%throws , --%throws(abe, 723pf) . If --%throws annotation is specified with arguments and no exception is raised, the test is marked as failed. If --%throws annotation is specified with arguments and exception raised is not on the list of provided exceptions, the test is marked as failed. The framework will raise a warning, when --%throws annotation has invalid arguments or when no arguments were provided. Annotation --%throws(7894562, operaqk, -=1, -20496, pow74d, posdfk3) will be interpreted as --%throws(-20496) . Please note that NO_DATA_FOUND exception is a special case in Oracle. To capture it use NO_DATA_FOUND named exception or -1403 exception No. Example: create or replace package exc_pkg is c_e_option1 constant number : = - 20200 ; c_e_option2 constant varchar2 ( 10 ) : = '-20201' ; c_e_option3 number : = - 20202 ; e_option4 exception ; pragma exception_init ( e_option4 , - 20203 ); end ; / create or replace package example_pgk as --%suite(Example Throws Annotation) --%test(Throws one of the listed exceptions) --%throws(-20145,bad,-20146, -20189 ,-20563) procedure raised_one_listed_exception ; --%test(Throws different exception than expected) --%throws(-20144) procedure raised_different_exception ; --%test(Throws different exception than listed) --%throws(-20144,-00001,-20145) procedure raised_unlisted_exception ; --%test(Gives failure when an exception is expected and nothing is thrown) --%throws(-20459, -20136, -20145) procedure nothing_thrown ; --%test(Throws package exception option1) --%throws(exc_pkg.c_e_option1) procedure raised_option1_exception ; --%test(Throws package exception option2) --%throws(exc_pkg.c_e_option2) procedure raised_option2_exception ; --%test(Throws package exception option3) --%throws(exc_pkg.c_e_option3) procedure raised_option3_exception ; --%test(Throws package exception option4) --%throws(exc_pkg.e_option4) procedure raised_option4_exception ; --%test(Raise name exception) --%throws(DUP_VAL_ON_INDEX) procedure raise_named_exc ; --%test(Invalid throws annotation) --%throws procedure bad_throws_annotation ; end ; / create or replace package body example_pgk is procedure raised_one_listed_exception is begin raise_application_error ( - 20189 , 'Test error' ); end ; procedure raised_different_exception is begin raise_application_error ( - 20143 , 'Test error' ); end ; procedure raised_unlisted_exception is begin raise_application_error ( - 20143 , 'Test error' ); end ; procedure nothing_thrown is begin ut . expect ( 1 ). to_equal ( 1 ); end ; procedure raised_option1_exception is begin raise_application_error ( exc_pkg . c_e_option1 , 'Test error' ); end ; procedure raised_option2_exception is begin raise_application_error ( exc_pkg . c_e_option2 , 'Test error' ); end ; procedure raised_option3_exception is begin raise_application_error ( exc_pkg . c_e_option3 , 'Test error' ); end ; procedure raised_option4_exception is begin raise exc_pkg . e_option4 ; end ; procedure raise_named_exc is begin raise DUP_VAL_ON_INDEX ; end ; procedure bad_throws_annotation is begin null ; end ; end ; / exec ut3 . ut . run ( 'example_pgk' ); Running the test will give report: Example Throws Annotation Throws one of the listed exceptions [.002 sec] Throws different exception than expected [.002 sec] (FAILED - 1) Throws different exception than listed [.003 sec] (FAILED - 2) Gives failure when an exception is expected and nothing is thrown [.002 sec] (FAILED - 3) Throws package exception option1 [.003 sec] Throws package exception option2 [.002 sec] Throws package exception option3 [.002 sec] Throws package exception option4 [.002 sec] Raise name exception [.002 sec] Invalid throws annotation [.002 sec] Failures: 1) raised_different_exception Actual: -20143 was expected to equal: -20144 ORA-20143: Test error ORA-06512: at \"UT3.EXAMPLE_PGK\", line 9 ORA-06512: at \"UT3.EXAMPLE_PGK\", line 9 ORA-06512: at line 6 2) raised_unlisted_exception Actual: -20143 was expected to be one of: (-20144, -1, -20145) ORA-20143: Test error ORA-06512: at \"UT3.EXAMPLE_PGK\", line 14 ORA-06512: at \"UT3.EXAMPLE_PGK\", line 14 ORA-06512: at line 6 3) nothing_thrown Expected one of exceptions (-20459, -20136, -20145) but nothing was raised. Warnings: 1) example_pgk Invalid parameter value \"bad\" for \"--%throws\" annotation. Parameter ignored. at \"UT3.EXAMPLE_PGK.RAISED_ONE_LISTED_EXCEPTION\", line 6 2) example_pgk \"--%throws\" annotation requires a parameter. Annotation ignored. at \"UT3.EXAMPLE_PGK.BAD_THROWS_ANNOTATION\", line 42 Finished in .025784 seconds 10 tests, 3 failed, 0 errored, 0 disabled, 2 warning(s) Order of execution \u00b6 create or replace package test_employee_pkg is --%suite(Employee management) --%suitepath(com.my_company.hr) --%rollback(auto) --%beforeall procedure setup_employees ; --%beforeall procedure setup_departments ; --%afterall procedure cleanup_log_table ; --%context(add_employee) --%beforeeach procedure setup_for_add_employees ; --%test(Raises exception when employee already exists) --%throws(-20145) procedure add_existing_employee ; --%test(Inserts employee to emp table) procedure add_employee ; --%endcontext --%context(remove_employee) --%beforeall procedure setup_for_remove_employee ; --%test(Removed employee from emp table) procedure del_employee ; --%endcontext --%test(Test without context) --%beforetest(setup_another_test) --%aftertest(cleanup_another_test) procedure some_test ; --%test(Name of test) --%disabled procedure disabled_test ; --%test(Name of test) --%rollback(manual) procedure no_transaction_control_test ; procedure setup_another_test ; procedure cleanup_another_test ; --%beforeeach procedure set_session_context ; --%aftereach procedure cleanup_session_context ; end test_employee_pkg ; When processing the test suite test_employee_pkg defined in Example of annotated test package , the order of execution will be as follows. create a savepoint 'before-suite' execute setup_employees (--%beforeall) execute setup_departments (--%beforeall) create a savepoint 'before-context' create savepoint 'before-test' execute test_setup (--%beforeeach) execute setup_for_add_employees (--%beforeeach from context) execute add_existing_employee (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' create savepoint 'before-test' (--%suite) execute test_setup (--%beforeeach) execute setup_for_add_employees (--%beforeeach from context) execute add_employee (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' rollback to savepoint 'before-context' create a savepoint 'before-context' execute setup_for_remove_employee (--%beforeall from context) create savepoint 'before-test' execute test_setup (--%beforeeach) execute add_existing_employee (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' rollback to savepoint 'before-context' create savepoint 'before-test' execute test_setup (--%beforeeach) execute some_test (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' create savepoint 'before-test' execute test_setup (--%beforeeach) execute setup_another_test (--%beforetest) execute another_test (--%test) execute cleanup_another_test (--%aftertest) execute test_cleanup (--%beforeeach) rollback to savepoint 'before-test' mark disabled_test as disabled (--%test --%disabled) execute test_setup (--%beforeeach) execute no_transaction_control_test (--%test) execute test_cleanup (--%aftertest) execute global_cleanup (--%afterall) rollback to savepoint 'before-suite' Note utPLSQL does not guarantee ordering of tests in suite. On contrary utPLSQL might give random order of tests/contexts in suite. Order of execution within multiple occurrences of before / after procedures is determined by the order of annotations in specific block (context/suite) of package specification. Annotation cache \u00b6 utPLSQL needs to scan the source of package specifications to identify and parse annotations. To improve framework startup time, especially when dealing with database users owning large amounts of packages, the framework has a built-in persistent cache for annotations. The annotation cache is checked for staleness and refreshed automatically on every run. The initial startup of utPLSQL for a schema will take longer than consecutive executions. If you are in a situation where your database is controlled via CI/CD server and is refreshed/wiped before each run of your tests, consider building the annotation cache upfront and taking a snapshot of the database after the cache has been refreshed. To build the annotation cache without actually invoking any tests, call ut_runner.rebuild_annotation_cache(a_object_owner) for every unit test owner for which you want to have the annotation cache prebuilt. Example: exec ut_runner . rebuild_annotation_cache ( 'HR' ); To purge the annotation cache call ut_runner.purge_cache(a_object_owner, a_object_type) . Both parameters are optional and if not provided, all owners/object_types will be purged. Example: exec ut_runner . purge_cache ( 'HR' , 'PACKAGE' );","title":"Annotations"},{"location":"userguide/annotations.html#annotations","text":"Annotations are used to configure tests and suites in a declarative way similar to modern OOP languages. This way, test configuration is stored along with the test logic inside the test package. No configuration files or tables are needed. The annotation names are based on popular testing frameworks such as JUnit. The framework runner searches for all the suitable annotated packages, automatically configures suites, forms the suite hierarchy, executes it and reports results in specified formats. Annotations are interpreted only in the package specification and are case-insensitive. We strongly recommend using lower-case annotations as described in this documentation. There are two distinct types of annotations, identified by their location in package: - Procedure level annotations - placed directly before a procedure ( --%test , --%beforeall , --%beforeeach etc.). - Package level annotations - placed at any place in package except directly before procedure ( --%suite , --%suitepath etc.). We strongly recommend putting package level annotations at the very top of package except for the --%context annotations (described below)","title":"Annotations"},{"location":"userguide/annotations.html#supported-annotations","text":"Annotation Level Description --%suite(<description>) Package Mandatory. Marks package as a test suite. Optional suite description can be provided (see displayname ). --%suitepath(<path>) Package Similar to java package. The annotation allows logical grouping of suites into hierarchies. --%displayname(<description>) Package/procedure Human-readable and meaningful description of a suite/test. %displayname(Name of the suite/test) . The annotation is provided for flexibility and convenience only. It has exactly the same meaning as <description> in test and suite annotations. If description is provided using both suite / test and displayname , then the one defined as last takes precedence. --%test(<description>) Procedure Denotes that the annotated procedure is a unit test procedure. Optional test description can by provided (see displayname ). --%throws(<exception>[,...]) Procedure Denotes that the annotated test procedure must throw one of the exceptions provided. Supported forms of exceptions are: numeric literals, numeric contant names, exception constant names, predefined Oracle exception names. --%beforeall Procedure Denotes that the annotated procedure should be executed once before all elements of the suite. --%beforeall([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed once before all elements of the suite. --%afterall Procedure Denotes that the annotated procedure should be executed once after all elements of the suite. --%afterall([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed once after all elements of the suite. --%beforeeach Procedure Denotes that the annotated procedure should be executed before each %test procedure in the suite. --%beforeeach([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed before each %test procedure in the suite. --%aftereach Procedure Denotes that the annotated procedure should be executed after each %test procedure in the suite. --%aftereach([[<owner>.]<package>.]<procedure>[,...]) Package Denotes that the mentioned procedure(s) should be executed after each %test procedure in the suite. --%beforetest([[<owner>.]<package>.]<procedure>[,...]) Procedure Denotes that mentioned procedure(s) should be executed before the annotated %test procedure. --%aftertest([[<owner>.]<package>.]<procedure>[,...]) Procedure Denotes that mentioned procedure(s) should be executed after the annotated %test procedure. --%rollback(<type>) Package/procedure Defines transaction control. Supported values: auto (default) - a savepoint is created before invocation of each \"before block\" is and a rollback to specific savepoint is issued after each \"after\" block; manual - rollback is never issued automatically. Property can be overridden for child element (test in suite) --%disabled Package/procedure Used to disable a suite or a test. Disabled suites/tests do not get executed, they are however marked and reported as disabled in a test run. --%context(<name>) Package Denotes start of a named context (sub-suite) in a suite package --%endcontext Package Denotes end of a nested context (sub-suite) in a suite package","title":"Supported annotations"},{"location":"userguide/annotations.html#suite","text":"The --%suite annotation denotes PLSQL package as a unit test suite. It accepts an optional description that will be visible when running the tests. When description is not provided, package name is displayed on report. Note Package is considered a test-suite only when package specification contains the --%suite annotation at the package level. Some annotations like --%suite , --%test and --%displayname accept parameters. The parameters for annotations need to be placed in brackets. Values for parameters should be provided without any quotation marks. If the parameters are placed without brackets or with incomplete brackets, they will be ignored. Example: --%suite(The name of suite without closing bracket Example: --%suite The name of suite without brackets Suite package without description. create or replace package test_package as --%suite end ; / exec ut . run ( 'test_package' ); test_package Finished in .002415 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Suite package with description. create or replace package test_package as --%suite(Tests for a package) end ; / exec ut . run ( 'test_package' ); Tests for a package Finished in .001646 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) When multiple --%suite annotations are specified in package, the first annotation will be used and a warning message will appear indicating duplicate annotation. create or replace package test_package as --%suite(Tests for a package) --%suite(Bad annotation) end ; / exec ut . run ( 'test_package' ); Tests for a package Warnings: 1) test_package Duplicate annotation \"--%suite\". Annotation ignored. at \"TESTS_OWNER.TEST_PACKAGE\", line 3 Finished in .003318 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 1 warning(s) When --%suite annotation is bound to procedure, it is ignored and results in package not getting recognized as test suite. create or replace package test_package as --%suite(Tests for a package) procedure some_proc ; end ; / exec ut . run ( 'test_package' ); ORA-20204: Suite package TESTS_OWNER.test_package not found ORA-06512: at \"UT3.UT_RUNNER\", line 106 ORA-06512: at \"UT3.UT\", line 115 ORA-06512: at \"UT3.UT\", line 306 ORA-06512: at \"UT3.UT\", line 364 ORA-06512: at line 1","title":"Suite"},{"location":"userguide/annotations.html#test","text":"The --%test annotation denotes procedure withing test suite as a unit test. It accepts an optional description that will be reported when the test is executed. When description is not provided, procedure name is displayed on report. If --%test raises an unhandled exception the following will happen: - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite Test procedure without description. create or replace package test_package as --%suite(Tests for a package) --%test procedure some_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package some_test [.003 sec] Finished in .004109 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Test procedure with description. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.005 sec] Finished in .006828 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) When multiple --%test annotations are specified for a procedure, the first annotation will be used and a warning message will appear indicating duplicate annotation. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) --%test(Duplicate description) procedure some_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.007 sec] Warnings: 1) test_package Duplicate annotation \"--%test\". Annotation ignored. at \"TESTS_OWNER.TEST_PACKAGE.SOME_TEST\", line 5 Finished in .008815 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 1 warning(s)","title":"Test"},{"location":"userguide/annotations.html#disabled","text":"Marks annotated suite package or test procedure as disabled. Disabling suite. create or replace package test_package as --%suite(Tests for a package) --%disabled --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [0 sec] (DISABLED) Description of another behavior [0 sec] (DISABLED) Finished in .001441 seconds 2 tests, 0 failed, 0 errored, 2 disabled, 0 warning(s) Disabling individual test(s). create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) --%disabled procedure other_test ; end ; / create or replace package body test_package as procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.004 sec] Description of another behavior [0 sec] (DISABLED) Finished in .005868 seconds 2 tests, 0 failed, 0 errored, 1 disabled, 0 warning(s)","title":"Disabled"},{"location":"userguide/annotations.html#beforeall","text":"There are two possible ways to use the --%beforeall annotation. As a procedure level annotation: --%suite(Some test suite) --%beforeall procedure to_be_executed_before_all ; --%test procedure some_test ; Marks annotated procedure to be executed before all test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%beforeall(to_be_executed_before_all, other_package.some_setup) --%test procedure some_test ; procedure to_be_executed_before_all ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed before all test procedures in a suite. If --%beforeall raises an exception, suite content cannot be safely executed as the setup was not executed successfully for the suite. If --%beforeall raises an exception the following will happen: - the --%beforeall procedures that follow the failed one, will not be executed - all --%test procedures and their --%beforeeach , --%aftereach , --%beforetest and --%aftertest procedures within suite package will not be executed - all --%test procedures will be marked as failed - the --%afterall procedures will be executed - test execution will continue uninterrupted for other suite packages When multiple --%beforeall procedures are defined in a suite package, all of them will be executed before invoking any test. For multiple --%beforeall procedures order of execution is defined by annotation position in the package specification. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%beforeall procedure setup_stuff ; end ; / create or replace package body test_package as procedure setup_stuff is begin dbms_output . put_line ( '--- SETUP_STUFF invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package --- SETUP_STUFF invoked --- Description of tested behavior [.004 sec] Description of another behavior [.003 sec] Finished in .012292 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) In the below example a combination pacakge and procedure level --%beforeall annotations is used. The order of execution of the beforeall procedures is determined by the annotation position in package. All of the --%beforeall procedures get invoked before any test is executed in a suite. create or replace package test_package as --%suite(Tests for a package) --%beforeall(initial_setup,test_package.another_setup) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%beforeall procedure next_setup ; --%beforeall(one_more_setup) procedure another_setup ; procedure one_more_setup ; procedure initial_setup ; end ; / create or replace package body test_package as procedure one_more_setup is begin dbms_output . put_line ( '--- ONE_MORE_SETUP invoked ---' ); end ; procedure next_setup is begin dbms_output . put_line ( '--- NEXT_SETUP invoked ---' ); end ; procedure another_setup is begin dbms_output . put_line ( '--- ANOTHER_SETUP invoked ---' ); end ; procedure initial_setup is begin dbms_output . put_line ( '--- INITIAL_SETUP invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); ``` Tests for a package --- INITIAL_SETUP invoked --- --- ANOTHER_SETUP invoked --- --- NEXT_SETUP invoked --- --- ONE_MORE_SETUP invoked --- Description of tested behavior [.003 sec] Description of another behavior [.002 sec] Finished in .018944 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) ``` When multiple --%beforeall annotations are specified for a procedure, the first annotation will be used and a warning message will appear indicating duplicate annotation. When procedure is annotated as both --%beforeall and --%test , the procedure will become a test and a warning message will appear indicating invalid annotation combination. create or replace package test_package as --%suite(Tests for a package) --%beforeall --%beforeall procedure initial_setup ; --%test(Description of tested behavior) --%beforeall procedure some_test ; --%test(Description of another behavior) procedure other_test ; end ; / create or replace package body test_package as procedure initial_setup is begin dbms_output . put_line ( '--- INITIAL_SETUP invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); ``` Tests for a package --- INITIAL_SETUP invoked --- Description of tested behavior [.003 sec] Description of another behavior [.004 sec] Warnings: 1) test_package Duplicate annotation \"--%beforeall\". Annotation ignored. at \"UT3_TESTER.TEST_PACKAGE.INITIAL_SETUP\", line 5 2) test_package Annotation \"--%beforeall\" cannot be used with annotation: \"--%test\" at \"UT3_TESTER.TEST_PACKAGE.SOME_TEST\", line 9 Finished in .012158 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 2 warning(s) ```","title":"Beforeall"},{"location":"userguide/annotations.html#afterall","text":"There are two possible ways to use the --%afterall annotation. As a procedure level annotation: --%suite(Some test suite) --%afterall procedure to_be_executed_after_all ; --%test procedure some_test ; Marks annotated procedure to be executed after all test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%afterall(to_be_executed_after_all, other_package.some_cleanup) --%test procedure some_test ; procedure to_be_executed_after_all ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed after all test procedures in a suite. If --%afterall raises an exception the following will happen: - a warning will be raised, indicating that --%afterall procedure has failed - execution will continue uninterrupted for rest of the suite If --%afterall raises an exception, it can have negative impact on other tests, as the environment was not cleaned-up after the tests. This however doesn't have direct impact on test execution within current suite, as the tests are already complete by the time --%afterall is called. When multiple --%afterall procedures are defined in a suite, all of them will be executed after invoking all tests from the suite. For multiple --%afterall procedures order of execution is defined by annotation position in the package specification. All rules defined for --%beforeall also apply for --%afterall annotation. See beforeall for more details. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%afterall procedure cleanup_stuff ; end ; / create or replace package body test_package as procedure cleanup_stuff is begin dbms_output . put_line ( '---CLEANUP_STUFF invoked ---' ); end ; procedure some_test is begin null ; end ; procedure other_test is begin null ; end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.003 sec] Description of another behavior [.005 sec] ---CLEANUP_STUFF invoked --- Finished in .014161 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)","title":"Afterall"},{"location":"userguide/annotations.html#beforeeach","text":"The procedure annotated as --%beforeeach is getting executed before each test in a suite. That means that the procedure will be executed as many times as there are test in suite package. There are two possible ways to use the --%beforeeach annotation. As a procedure level annotation: --%suite(Some test suite) --%beforeeach procedure to_be_executed_before_each ; --%test procedure some_test ; Marks annotated procedure to be executed before each test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%beforeeach(to_be_executed_before_each, other_package.some_setup) --%test procedure some_test ; procedure to_be_executed_before_each ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed before each test procedure in a suite. If a test is marked as disabled the --%beforeeach procedure is not invoked for that test. If --%beforeeach raises an unhandled exception the following will happen: - the following --%beforeeach as well as all --%beforetest for that test will not be executed - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite As a rule, the --%beforeeach execution gets aborted if preceding --%beforeeach failed. When multiple --%beforeeach procedures are defined in a suite, all of them will be executed before invoking each test. For multiple --%beforeeach procedures order of execution is defined by annotation position in the package specification. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%beforeeach procedure setup_for_test ; --%beforeall procedure setup_stuff ; end ; / create or replace package body test_package as procedure setup_stuff is begin dbms_output . put_line ( '---SETUP_STUFF invoked ---' ); end ; procedure setup_for_test is begin dbms_output . put_line ( '---SETUP_FOR_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package ---SETUP_STUFF invoked --- Description of tested behavior [.004 sec] ---SETUP_FOR_TEST invoked --- ---SOME_TEST invoked --- Description of another behavior [.006 sec] ---SETUP_FOR_TEST invoked --- ---OTHER_TEST invoked --- Finished in .014683 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) See beforeall for more examples.","title":"Beforeeach"},{"location":"userguide/annotations.html#aftereach","text":"Marks annotated procedure to be executed after each test procedure in a suite. The procedure annotated as --%aftereach is getting executed after each test in a suite. That means that the procedure will be executed as many times as there are test in suite package. There are two possible ways to use the --%aftereach annotation. As a procedure level annotation: --%suite(Some test suite) --%aftereach procedure to_be_executed_after_each ; --%test procedure some_test ; Marks annotated procedure to be executed after each test procedures in a suite. As a package level annotation (not associated with any procedure). --%suite(Some test suite) --%aftereach(to_be_executed_after_each, other_package.some_setup) --%test procedure some_test ; procedure to_be_executed_after_each ; Indicates that the procedure(s) mentioned as the annotation parameter are to be executed after each test procedure in a suite. If a test is marked as disabled the --%aftereach procedure is not invoked for that test. If --%aftereach raises an unhandled exception the following will happen: - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite When multiple --%aftereach procedures are defined in a suite, all of them will be executed after invoking each test. For multiple --%aftereach procedures order of execution is defined by the annotation position in the package specification. As a rule, the --%aftereach gets executed even if the associated --%beforeeach , --%beforetest , --%test or other --%aftereach procedures have raised unhandled exceptions. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) procedure some_test ; --%test(Description of another behavior) procedure other_test ; --%aftereach procedure cleanup_for_test ; --%afterall procedure cleanup_stuff ; end ; / create or replace package body test_package as procedure cleanup_stuff is begin dbms_output . put_line ( '---CLEANUP_STUFF invoked ---' ); end ; procedure cleanup_for_test is begin dbms_output . put_line ( '---CLEANUP_FOR_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.006 sec] ---SOME_TEST invoked --- ---CLEANUP_FOR_TEST invoked --- Description of another behavior [.006 sec] ---OTHER_TEST invoked --- ---CLEANUP_FOR_TEST invoked --- ---CLEANUP_STUFF invoked --- Finished in .018115 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) See beforeall for more examples.","title":"Aftereach"},{"location":"userguide/annotations.html#beforetest","text":"Indicates specific setup procedure(s) to be executed for a test. The procedure(s) can be located either: - within current package (package name is optional) - within another package The annotation need to be placed alongside --%test annotation. The --%beforetest procedures are executed after invoking all --%beforeeach for a test. If a test is marked as disabled the --%beforetest procedures are not invoked for that test. If --%beforetest raises an unhandled exception the following will happen: - the following --%beforetest for that test will not be executed - the test will be marked as errored and exception stack trace will be captured and reported - the --%aftertest , --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite When multiple --%beforetest procedures are defined for a test, all of them will be executed before invoking the test. The order of execution for --%beforetest procedures is defined by: - position of procedure on the list within single annotation - annotation position As a rule, the --%beforetest execution gets aborted if preceding --%beforeeach or --%beforetest failed. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) --%beforetest(test_package.setup_for_a_test) --%beforetest(another_setup_for_a_test) procedure some_test ; --%test(Description of another behavior) --%beforetest(test_package.setup_for_a_test, another_setup_for_a_test) procedure other_test ; procedure another_setup_for_a_test ; procedure setup_for_a_test ; end ; / create or replace package body test_package as procedure setup_for_a_test is begin dbms_output . put_line ( '---SETUP_FOR_A_TEST invoked ---' ); end ; procedure another_setup_for_a_test is begin dbms_output . put_line ( '---ANOTHER_SETUP_FOR_A_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.008 sec] ---SETUP_FOR_A_TEST invoked --- ---ANOTHER_SETUP_FOR_A_TEST invoked --- ---SOME_TEST invoked --- Description of another behavior [.005 sec] ---SETUP_FOR_A_TEST invoked --- ---ANOTHER_SETUP_FOR_A_TEST invoked --- ---OTHER_TEST invoked --- Finished in .015185 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)","title":"Beforetest"},{"location":"userguide/annotations.html#aftertest","text":"Indicates specific cleanup procedure(s) to be executed for a test. The procedure(s) can be located either: - within current package (package name is optional) - within another package The annotation need to be placed alongside --%test annotation. If a test is marked as disabled the --%aftertest procedures are not invoked for that test. If --%aftertest raises an unhandled exception the following will happen: - the test will be marked as errored and exception stack trace will be captured and reported - the following --%aftertest and all --%aftereach procedures will be executed for the errored test - the --%afterall procedures will be executed - test execution will continue uninterrupted for rest of the suite When multiple --%aftertest procedures are defined for a test, all of them will be executed before invoking the test. The order of execution for --%aftertest procedures is defined by: - position of procedure on the list within single annotation - annotation position As a rule, the --%aftertest gets executed even if the associated --%beforeeach , --%beforetest , --%test or other --%aftertest procedures have raised unhandled exceptions. create or replace package test_package as --%suite(Tests for a package) --%test(Description of tested behavior) --%aftertest(test_package.cleanup_for_a_test) --%aftertest(another_cleanup_for_a_test) procedure some_test ; --%test(Description of another behavior) --%aftertest(test_package.cleanup_for_a_test, another_cleanup_for_a_test) procedure other_test ; procedure another_cleanup_for_a_test ; procedure cleanup_for_a_test ; end ; / create or replace package body test_package as procedure cleanup_for_a_test is begin dbms_output . put_line ( '---CLEANUP_FOR_A_TEST invoked ---' ); end ; procedure another_cleanup_for_a_test is begin dbms_output . put_line ( '---ANOTHER_CLEANUP_FOR_A_TEST invoked ---' ); end ; procedure some_test is begin dbms_output . put_line ( '---SOME_TEST invoked ---' ); end ; procedure other_test is begin dbms_output . put_line ( '---OTHER_TEST invoked ---' ); end ; end ; / exec ut . run ( 'test_package' ); Tests for a package Description of tested behavior [.008 sec] ---SOME_TEST invoked --- ---CLEANUP_FOR_A_TEST invoked --- ---ANOTHER_CLEANUP_FOR_A_TEST invoked --- Description of another behavior [.006 sec] ---OTHER_TEST invoked --- ---CLEANUP_FOR_A_TEST invoked --- ---ANOTHER_CLEANUP_FOR_A_TEST invoked --- Finished in .016873 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)","title":"Aftertest"},{"location":"userguide/annotations.html#context","text":"In most of the cases, the code to be tested is consisting of PLSQL packages containing procedures and functions. When creating test suites, it's quite common to maintain one to one relationship between test suite packages and tested code. When it comes to test procedures themselves, it is best practice to have one test procedure for one tested behavior of the code that is tested. The relationship between test procedure and tested procedure/function will be therefore many to one in most of the cases. With this comes a challenge. How to group tests, related to one tested procedure, so that it is obvious that they relate to the same code. This is where utPLSQL contexts come handy. Contexts allow for creating sub-suites within a suite package and they allow for grouping of tests that are somehow related. In essence, context behaves like a suite within a suite. Context have following characteristics: - start with the --%context annotation and ends with --%endcontext - can have a name provided as parameter for example --%context(remove_rooms_by_name) - when no name is provided for context, the context is names context_N where N is the number of the context in suite - can have their own --%beforeall , --%beforeeach , --%afterall and --%aftereach procedures - --%beforeall , --%beforeeach , --%afterall and --%aftereach procedures defined at suite level, propagate to context - test suite package can have multiple contexts in it - contexts cannot be nested The below example illustrates usage of --%context for separating tests for individual procedures of package. Tested tables and code create table rooms ( room_key number primary key , name varchar2 ( 100 ) not null ); create table room_contents ( contents_key number primary key , room_key number not null , name varchar2 ( 100 ) not null , create_date timestamp default current_timestamp not null , constraint fk_rooms foreign key ( room_key ) references rooms ( room_key ) ); create or replace package rooms_management is procedure remove_rooms_by_name ( a_name rooms . name % type ); procedure add_rooms_content ( a_room_name rooms . name % type , a_content_name room_contents . name % type ); end ; / create or replace package body rooms_management is procedure remove_rooms_by_name ( a_name rooms . name % type ) is begin if a_name is null then raise program_error ; end if ; delete from rooms where name like a_name ; end ; procedure add_rooms_content ( a_room_name rooms . name % type , a_content_name room_contents . name % type ) is l_room_key rooms . room_key % type ; begin select room_key into l_room_key from rooms where name = a_room_name ; insert into room_contents ( contents_key , room_key , name ) select nvl ( max ( contents_key ) + 1 , 1 ) as contents_key , l_room_key , a_content_name from room_contents ; end ; end ; / Below test suite defines: - --%beforeall outside of context, that will be executed before all tests - --%context(remove_rooms_by_name) to group tests for remove_rooms_by_name procedure - --%context(add_rooms_content) to group tests for add_rooms_content procedure create or replace package test_rooms_management is gc_null_value_exception constant integer : = - 1400 ; --%suite(Rooms management) --%beforeall procedure setup_rooms ; --%context(remove_rooms_by_name) --%description(Remove rooms by name) --%test(Removes a room without content in it) procedure remove_empty_room ; --%test(Raises exception when null room name given) --%throws(-6501) procedure null_room_name ; --%endcontext --%context(add_rooms_content) --%description(Add content to a room) --%test(Fails when room name is not valid) --%throws(no_data_found) procedure fails_on_room_name_invalid ; --%test(Fails when content name is null) --%throws(gc_null_value_exception) procedure fails_on_content_null ; --%test(Adds a content to existing room) procedure add_content_success ; --%endcontext end ; / create or replace package body test_rooms_management is procedure setup_rooms is begin insert all into rooms values ( 1 , 'Dining Room' ) into rooms values ( 2 , 'Living Room' ) into rooms values ( 3 , 'Bathroom' ) select 1 from dual ; insert all into room_contents values ( 1 , 1 , 'Table' , sysdate ) into room_contents values ( 3 , 1 , 'Chair' , sysdate ) into room_contents values ( 4 , 2 , 'Sofa' , sysdate ) into room_contents values ( 5 , 2 , 'Lamp' , sysdate ) select 1 from dual ; dbms_output . put_line ( '---SETUP_ROOMS invoked ---' ); end ; procedure remove_empty_room is l_rooms_not_named_b sys_refcursor ; l_remaining_rooms sys_refcursor ; begin open l_rooms_not_named_b for select * from rooms where name not like 'B%' ; remove_rooms_by_name ( 'B%' ); open l_remaining_rooms for select * from rooms ; ut . expect ( l_remaining_rooms ). to_equal ( l_rooms_not_named_b ); end ; procedure room_with_content is begin remove_rooms_by_name ( 'Living Room' ); end ; procedure null_room_name is begin remove_rooms_by_name ( NULL ); end ; procedure fails_on_room_name_invalid is begin add_rooms_content ( 'bad room name' , 'Chair' ); end ; procedure fails_on_content_null is begin --Act add_rooms_content ( 'Dining Room' , null ); --Assert done by --%throws annotation end ; procedure add_content_success is l_expected room_contents . name % type ; l_actual room_contents . name % type ; begin --Arrange l_expected : = 'Table' ; --Act add_rooms_content ( 'Dining Room' , l_expected ); --Assert select name into l_actual from room_contents where contents_key = ( select max ( contents_key ) from room_contents ); ut . expect ( l_actual ). to_equal ( l_expected ); end ; end ; / When te tests are executed exec ut . run ( 'test_package' ); The following report is displayed Rooms management ---SETUP_ROOMS invoked --- remove_rooms_by_name Removes a room without content in it [.015 sec] Raises exception when null room name given [.002 sec] add_rooms_content Fails when room name is not valid [.003 sec] Fails when content name is null [.003 sec] Adds a content to existing room [.003 sec] Finished in .035261 seconds 5 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)","title":"Context"},{"location":"userguide/annotations.html#suitepath","text":"It is very likely that the application for which you are going to introduce tests consists of many different packages, procedures and functions. Usually procedures can be logically grouped inside a package, there also might be several logical groups of procedures in a single package and packages might be grouped into modules and modules into subject areas. As your project grows, the codebase will grow to. utPLSQL allows you to group packages into modules and also allows for nesting modules. Let's say you have a complex insurance application that deals with policies, claims and payments. The payment module contains several packages for payment recognition, charging, planning etc. The payment recognition module among others contains a complex recognize_payment procedure that associates received money to the policies. If you want to create tests for your application it is recommended to structure your tests similarly to the logical structure of your application. So you end up with something like: * Integration tests * Policy tests * Claim tests * Payment tests * Payments recognition * Payments set off The %suitepath annotation is used for such grouping. Even though test packages are defined in a flat structure the %suitepath is used by the framework to form them into a hierarchical structure. Your payments recognition test package might look like: create or replace package test_payment_recognition as --%suite(Payment recognition tests) --%suitepath(payments) --%test(Recognize payment by policy number) procedure test_recognize_by_num ; --%test(Recognize payment by payment purpose) procedure test_recognize_by_purpose ; --%test(Recognize payment by customer) procedure test_recognize_by_customer ; end test_payment_recognition ; And payments set off test package: create or replace package test_payment_set_off as --%suite(Payment set off tests) --%suitepath(payments) --%test(Creates set off) procedure test_create_set_off ; --%test(Cancels set off) procedure test_cancel_set_off ; end test_payment_set_off ; When you execute tests for your application, the framework constructs a test suite for each test package. Then it combines suites into grouping suites by the %suitepath annotation value so that the fully qualified path to the recognize_by_num procedure is USER:payments.test_payment_recognition.test_recognize_by_num . If any of its expectations fails then the test is marked as failed, also the test_payment_recognition suite, the parent suite payments and the whole run is marked as failed. The test report indicates which expectation has failed on the payments module. The payments recognition submodule is causing the failure as recognize_by_num has not met the expectations of the test. Grouping tests into modules and submodules using the %suitepath annotation allows you to logically organize your project's flat structure of packages into functional groups. An additional advantage of such grouping is the fact that every element level of the grouping can be an actual unit test package containing a common module level setup for all of the submodules. So in addition to the packages mentioned above you could have the following package. create or replace package payments as --%suite(Payments) --%beforeall procedure set_common_payments_data ; --%afterall procedure reset_common_paymnets_data ; end payments ; A %suitepath can be provided in three ways: * schema - execute all tests in the schema * [schema]:suite1[.suite2][.suite3]...[.procedure] - execute all tests in all suites from suite1[.suite2][.suite3]...[.procedure] path. If schema is not provided, then the current schema is used. Example: :all.rooms_tests * [schema.]package[.procedure] - execute all tests in the specified test package. The whole hierarchy of suites in the schema is built before all before/after hooks or part suites for the provided suite package are executed as well. Example: tests.test_contact.test_last_name_validator or simply test_contact.test_last_name_validator if tests is the current schema.","title":"Suitepath"},{"location":"userguide/annotations.html#rollback","text":"By default, changes performed by every setup, cleanup and test procedure are isolated by savepoints. This solution is suitable for use-cases where the code that is being tested as well as the unit tests themselves do not use transaction control (commit/rollback) or DDL commands. In general, your unit tests should not use transaction control as long as the code you are testing is not using it too. Keeping the transactions uncommitted allows your changes to be isolated and the execution of tests does not impact others who might be using a shared development database. If you are in a situation where the code you are testing uses transaction control (common case with ETL code), then your tests probably should not use the default automatic transaction control. In that case use the annotation --%rollback(manual) on the suite level to disable automatic transaction control for the entire suite. If you are using nested suites, you need to make sure that the entire suite all the way to the root is using manual transaction control. It is possible with utPLSQL to change the transaction control on individual suites or tests that are part of complex suite. It is strongly recommended not to have mixed transaction control in a suite. Mixed transaction control settings will not work properly when your suites are using shared setup/cleanup with beforeall, afterall, beforeeach or aftereach annotations. Your suite will most likely fail with error or warning on execution. Some of the automatic rollbacks will probably fail to execute depending on the configuration you have. In some cases it is necessary to perform DDL as part of setup or cleanup for the tests. It is recommended to move such DDL statements to a procedure with pragma autonomous_transaction to eliminate implicit commits in the main session that is executing all your tests. Doing so allows your tests to use the framework's automatic transaction control and releases you from the burden of manual cleanup of data that was created or modified by test execution. When you are testing code that performs explicit or implicit commits, you may set the test procedure to run as an autonomous transaction with pragma autonomous_transaction . Keep in mind that when your test runs as autonomous transaction it will not see the data prepared in a setup procedure unless the setup procedure committed the changes. Note The --%suitepath annotation, when used, must be provided with a value of path. The path in suitepath cannot contain spaces. Dot (.) identifies individual elements of the path. Example: --%suitepath(org.utplsql.core.utils)","title":"Rollback"},{"location":"userguide/annotations.html#throws","text":"The --%throws annotation allows you to specify a list of exceptions as one of: - number literals - example --%throws(-20134) - variables of type exception defined in a package specification - example --%throws(exc_pkg.c_exception_No_variable) - variables of type number defined in a package specification - example --%throws(exc_pkg.c_some_exception) - predefined oracle exceptions - example --%throws(no_data_found) The annotation is ignored, when no valid arguments are provided. Examples of invalid annotations --%throws() , --%throws , --%throws(abe, 723pf) . If --%throws annotation is specified with arguments and no exception is raised, the test is marked as failed. If --%throws annotation is specified with arguments and exception raised is not on the list of provided exceptions, the test is marked as failed. The framework will raise a warning, when --%throws annotation has invalid arguments or when no arguments were provided. Annotation --%throws(7894562, operaqk, -=1, -20496, pow74d, posdfk3) will be interpreted as --%throws(-20496) . Please note that NO_DATA_FOUND exception is a special case in Oracle. To capture it use NO_DATA_FOUND named exception or -1403 exception No. Example: create or replace package exc_pkg is c_e_option1 constant number : = - 20200 ; c_e_option2 constant varchar2 ( 10 ) : = '-20201' ; c_e_option3 number : = - 20202 ; e_option4 exception ; pragma exception_init ( e_option4 , - 20203 ); end ; / create or replace package example_pgk as --%suite(Example Throws Annotation) --%test(Throws one of the listed exceptions) --%throws(-20145,bad,-20146, -20189 ,-20563) procedure raised_one_listed_exception ; --%test(Throws different exception than expected) --%throws(-20144) procedure raised_different_exception ; --%test(Throws different exception than listed) --%throws(-20144,-00001,-20145) procedure raised_unlisted_exception ; --%test(Gives failure when an exception is expected and nothing is thrown) --%throws(-20459, -20136, -20145) procedure nothing_thrown ; --%test(Throws package exception option1) --%throws(exc_pkg.c_e_option1) procedure raised_option1_exception ; --%test(Throws package exception option2) --%throws(exc_pkg.c_e_option2) procedure raised_option2_exception ; --%test(Throws package exception option3) --%throws(exc_pkg.c_e_option3) procedure raised_option3_exception ; --%test(Throws package exception option4) --%throws(exc_pkg.e_option4) procedure raised_option4_exception ; --%test(Raise name exception) --%throws(DUP_VAL_ON_INDEX) procedure raise_named_exc ; --%test(Invalid throws annotation) --%throws procedure bad_throws_annotation ; end ; / create or replace package body example_pgk is procedure raised_one_listed_exception is begin raise_application_error ( - 20189 , 'Test error' ); end ; procedure raised_different_exception is begin raise_application_error ( - 20143 , 'Test error' ); end ; procedure raised_unlisted_exception is begin raise_application_error ( - 20143 , 'Test error' ); end ; procedure nothing_thrown is begin ut . expect ( 1 ). to_equal ( 1 ); end ; procedure raised_option1_exception is begin raise_application_error ( exc_pkg . c_e_option1 , 'Test error' ); end ; procedure raised_option2_exception is begin raise_application_error ( exc_pkg . c_e_option2 , 'Test error' ); end ; procedure raised_option3_exception is begin raise_application_error ( exc_pkg . c_e_option3 , 'Test error' ); end ; procedure raised_option4_exception is begin raise exc_pkg . e_option4 ; end ; procedure raise_named_exc is begin raise DUP_VAL_ON_INDEX ; end ; procedure bad_throws_annotation is begin null ; end ; end ; / exec ut3 . ut . run ( 'example_pgk' ); Running the test will give report: Example Throws Annotation Throws one of the listed exceptions [.002 sec] Throws different exception than expected [.002 sec] (FAILED - 1) Throws different exception than listed [.003 sec] (FAILED - 2) Gives failure when an exception is expected and nothing is thrown [.002 sec] (FAILED - 3) Throws package exception option1 [.003 sec] Throws package exception option2 [.002 sec] Throws package exception option3 [.002 sec] Throws package exception option4 [.002 sec] Raise name exception [.002 sec] Invalid throws annotation [.002 sec] Failures: 1) raised_different_exception Actual: -20143 was expected to equal: -20144 ORA-20143: Test error ORA-06512: at \"UT3.EXAMPLE_PGK\", line 9 ORA-06512: at \"UT3.EXAMPLE_PGK\", line 9 ORA-06512: at line 6 2) raised_unlisted_exception Actual: -20143 was expected to be one of: (-20144, -1, -20145) ORA-20143: Test error ORA-06512: at \"UT3.EXAMPLE_PGK\", line 14 ORA-06512: at \"UT3.EXAMPLE_PGK\", line 14 ORA-06512: at line 6 3) nothing_thrown Expected one of exceptions (-20459, -20136, -20145) but nothing was raised. Warnings: 1) example_pgk Invalid parameter value \"bad\" for \"--%throws\" annotation. Parameter ignored. at \"UT3.EXAMPLE_PGK.RAISED_ONE_LISTED_EXCEPTION\", line 6 2) example_pgk \"--%throws\" annotation requires a parameter. Annotation ignored. at \"UT3.EXAMPLE_PGK.BAD_THROWS_ANNOTATION\", line 42 Finished in .025784 seconds 10 tests, 3 failed, 0 errored, 0 disabled, 2 warning(s)","title":"Throws"},{"location":"userguide/annotations.html#order-of-execution","text":"create or replace package test_employee_pkg is --%suite(Employee management) --%suitepath(com.my_company.hr) --%rollback(auto) --%beforeall procedure setup_employees ; --%beforeall procedure setup_departments ; --%afterall procedure cleanup_log_table ; --%context(add_employee) --%beforeeach procedure setup_for_add_employees ; --%test(Raises exception when employee already exists) --%throws(-20145) procedure add_existing_employee ; --%test(Inserts employee to emp table) procedure add_employee ; --%endcontext --%context(remove_employee) --%beforeall procedure setup_for_remove_employee ; --%test(Removed employee from emp table) procedure del_employee ; --%endcontext --%test(Test without context) --%beforetest(setup_another_test) --%aftertest(cleanup_another_test) procedure some_test ; --%test(Name of test) --%disabled procedure disabled_test ; --%test(Name of test) --%rollback(manual) procedure no_transaction_control_test ; procedure setup_another_test ; procedure cleanup_another_test ; --%beforeeach procedure set_session_context ; --%aftereach procedure cleanup_session_context ; end test_employee_pkg ; When processing the test suite test_employee_pkg defined in Example of annotated test package , the order of execution will be as follows. create a savepoint 'before-suite' execute setup_employees (--%beforeall) execute setup_departments (--%beforeall) create a savepoint 'before-context' create savepoint 'before-test' execute test_setup (--%beforeeach) execute setup_for_add_employees (--%beforeeach from context) execute add_existing_employee (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' create savepoint 'before-test' (--%suite) execute test_setup (--%beforeeach) execute setup_for_add_employees (--%beforeeach from context) execute add_employee (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' rollback to savepoint 'before-context' create a savepoint 'before-context' execute setup_for_remove_employee (--%beforeall from context) create savepoint 'before-test' execute test_setup (--%beforeeach) execute add_existing_employee (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' rollback to savepoint 'before-context' create savepoint 'before-test' execute test_setup (--%beforeeach) execute some_test (--%test) execute test_cleanup (--%aftereach) rollback to savepoint 'before-test' create savepoint 'before-test' execute test_setup (--%beforeeach) execute setup_another_test (--%beforetest) execute another_test (--%test) execute cleanup_another_test (--%aftertest) execute test_cleanup (--%beforeeach) rollback to savepoint 'before-test' mark disabled_test as disabled (--%test --%disabled) execute test_setup (--%beforeeach) execute no_transaction_control_test (--%test) execute test_cleanup (--%aftertest) execute global_cleanup (--%afterall) rollback to savepoint 'before-suite' Note utPLSQL does not guarantee ordering of tests in suite. On contrary utPLSQL might give random order of tests/contexts in suite. Order of execution within multiple occurrences of before / after procedures is determined by the order of annotations in specific block (context/suite) of package specification.","title":"Order of execution"},{"location":"userguide/annotations.html#annotation-cache","text":"utPLSQL needs to scan the source of package specifications to identify and parse annotations. To improve framework startup time, especially when dealing with database users owning large amounts of packages, the framework has a built-in persistent cache for annotations. The annotation cache is checked for staleness and refreshed automatically on every run. The initial startup of utPLSQL for a schema will take longer than consecutive executions. If you are in a situation where your database is controlled via CI/CD server and is refreshed/wiped before each run of your tests, consider building the annotation cache upfront and taking a snapshot of the database after the cache has been refreshed. To build the annotation cache without actually invoking any tests, call ut_runner.rebuild_annotation_cache(a_object_owner) for every unit test owner for which you want to have the annotation cache prebuilt. Example: exec ut_runner . rebuild_annotation_cache ( 'HR' ); To purge the annotation cache call ut_runner.purge_cache(a_object_owner, a_object_type) . Both parameters are optional and if not provided, all owners/object_types will be purged. Example: exec ut_runner . purge_cache ( 'HR' , 'PACKAGE' );","title":"Annotation cache"},{"location":"userguide/best-practices.html","text":"Best Practices \u00b6 The following are best practices we at utPLSQL have learned about PL/SQL and Unit Testing. Test Isolation and Dependency \u00b6 Tests should not depend on a specific order to run Tests should not depend on other tests to execute Tests should not depend on specific database state, they should setup the expected state before being run Tests should keep the environment unchanged post execution Writing tests \u00b6 Tests should not mimic / duplicate the logic of tested code Tests should contain zero logic (or as close to zero as possible) The 3A rule: Arrange (setup inputs/data/environment for the tested code) Act (execute code under test) Assert (validate the outcomes of the execution) Each tested procedure/function/trigger (code block) should have more than one test Each test should check only one behavior (one requirement) of the code block under test Tests should be maintained as thoroughly as production code Every test needs to be built so that it can fail, tests that do not fail when needed are useless Gaining value from the tests \u00b6 Tests are only valuable if they are executed frequently; ideally with every change to the project code Tests need to run very fast; the slower the tests, the longer you wait. Build tests with performance in mind (do you really need to have 10k rows to run the tests?) Tests that are executed infrequently can quickly become stale and end up adding overhead rather than value. Maintain tests as you would maintain code. Tests that are failing need to be addressed immediately. How can you trust your tests when 139 of 1000 tests are failing for a month? Will you recognise each time that it is still the same 139 tests? Tests are not for production \u00b6 Tests will generate and operate on fake data. They might insert, update and delete data. You don't want tests to run on a production database and affect real life data. Tests and their relationship to code under test \u00b6 Tests and the code under test should be in separate packages. This is a fundamental separation of responsibilities. It is common for test code to be in the same schema as the tested code. This removes the need to manage privileges for the tests. Version Control \u00b6 Use a version control system for your code. Don't just trust the database for code storage. This includes both the code under test, and the unit tests you develop as well. Treat the database as a target/destination for your code, not as a source of it.","title":"Testing best pracitces"},{"location":"userguide/best-practices.html#best-practices","text":"The following are best practices we at utPLSQL have learned about PL/SQL and Unit Testing.","title":"Best Practices"},{"location":"userguide/best-practices.html#test-isolation-and-dependency","text":"Tests should not depend on a specific order to run Tests should not depend on other tests to execute Tests should not depend on specific database state, they should setup the expected state before being run Tests should keep the environment unchanged post execution","title":"Test Isolation and Dependency"},{"location":"userguide/best-practices.html#writing-tests","text":"Tests should not mimic / duplicate the logic of tested code Tests should contain zero logic (or as close to zero as possible) The 3A rule: Arrange (setup inputs/data/environment for the tested code) Act (execute code under test) Assert (validate the outcomes of the execution) Each tested procedure/function/trigger (code block) should have more than one test Each test should check only one behavior (one requirement) of the code block under test Tests should be maintained as thoroughly as production code Every test needs to be built so that it can fail, tests that do not fail when needed are useless","title":"Writing tests"},{"location":"userguide/best-practices.html#gaining-value-from-the-tests","text":"Tests are only valuable if they are executed frequently; ideally with every change to the project code Tests need to run very fast; the slower the tests, the longer you wait. Build tests with performance in mind (do you really need to have 10k rows to run the tests?) Tests that are executed infrequently can quickly become stale and end up adding overhead rather than value. Maintain tests as you would maintain code. Tests that are failing need to be addressed immediately. How can you trust your tests when 139 of 1000 tests are failing for a month? Will you recognise each time that it is still the same 139 tests?","title":"Gaining value from the tests"},{"location":"userguide/best-practices.html#tests-are-not-for-production","text":"Tests will generate and operate on fake data. They might insert, update and delete data. You don't want tests to run on a production database and affect real life data.","title":"Tests are not for production"},{"location":"userguide/best-practices.html#tests-and-their-relationship-to-code-under-test","text":"Tests and the code under test should be in separate packages. This is a fundamental separation of responsibilities. It is common for test code to be in the same schema as the tested code. This removes the need to manage privileges for the tests.","title":"Tests and their relationship to code under test"},{"location":"userguide/best-practices.html#version-control","text":"Use a version control system for your code. Don't just trust the database for code storage. This includes both the code under test, and the unit tests you develop as well. Treat the database as a target/destination for your code, not as a source of it.","title":"Version Control"},{"location":"userguide/coverage.html","text":"Coverage \u00b6 utPLSQL comes with a built-in coverage reporting engine. The code coverage reporting is based on the DBMS_PROFILER package provided with Oracle database. Code coverage is gathered for the following source types: * package bodies * type bodies * triggers * procedures * functions Note The package and type specifications are explicitly excluded from code coverage analysis. This limitation is introduced to avoid false-negatives. Typically package specifications contain no executable code. The only exception is initialization of global constants and variables in package specification. Since most package specifications are not executable at all, there is no information available on the number of lines covered and those would be reported as 0% covered, which is not desirable. To obtain information about code coverage of your unit tests, all you need to do is run your unit tests with one of built-in code coverage reporters. The following code coverage reporters are supplied with utPLSQL: * ut_coverage_html_reporter - generates a HTML coverage report providing summary and detailed information on code coverage. The HTML reporter is based on the open-source simplecov-html reporter for Ruby. It includes source code of the code that was covered (if possible) * ut_coveralls_reporter - generates a Coveralls compatible JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like Coveralls * ut_coverage_sonar_reporter - generates a Sonar Compatible XML coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like SonarQube/SonarCloud * ut_coverage_cobertura_reporter - generates a basic Cobertura coverage (http://cobertura.sourceforge.net/xml/coverage-04.dtd) report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like TFS and Jenkins. Check this link for an example of XML generated by Java: https://raw.githubusercontent.com/jenkinsci/cobertura-plugin/master/src/test/resources/hudson/plugins/cobertura/coverage-with-data.xml Security model \u00b6 utPLSQL code coverage uses DBMS_PROFILER to gather information about the execution of code under test and therefore follows the DBMS_PROFILER's Security Model . In order to be able to gather coverage information, the user executing unit tests needs to be either: * The owner of the code that is being tested * Have the following privileges to be able to gather coverage on code owned by other users: * create any procedure system privilege * execute privilege on the code that is being tested (not only the unit tests) or execute any procedure system privilege If you have execute privilege on the code that is being tested, but do not have create any procedure system privilege, then the code that is being tested will be reported as not covered (coverage = 0%). If you have execute privilege only on the unit tests, but do not have execute privilege on the code that is being tested, the code will not be reported by coverage - as if it did not exist in the database. If the code that is being tested is complied as NATIVE, the code coverage will not be reported as well. Running unit tests with coverage \u00b6 Using the code coverage functionality is as easy as using any other reporter for the utPLSQL project. You just run your tests from your preferred SQL tool and save the reporter results to a file. All you need to do is pass the constructor of the reporter to your ut.run Example: begin ut . run ( ut_coverage_html_reporter ()); end ; / Executes all unit tests in the current schema, gathers information about code coverage and outputs the HTML text into DBMS_OUTPUT. The ut_coverage_html_reporter will produce an interactive HTML report. You can see a sample of code coverage for the utPLSQL project here The report provides summary information with a list of source code that was expected to be covered. The report allow you to navigate to each source file and inspect line by line coverage. Oracle 12.2 extended coverage with profiler and block coverage \u00b6 Using data collected from profiler and block coverage running parallel we are able to enrich information about coverage. For every line recorded by profiler if we have a partially covered same line in block coverage we will display that information presenting line as partially covered, displaying number of block and how many blocks been covered in that line.The feature will be automatically enabled in the Oracle database version 12.2 and higher, for older versions current profiler will be used. utPLSQL installation automatically creates tables needed by dbms_plsql_code_coverage on databases in versions above 12c Release 1. Due to security model of dbms_plsql_code_coverage package, utPLSQL grants access to those tables and creates synonyms for those tables. The access and synonyms will be public when using the headless installation. This approach avoids complexity of forcing every user of utPLSQL framework to create tables on their own. Sample output: Coverage reporting options \u00b6 There are two distinct ways to gather code coverage: - Coverage on database schema(s) - Coverage on project files Those two options are mutually exclusive and cannot be mixed. By default, when using one of coverage reporters, coverage is gathered on schema(s). The parameters used to execute tests determine if utPLSQL will be using one approach or the other. The database schema(s) containing the tests that were executed during the run will be reported on by coverage reporter. Note Regardless of the options provided, all unit test packages are excluded from the coverage report. Coverage reports provide information only about the tested code. The default behavior of coverage reporting can be altered using invocation parameters. Schema based Coverage \u00b6 To simply gather coverage for all objects in your current schema execute tests with coverage reporting. exec ut . run ( ut_coverage_html_reporter ()); Note When no filters are used, the size of the coverage report will depend two factors: - the type of report (does the report include source code or not) - the amount of source code in the database schema Keep in mind that for schemas containing a lot of code, it can take quite some time to produce the coverage report. Setting coverage schema(s) \u00b6 By default, coverage is gathered on the schema(s) derived from suite paths provided to execute tests. This is correct as long as your test packages and tested code share the same schema. So when you run: exec ut . run ( ut_varchar2_list ( 'user_1' , 'user_2' ), ut_coverage_html_reporter ()); Coverage will be gathered on both user_1 and user_2 objects. If your tests live in a different schema from the tested code you may override the default behavior by providing an explicit list of coverage schema names. In the example below, coverage will still be gathered for user_1 and user_2 objects, even thought we run the tests located in schema unit_test_schema exec ut . run ( 'unit_test_schema' , ut_coverage_html_reporter (), a_coverage_schemes => ut_varchar2_list ( 'user_1' , 'user_2' ) ); Filtering objects in coverage reports \u00b6 There are two options that can be used to narrow down the scope of coverage report: - a_include_objects - list of [object_owner.].object_name to be included in the coverage report - a_exclude_objects - list of [object_owner.].object_name to be excluded from the coverage report You may specify both include and exclude object lists to gain more control over what needs to be included / excluded from the coverage report. The object owner is optional in the object list. If you do not provide an object owner, the include / exclude list will be considered for every schema used for coverage gathering (as described above). Example: Limiting coverage by object name, for tested code located in the same schema as the unit tests. exec ut . run ( ut_varchar2_list ( 'user_1' , 'user_2' ), ut_coverage_html_reporter (), a_include_objects => ut_varchar2_list ( 'award_bonus' )); Executes all tests in schemas: user_1 and user_2 . Coverage will only be reported on objects user_1.award_bonus , user_2.award_bonus Example: Limiting coverage by object name, for tested code located in different schemas than the unit tests. begin ut . run ( 'unit_test_schema' , ut_coverage_html_reporter (), a_coverage_schemes => ut_varchar2_list ( 'user_1' , 'user_2' ), a_include_objects => ut_varchar2_list ( 'award_bonus' , 'betwnstr' ) ); end ; Executes all tests in schema unit_test_schema . Coverage will only be reported on objects user_1.award_bonus , user_2.award_bonus , user_1.betwnstr , user_2.betwnstr . Objects that do not exist in the database but were specified in a_include_objects will be ignored. Example: Limiting coverage by object owner and name. begin ut . run ( 'unit_test_schema' , ut_coverage_html_reporter (), a_include_objects => ut_varchar2_list ( 'user_1.award_bonus' , 'user_2.betwnstr' ) ); end ; Executes all tests in schema unit_test_schema . Coverage will only be reported on objects user_1.award_bonus , user_2.betwnstr The a_exclude_objects can be used in the same way as a_include_objects . Example: Excluding objects from coverage report by providing a list of object owner/name to be excluded. begin ut . run ( 'unit_test_schema.test_award_bonus' , ut_coverage_html_reporter (), a_exclude_objects => ut_varchar2_list ( 'ut3_user.betwnstr' ) ); end ; Executes test test_award_bonus in schema unit_test_schema . Coverage will be reported on all objects in schema ut3_user except the betwnstr object. Note Filtering using a_include_objects and a_exclude_objects is only applicable when gathering coverage for a schema. Those filters are not applied when reporting coverage on project files. Note When running coverage on schema objects, all source code of package bodies, functions, procedures, type bodies and triggers that were not executed will be reported as having 0% code coverage and all source code lines will show as uncovered. This is different than the behavior when gathering coverage on project files. Project based Coverage \u00b6 utPLSQL provides reporters that produce reports consumable by external tools like Sonar / SonarCloud & Coveralls . Services like Sonar, Coveralls and others perform analysis based on source code in project files. They are abstracted from database, schema names, packages, procedures and functions, and operate on a more generic concept of project source code. To be able to effectively use reporters dedicated for those tools, utPLSQL provides functionality for mapping database object names to project files. There are a few significant differences when running coverage on project files compared to running coverage on schema(s). - Coverage is only reported on objects that were successfully mapped to project files. - Project files (database objects) that were not executed at all are not reported as fully uncovered. It is up to the consumer (Sonar/Coveralls) to determine if project file should be considered as 0% coverage or just ignored. In order to successfully use coverage on project files, those files must be mapped to database objects. Though you can gather project based code coverage directly using exec ut.run(...) , it is highly recommended to use utPLSQL-cli command line client. The examples below are using utPLSQL-cli to execute tests and gather coverage information. File mapping using default parameters \u00b6 The example below illustrates a directory structure supported by the default parameters of utPLSQL. The structure represents a multi-schema project with file names indicating object owner. C: \\my_project \\sources \\hotel.add_rooms_content.prc \\hotel.remove_rooms_by_name.prc \\hotel.rooms.tbl \\hr.award_bonus.prc \\hr.betwnstr.fnc \\hr.employees_test.tbl \\tests \\hotel.test_add_room_content.pkb \\hotel.test_add_room_content.pks \\hotel.test_remove_rooms_by_name.pkb \\hotel.test_remove_rooms_by_name.pks \\hr.test_award_bonus.pkb \\hr.test_award_bonus.pks \\hr.test_betwnstr.pkb \\hr.test_betwnstr.pks By default, utPLSQL will convert file paths into database objects using the following regular expression /(((\\w|[$#])+)\\.)?((\\w|[$#])+)\\.(\\w{3})$ - object owner (if it is present) is identified by the expression in the second set of brackets - object name is identified by the expression in the fourth set of brackets - object type is identified by the expression in the sixth set of brackets Note utPLSQL will replace any '\\' with '/' for the purpose of mapping files to objects. The paths shown in the results will remain (contain '\\' where it was present). This is done to simplify the syntax of regular expressions. Regular expression will always use '/' as a directory separator on a file path regardless of whether you're on a Windows or Unix system. Note Below examples assume that you have downloaded latest version of utPLSQL-cli , extracted it into your projects root directory (my_project) and placed ojdbc8.jar and orai18n.jar files in utPLSQL-cli\\lib directory. The examples assume that you run the utPLSQL-cli from my_project directory. Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_host:db_port/db_service_name ^ -p=hr,hotel ^ -source_path=sources ^ -test_path=tests ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_host:db_port/db_service_name \\ -p = hr,hotel \\ -source_path = sources \\ -test_path = tests \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml The above commands will: - connect as user test_runner - run all utPLSQL v3 tests for users hr , hotel - map database code to project files in sources directory and save code coverage results into coverage.html - map test packages to project files in tests directory and save test results into test_results.xml To better understand the default regular expression used, have a look here . Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml Using custom regular expressions \u00b6 If your project directory structure is different, you can use additional configuration parameters to tell utPLSQL how the project files are to be mapped into database objects. Example: Using custom regular expressions on a multi-schema project with separate directories for each object owner. C: \\my_project \\sources \\hotel \\add_rooms_content.prc \\remove_rooms_by_name.prc \\rooms.tbl \\hr \\award_bonus.prc \\betwnstr.fnc \\employees_test.tbl \\tests \\hotel \\test_add_room_content.pkb \\test_add_room_content.pks \\test_remove_rooms_by_name.pkb \\test_remove_rooms_by_name.pks \\hr \\test_award_bonus.pkb \\test_award_bonus.pks \\test_betwnstr.pkb \\test_betwnstr.pks The command below will gather coverage and map files to database objects using custom regular expression. Note that the owner/name/type subexpressions don't need to be explicitly specified if they are same as default values ( 2/3/4 ). In the below example, they were specified explicitly only for source_path , test_path doesn't have subexpressions specified and so they are default (2/3/4). Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^ -p=hr,hotel ^ -source_path=sources ^ -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" ^ -owner_subexpression=2 ^ -name_subexpression=3 ^ -type_subexpression=4 ^ -test_path=tests -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml ^ Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_url \\ -source_path = sources \\ -regex_expression = \"/((\\w+)/)?(\\w+)\\.(\\w{3}) $ \" \\ -owner_subexpression = 2 \\ -name_subexpression = 3 \\ -type_subexpression = 4 \\ -test_path = tests -regex_expression = \"/((\\w+)/)?(\\w+)\\.(\\w{3}) $ \" \\ -owner_subexpression = 2 \\ -name_subexpression = 3 \\ -type_subexpression = 4 \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml You can specify different mapping rules for source files and for test files - see utPLSQL-cli readme for details. To better understand the regular expression used, have a look here . Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml Explicitly specifying object owner \u00b6 When dealing with projects that operate within a single schema the project structure probably doesn't indicate the owner. In such scenarios, you can explicitly specify the object owner for both tests and source code. Example: Single-schema project - no indication of object owner C: \\my_project \\sources \\betwnstr.fnc \\tests \\test_betwnstr.pkb \\test_betwnstr.pks The command below will gather coverage and map files to database objects. For the database objects mapped to souces directory user code_owner will be used. For the database objects mapped to tests directory user tests_owner will be used. Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^ -p=tests_owner ^ -source_path=sources -owner=code_owner ^ -test_path=tests -owner=tests_owner ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_url \\ -p = tests_owner \\ -source_path = sources -owner = code_owner \\ -test_path = tests -owner = tests_owner \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml Note When the project folder structure does not provide any information about source code owner and test owner, you can specify the owner for tests and owner for code explicitly. Such project configuration supports only single-owner for source code and single owner for tests. Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml Custom mapping of object types \u00b6 By default, when mapping project files to database objects, utPLSQL will identify the object type by file extension. The table below represents the default mapping of file extensions to database object types. file extension object type tpb type body pkb package body bdy package body trg trigger fnc function prc procedure If your project naming convention differs and your file extensions do not match the above, or you simply name all of your files with .sql suffix, you can still use utPLSQL, but you need to provide custom mapping for object types. Example: Multi-schema project with separate directories for each object owner and object type C: \\my_project \\sources \\hotel \\functions \\packages \\packages_bodies \\procedures \\add_rooms_content.sql \\remove_rooms_by_name.sql \\tables \\rooms.sql \\triggers \\types \\type_bodies \\hr \\functions \\betwnstr.sql \\packages \\package_bodies \\procedures \\award_bonus.sql \\tables \\employees_test.sql \\triggers \\types \\types_bodies \\tests \\hotel \\packages \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\packages_bodies \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\hr \\packages \\test_award_bonus.sql \\test_betwnstr.sql \\packages_bodies \\test_award_bonus.sql \\test_betwnstr.sql Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^ -p=hr,hotel ^ -source_path=sources ^ -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" ^ -type_mapping=\"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" ^ -owner_subexpression=1 ^ -name_subexpression=3 ^ -type_subexpression=2 ^ -test_path=tests -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" ^ -type_mapping=\"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" ^ -owner_subexpression=1 ^ -name_subexpression=3 ^ -type_subexpression=2 ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_urll \\ -p = hr,hotel \\ -source_path = sources \\ -regex_expression = \"/(\\w+)/(\\w+)/(\\w+)\\..{3} $ \" \\ -type_mapping = \"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" \\ -owner_subexpression = 1 \\ -name_subexpression = 3 \\ -type_subexpression = 2 \\ -test_path = tests -regex_expression = \"/(\\w+)/(\\w+)/(\\w+)\\..{3} $ \" \\ -type_mapping = \"body=PACKAGE BODY/type_body=TYPE BODY/trigger=TRIGGER\" \\ -owner_subexpression = 1 \\ -name_subexpression = 3 \\ -type_subexpression = 2 \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml The parameter type_mapping accepts a list of a key-value pairs representing a mapping of regex subexpression to database object type. To better understand the regular expression used, have a look here . Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml Object-file mapping rules \u00b6 In order to allow deterministic and accurate mapping of database source-code into project files, the project directory and file structure needs to meet certain criteria. - Source code is kept separate from test code (separate directories) - Each database (source-code) object is stored in individual file. Package/type specification is kept separate from it's body. - File name (file path) contains name of database object - Each file-path clearly identifies object type (by file extension) - Each file contains representation of database object \"as is\". No extra commands (like set echo off ALTER SESSION SET PLSQL_CCFLAGS = 'debug:TRUE'; ) or blank lines are present before CREATE TYPE , CREATE TYPE etc. - When project is spanning across multiple database schemes, each file-path clearly and uniformly identifies object owner File mapping from SQL \u00b6 The ut.run command provides interface to map project into database objects when executing tests. While it is much easier to perform mapping directly from command line, it is possible to achieve similar functionality from any SQL client. The main differences when using the ut.run(...) command, will be: - you can only use single reporter and therefore will get only one report from test execution - you need to provide fill list of project files rather than point to sources and tests directories Example project directory structure. C: \\my_project \\sources \\hotel \\functions \\packages \\packages_bodies \\procedures \\add_rooms_content.sql \\remove_rooms_by_name.sql \\tables \\rooms.sql \\triggers \\types \\type_bodies \\hr \\functions \\betwnstr.sql \\packages \\package_bodies \\procedures \\award_bonus.sql \\tables \\employees_test.sql \\triggers \\types \\types_bodies \\tests \\hotel \\packages \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\packages_bodies \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\hr \\packages \\test_award_bonus.sql \\test_betwnstr.sql \\packages_bodies \\test_award_bonus.sql \\test_betwnstr.sql To execute all tests and map database source code into source file names you could use the following command in any SQL client: begin ut . run ( ut_varchar2_list ( 'hr' , 'hotel' ), ut_coverage_html_reporter (), a_source_file_mappings => ut_file_mapper . build_file_mappings ( a_file_paths => ut_varchar2_list ( 'sources\\hotel\\procedures\\add_rooms_content.sql' , 'sources\\hotel\\procedures\\remove_rooms_by_name.sql' , 'sources\\hotel\\tables\\rooms.sql' , 'sources\\hr\\functions\\betwnstr.sql' , 'sources\\hr\\procedures\\award_bonus.sql' , 'sources\\hr\\tables\\employees_test.sql' ), a_regex_pattern => '/(\\w+)/(\\w+)/(\\w+)\\..{3}$' , a_object_owner_subexpression => 1 , a_object_name_subexpression => 3 , a_object_type_subexpression => 2 , a_file_to_object_type_mapping => ut_key_value_pairs ( ut_key_value_pair ( 'packages_bodies' , 'PACKAGE BODY' ), ut_key_value_pair ( 'types_bodies' , 'TYPE BODY' ), ut_key_value_pair ( 'triggers' , 'TRIGGER' ), ut_key_value_pair ( 'procedures' , 'PROCEDURE' ), ut_key_value_pair ( 'functions' , 'FUNCTION' ) ) ) ); end ; To execute all tests and map database tests code into test file names you could use the following command in any SQL client: begin ut . run ( ut_varchar2_list ( 'hr' , 'hotel' ), ut_sonar_test_reporter (), a_test_file_mappings => ut_file_mapper . build_file_mappings ( a_file_paths => ut_varchar2_list ( 'tests\\hotel\\packages\\test_add_room_content.sql' , 'tests\\hotel\\packages\\test_remove_rooms_by_name.sql' , 'tests\\hotel\\packages_bodies\\test_add_room_content.sql' , 'tests\\hotel\\packages_bodies\\test_remove_rooms_by_name.sql' , 'tests\\hr\\packages\\test_award_bonus.sql' , 'tests\\hr\\packages\\test_betwnstr.sql' , 'tests\\hr\\packages_bodies\\test_award_bonus.sql' , 'tests\\hr\\packages_bodies\\test_betwnstr.sql' ), a_regex_pattern => '/(\\w+)/(\\w+)/(\\w+)\\..{3}$' , a_object_owner_subexpression => 1 , a_object_name_subexpression => 3 , a_object_type_subexpression => 2 , a_file_to_object_type_mapping => ut_key_value_pairs ( ut_key_value_pair ( 'packages_bodies' , 'PACKAGE BODY' ), ut_key_value_pair ( 'types_bodies' , 'TYPE BODY' ), ut_key_value_pair ( 'triggers' , 'TRIGGER' ), ut_key_value_pair ( 'procedures' , 'PROCEDURE' ), ut_key_value_pair ( 'functions' , 'FUNCTION' ) ) ) ); end ;","title":"Code coverage"},{"location":"userguide/coverage.html#coverage","text":"utPLSQL comes with a built-in coverage reporting engine. The code coverage reporting is based on the DBMS_PROFILER package provided with Oracle database. Code coverage is gathered for the following source types: * package bodies * type bodies * triggers * procedures * functions Note The package and type specifications are explicitly excluded from code coverage analysis. This limitation is introduced to avoid false-negatives. Typically package specifications contain no executable code. The only exception is initialization of global constants and variables in package specification. Since most package specifications are not executable at all, there is no information available on the number of lines covered and those would be reported as 0% covered, which is not desirable. To obtain information about code coverage of your unit tests, all you need to do is run your unit tests with one of built-in code coverage reporters. The following code coverage reporters are supplied with utPLSQL: * ut_coverage_html_reporter - generates a HTML coverage report providing summary and detailed information on code coverage. The HTML reporter is based on the open-source simplecov-html reporter for Ruby. It includes source code of the code that was covered (if possible) * ut_coveralls_reporter - generates a Coveralls compatible JSON coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by cloud services like Coveralls * ut_coverage_sonar_reporter - generates a Sonar Compatible XML coverage report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like SonarQube/SonarCloud * ut_coverage_cobertura_reporter - generates a basic Cobertura coverage (http://cobertura.sourceforge.net/xml/coverage-04.dtd) report providing detailed information on code coverage with line numbers. This coverage report is designed to be consumed by services like TFS and Jenkins. Check this link for an example of XML generated by Java: https://raw.githubusercontent.com/jenkinsci/cobertura-plugin/master/src/test/resources/hudson/plugins/cobertura/coverage-with-data.xml","title":"Coverage"},{"location":"userguide/coverage.html#security-model","text":"utPLSQL code coverage uses DBMS_PROFILER to gather information about the execution of code under test and therefore follows the DBMS_PROFILER's Security Model . In order to be able to gather coverage information, the user executing unit tests needs to be either: * The owner of the code that is being tested * Have the following privileges to be able to gather coverage on code owned by other users: * create any procedure system privilege * execute privilege on the code that is being tested (not only the unit tests) or execute any procedure system privilege If you have execute privilege on the code that is being tested, but do not have create any procedure system privilege, then the code that is being tested will be reported as not covered (coverage = 0%). If you have execute privilege only on the unit tests, but do not have execute privilege on the code that is being tested, the code will not be reported by coverage - as if it did not exist in the database. If the code that is being tested is complied as NATIVE, the code coverage will not be reported as well.","title":"Security model"},{"location":"userguide/coverage.html#running-unit-tests-with-coverage","text":"Using the code coverage functionality is as easy as using any other reporter for the utPLSQL project. You just run your tests from your preferred SQL tool and save the reporter results to a file. All you need to do is pass the constructor of the reporter to your ut.run Example: begin ut . run ( ut_coverage_html_reporter ()); end ; / Executes all unit tests in the current schema, gathers information about code coverage and outputs the HTML text into DBMS_OUTPUT. The ut_coverage_html_reporter will produce an interactive HTML report. You can see a sample of code coverage for the utPLSQL project here The report provides summary information with a list of source code that was expected to be covered. The report allow you to navigate to each source file and inspect line by line coverage.","title":"Running unit tests with coverage"},{"location":"userguide/coverage.html#oracle-122-extended-coverage-with-profiler-and-block-coverage","text":"Using data collected from profiler and block coverage running parallel we are able to enrich information about coverage. For every line recorded by profiler if we have a partially covered same line in block coverage we will display that information presenting line as partially covered, displaying number of block and how many blocks been covered in that line.The feature will be automatically enabled in the Oracle database version 12.2 and higher, for older versions current profiler will be used. utPLSQL installation automatically creates tables needed by dbms_plsql_code_coverage on databases in versions above 12c Release 1. Due to security model of dbms_plsql_code_coverage package, utPLSQL grants access to those tables and creates synonyms for those tables. The access and synonyms will be public when using the headless installation. This approach avoids complexity of forcing every user of utPLSQL framework to create tables on their own. Sample output:","title":"Oracle 12.2 extended coverage with profiler and block coverage"},{"location":"userguide/coverage.html#coverage-reporting-options","text":"There are two distinct ways to gather code coverage: - Coverage on database schema(s) - Coverage on project files Those two options are mutually exclusive and cannot be mixed. By default, when using one of coverage reporters, coverage is gathered on schema(s). The parameters used to execute tests determine if utPLSQL will be using one approach or the other. The database schema(s) containing the tests that were executed during the run will be reported on by coverage reporter. Note Regardless of the options provided, all unit test packages are excluded from the coverage report. Coverage reports provide information only about the tested code. The default behavior of coverage reporting can be altered using invocation parameters.","title":"Coverage reporting options"},{"location":"userguide/coverage.html#schema-based-coverage","text":"To simply gather coverage for all objects in your current schema execute tests with coverage reporting. exec ut . run ( ut_coverage_html_reporter ()); Note When no filters are used, the size of the coverage report will depend two factors: - the type of report (does the report include source code or not) - the amount of source code in the database schema Keep in mind that for schemas containing a lot of code, it can take quite some time to produce the coverage report.","title":"Schema based Coverage"},{"location":"userguide/coverage.html#setting-coverage-schemas","text":"By default, coverage is gathered on the schema(s) derived from suite paths provided to execute tests. This is correct as long as your test packages and tested code share the same schema. So when you run: exec ut . run ( ut_varchar2_list ( 'user_1' , 'user_2' ), ut_coverage_html_reporter ()); Coverage will be gathered on both user_1 and user_2 objects. If your tests live in a different schema from the tested code you may override the default behavior by providing an explicit list of coverage schema names. In the example below, coverage will still be gathered for user_1 and user_2 objects, even thought we run the tests located in schema unit_test_schema exec ut . run ( 'unit_test_schema' , ut_coverage_html_reporter (), a_coverage_schemes => ut_varchar2_list ( 'user_1' , 'user_2' ) );","title":"Setting coverage schema(s)"},{"location":"userguide/coverage.html#filtering-objects-in-coverage-reports","text":"There are two options that can be used to narrow down the scope of coverage report: - a_include_objects - list of [object_owner.].object_name to be included in the coverage report - a_exclude_objects - list of [object_owner.].object_name to be excluded from the coverage report You may specify both include and exclude object lists to gain more control over what needs to be included / excluded from the coverage report. The object owner is optional in the object list. If you do not provide an object owner, the include / exclude list will be considered for every schema used for coverage gathering (as described above). Example: Limiting coverage by object name, for tested code located in the same schema as the unit tests. exec ut . run ( ut_varchar2_list ( 'user_1' , 'user_2' ), ut_coverage_html_reporter (), a_include_objects => ut_varchar2_list ( 'award_bonus' )); Executes all tests in schemas: user_1 and user_2 . Coverage will only be reported on objects user_1.award_bonus , user_2.award_bonus Example: Limiting coverage by object name, for tested code located in different schemas than the unit tests. begin ut . run ( 'unit_test_schema' , ut_coverage_html_reporter (), a_coverage_schemes => ut_varchar2_list ( 'user_1' , 'user_2' ), a_include_objects => ut_varchar2_list ( 'award_bonus' , 'betwnstr' ) ); end ; Executes all tests in schema unit_test_schema . Coverage will only be reported on objects user_1.award_bonus , user_2.award_bonus , user_1.betwnstr , user_2.betwnstr . Objects that do not exist in the database but were specified in a_include_objects will be ignored. Example: Limiting coverage by object owner and name. begin ut . run ( 'unit_test_schema' , ut_coverage_html_reporter (), a_include_objects => ut_varchar2_list ( 'user_1.award_bonus' , 'user_2.betwnstr' ) ); end ; Executes all tests in schema unit_test_schema . Coverage will only be reported on objects user_1.award_bonus , user_2.betwnstr The a_exclude_objects can be used in the same way as a_include_objects . Example: Excluding objects from coverage report by providing a list of object owner/name to be excluded. begin ut . run ( 'unit_test_schema.test_award_bonus' , ut_coverage_html_reporter (), a_exclude_objects => ut_varchar2_list ( 'ut3_user.betwnstr' ) ); end ; Executes test test_award_bonus in schema unit_test_schema . Coverage will be reported on all objects in schema ut3_user except the betwnstr object. Note Filtering using a_include_objects and a_exclude_objects is only applicable when gathering coverage for a schema. Those filters are not applied when reporting coverage on project files. Note When running coverage on schema objects, all source code of package bodies, functions, procedures, type bodies and triggers that were not executed will be reported as having 0% code coverage and all source code lines will show as uncovered. This is different than the behavior when gathering coverage on project files.","title":"Filtering objects in coverage reports"},{"location":"userguide/coverage.html#project-based-coverage","text":"utPLSQL provides reporters that produce reports consumable by external tools like Sonar / SonarCloud & Coveralls . Services like Sonar, Coveralls and others perform analysis based on source code in project files. They are abstracted from database, schema names, packages, procedures and functions, and operate on a more generic concept of project source code. To be able to effectively use reporters dedicated for those tools, utPLSQL provides functionality for mapping database object names to project files. There are a few significant differences when running coverage on project files compared to running coverage on schema(s). - Coverage is only reported on objects that were successfully mapped to project files. - Project files (database objects) that were not executed at all are not reported as fully uncovered. It is up to the consumer (Sonar/Coveralls) to determine if project file should be considered as 0% coverage or just ignored. In order to successfully use coverage on project files, those files must be mapped to database objects. Though you can gather project based code coverage directly using exec ut.run(...) , it is highly recommended to use utPLSQL-cli command line client. The examples below are using utPLSQL-cli to execute tests and gather coverage information.","title":"Project based Coverage"},{"location":"userguide/coverage.html#file-mapping-using-default-parameters","text":"The example below illustrates a directory structure supported by the default parameters of utPLSQL. The structure represents a multi-schema project with file names indicating object owner. C: \\my_project \\sources \\hotel.add_rooms_content.prc \\hotel.remove_rooms_by_name.prc \\hotel.rooms.tbl \\hr.award_bonus.prc \\hr.betwnstr.fnc \\hr.employees_test.tbl \\tests \\hotel.test_add_room_content.pkb \\hotel.test_add_room_content.pks \\hotel.test_remove_rooms_by_name.pkb \\hotel.test_remove_rooms_by_name.pks \\hr.test_award_bonus.pkb \\hr.test_award_bonus.pks \\hr.test_betwnstr.pkb \\hr.test_betwnstr.pks By default, utPLSQL will convert file paths into database objects using the following regular expression /(((\\w|[$#])+)\\.)?((\\w|[$#])+)\\.(\\w{3})$ - object owner (if it is present) is identified by the expression in the second set of brackets - object name is identified by the expression in the fourth set of brackets - object type is identified by the expression in the sixth set of brackets Note utPLSQL will replace any '\\' with '/' for the purpose of mapping files to objects. The paths shown in the results will remain (contain '\\' where it was present). This is done to simplify the syntax of regular expressions. Regular expression will always use '/' as a directory separator on a file path regardless of whether you're on a Windows or Unix system. Note Below examples assume that you have downloaded latest version of utPLSQL-cli , extracted it into your projects root directory (my_project) and placed ojdbc8.jar and orai18n.jar files in utPLSQL-cli\\lib directory. The examples assume that you run the utPLSQL-cli from my_project directory. Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_host:db_port/db_service_name ^ -p=hr,hotel ^ -source_path=sources ^ -test_path=tests ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_host:db_port/db_service_name \\ -p = hr,hotel \\ -source_path = sources \\ -test_path = tests \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml The above commands will: - connect as user test_runner - run all utPLSQL v3 tests for users hr , hotel - map database code to project files in sources directory and save code coverage results into coverage.html - map test packages to project files in tests directory and save test results into test_results.xml To better understand the default regular expression used, have a look here . Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml","title":"File mapping using default parameters"},{"location":"userguide/coverage.html#using-custom-regular-expressions","text":"If your project directory structure is different, you can use additional configuration parameters to tell utPLSQL how the project files are to be mapped into database objects. Example: Using custom regular expressions on a multi-schema project with separate directories for each object owner. C: \\my_project \\sources \\hotel \\add_rooms_content.prc \\remove_rooms_by_name.prc \\rooms.tbl \\hr \\award_bonus.prc \\betwnstr.fnc \\employees_test.tbl \\tests \\hotel \\test_add_room_content.pkb \\test_add_room_content.pks \\test_remove_rooms_by_name.pkb \\test_remove_rooms_by_name.pks \\hr \\test_award_bonus.pkb \\test_award_bonus.pks \\test_betwnstr.pkb \\test_betwnstr.pks The command below will gather coverage and map files to database objects using custom regular expression. Note that the owner/name/type subexpressions don't need to be explicitly specified if they are same as default values ( 2/3/4 ). In the below example, they were specified explicitly only for source_path , test_path doesn't have subexpressions specified and so they are default (2/3/4). Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^ -p=hr,hotel ^ -source_path=sources ^ -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" ^ -owner_subexpression=2 ^ -name_subexpression=3 ^ -type_subexpression=4 ^ -test_path=tests -regex_expression=\"/((\\w+)/)?(\\w+)\\.(\\w{3})$\" ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml ^ Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_url \\ -source_path = sources \\ -regex_expression = \"/((\\w+)/)?(\\w+)\\.(\\w{3}) $ \" \\ -owner_subexpression = 2 \\ -name_subexpression = 3 \\ -type_subexpression = 4 \\ -test_path = tests -regex_expression = \"/((\\w+)/)?(\\w+)\\.(\\w{3}) $ \" \\ -owner_subexpression = 2 \\ -name_subexpression = 3 \\ -type_subexpression = 4 \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml You can specify different mapping rules for source files and for test files - see utPLSQL-cli readme for details. To better understand the regular expression used, have a look here . Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml","title":"Using custom regular expressions"},{"location":"userguide/coverage.html#explicitly-specifying-object-owner","text":"When dealing with projects that operate within a single schema the project structure probably doesn't indicate the owner. In such scenarios, you can explicitly specify the object owner for both tests and source code. Example: Single-schema project - no indication of object owner C: \\my_project \\sources \\betwnstr.fnc \\tests \\test_betwnstr.pkb \\test_betwnstr.pks The command below will gather coverage and map files to database objects. For the database objects mapped to souces directory user code_owner will be used. For the database objects mapped to tests directory user tests_owner will be used. Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^ -p=tests_owner ^ -source_path=sources -owner=code_owner ^ -test_path=tests -owner=tests_owner ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_url \\ -p = tests_owner \\ -source_path = sources -owner = code_owner \\ -test_path = tests -owner = tests_owner \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml Note When the project folder structure does not provide any information about source code owner and test owner, you can specify the owner for tests and owner for code explicitly. Such project configuration supports only single-owner for source code and single owner for tests. Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml","title":"Explicitly specifying object owner"},{"location":"userguide/coverage.html#custom-mapping-of-object-types","text":"By default, when mapping project files to database objects, utPLSQL will identify the object type by file extension. The table below represents the default mapping of file extensions to database object types. file extension object type tpb type body pkb package body bdy package body trg trigger fnc function prc procedure If your project naming convention differs and your file extensions do not match the above, or you simply name all of your files with .sql suffix, you can still use utPLSQL, but you need to provide custom mapping for object types. Example: Multi-schema project with separate directories for each object owner and object type C: \\my_project \\sources \\hotel \\functions \\packages \\packages_bodies \\procedures \\add_rooms_content.sql \\remove_rooms_by_name.sql \\tables \\rooms.sql \\triggers \\types \\type_bodies \\hr \\functions \\betwnstr.sql \\packages \\package_bodies \\procedures \\award_bonus.sql \\tables \\employees_test.sql \\triggers \\types \\types_bodies \\tests \\hotel \\packages \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\packages_bodies \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\hr \\packages \\test_award_bonus.sql \\test_betwnstr.sql \\packages_bodies \\test_award_bonus.sql \\test_betwnstr.sql Windows: utPLSQL-cli\\bin\\utplsql run test_runner/pass@db_url ^ -p=hr,hotel ^ -source_path=sources ^ -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" ^ -type_mapping=\"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" ^ -owner_subexpression=1 ^ -name_subexpression=3 ^ -type_subexpression=2 ^ -test_path=tests -regex_expression=\"/(\\w+)/(\\w+)/(\\w+)\\..{3}$\" ^ -type_mapping=\"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" ^ -owner_subexpression=1 ^ -name_subexpression=3 ^ -type_subexpression=2 ^ -f=ut_coverage_html_reporter -o=coverage.html ^ -f=ut_sonar_test_reporter -o=test_results.xml Bash: utPLSQL-cli/bin/utplsql run test_runner/pass@db_urll \\ -p = hr,hotel \\ -source_path = sources \\ -regex_expression = \"/(\\w+)/(\\w+)/(\\w+)\\..{3} $ \" \\ -type_mapping = \"packages_bodies=PACKAGE BODY/types_bodies=TYPE BODY/triggers=TRIGGER/procedures=PROCEDURE/functions=FUNCTION\" \\ -owner_subexpression = 1 \\ -name_subexpression = 3 \\ -type_subexpression = 2 \\ -test_path = tests -regex_expression = \"/(\\w+)/(\\w+)/(\\w+)\\..{3} $ \" \\ -type_mapping = \"body=PACKAGE BODY/type_body=TYPE BODY/trigger=TRIGGER\" \\ -owner_subexpression = 1 \\ -name_subexpression = 3 \\ -type_subexpression = 2 \\ -f = ut_coverage_html_reporter -o = coverage.html \\ -f = ut_sonar_test_reporter -o = test_results.xml The parameter type_mapping accepts a list of a key-value pairs representing a mapping of regex subexpression to database object type. To better understand the regular expression used, have a look here . Tested code is mapped to files in coverage.html Unit test code is mapped to files in test_results.xml","title":"Custom mapping of object types"},{"location":"userguide/coverage.html#object-file-mapping-rules","text":"In order to allow deterministic and accurate mapping of database source-code into project files, the project directory and file structure needs to meet certain criteria. - Source code is kept separate from test code (separate directories) - Each database (source-code) object is stored in individual file. Package/type specification is kept separate from it's body. - File name (file path) contains name of database object - Each file-path clearly identifies object type (by file extension) - Each file contains representation of database object \"as is\". No extra commands (like set echo off ALTER SESSION SET PLSQL_CCFLAGS = 'debug:TRUE'; ) or blank lines are present before CREATE TYPE , CREATE TYPE etc. - When project is spanning across multiple database schemes, each file-path clearly and uniformly identifies object owner","title":"Object-file mapping rules"},{"location":"userguide/coverage.html#file-mapping-from-sql","text":"The ut.run command provides interface to map project into database objects when executing tests. While it is much easier to perform mapping directly from command line, it is possible to achieve similar functionality from any SQL client. The main differences when using the ut.run(...) command, will be: - you can only use single reporter and therefore will get only one report from test execution - you need to provide fill list of project files rather than point to sources and tests directories Example project directory structure. C: \\my_project \\sources \\hotel \\functions \\packages \\packages_bodies \\procedures \\add_rooms_content.sql \\remove_rooms_by_name.sql \\tables \\rooms.sql \\triggers \\types \\type_bodies \\hr \\functions \\betwnstr.sql \\packages \\package_bodies \\procedures \\award_bonus.sql \\tables \\employees_test.sql \\triggers \\types \\types_bodies \\tests \\hotel \\packages \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\packages_bodies \\test_add_room_content.sql \\test_remove_rooms_by_name.sql \\hr \\packages \\test_award_bonus.sql \\test_betwnstr.sql \\packages_bodies \\test_award_bonus.sql \\test_betwnstr.sql To execute all tests and map database source code into source file names you could use the following command in any SQL client: begin ut . run ( ut_varchar2_list ( 'hr' , 'hotel' ), ut_coverage_html_reporter (), a_source_file_mappings => ut_file_mapper . build_file_mappings ( a_file_paths => ut_varchar2_list ( 'sources\\hotel\\procedures\\add_rooms_content.sql' , 'sources\\hotel\\procedures\\remove_rooms_by_name.sql' , 'sources\\hotel\\tables\\rooms.sql' , 'sources\\hr\\functions\\betwnstr.sql' , 'sources\\hr\\procedures\\award_bonus.sql' , 'sources\\hr\\tables\\employees_test.sql' ), a_regex_pattern => '/(\\w+)/(\\w+)/(\\w+)\\..{3}$' , a_object_owner_subexpression => 1 , a_object_name_subexpression => 3 , a_object_type_subexpression => 2 , a_file_to_object_type_mapping => ut_key_value_pairs ( ut_key_value_pair ( 'packages_bodies' , 'PACKAGE BODY' ), ut_key_value_pair ( 'types_bodies' , 'TYPE BODY' ), ut_key_value_pair ( 'triggers' , 'TRIGGER' ), ut_key_value_pair ( 'procedures' , 'PROCEDURE' ), ut_key_value_pair ( 'functions' , 'FUNCTION' ) ) ) ); end ; To execute all tests and map database tests code into test file names you could use the following command in any SQL client: begin ut . run ( ut_varchar2_list ( 'hr' , 'hotel' ), ut_sonar_test_reporter (), a_test_file_mappings => ut_file_mapper . build_file_mappings ( a_file_paths => ut_varchar2_list ( 'tests\\hotel\\packages\\test_add_room_content.sql' , 'tests\\hotel\\packages\\test_remove_rooms_by_name.sql' , 'tests\\hotel\\packages_bodies\\test_add_room_content.sql' , 'tests\\hotel\\packages_bodies\\test_remove_rooms_by_name.sql' , 'tests\\hr\\packages\\test_award_bonus.sql' , 'tests\\hr\\packages\\test_betwnstr.sql' , 'tests\\hr\\packages_bodies\\test_award_bonus.sql' , 'tests\\hr\\packages_bodies\\test_betwnstr.sql' ), a_regex_pattern => '/(\\w+)/(\\w+)/(\\w+)\\..{3}$' , a_object_owner_subexpression => 1 , a_object_name_subexpression => 3 , a_object_type_subexpression => 2 , a_file_to_object_type_mapping => ut_key_value_pairs ( ut_key_value_pair ( 'packages_bodies' , 'PACKAGE BODY' ), ut_key_value_pair ( 'types_bodies' , 'TYPE BODY' ), ut_key_value_pair ( 'triggers' , 'TRIGGER' ), ut_key_value_pair ( 'procedures' , 'PROCEDURE' ), ut_key_value_pair ( 'functions' , 'FUNCTION' ) ) ) ); end ;","title":"File mapping from SQL"},{"location":"userguide/exception-reporting.html","text":"Exception handling and reporting \u00b6 The utPLSQL is responsible for handling exceptions wherever they occur in the test run. utPLSQL is trapping most of the exceptions so that the test execution is not affected by individual tests or test packages throwing an exception. The framework provides a full stacktrace for every exception that was thrown. The stacktrace is clean and does not include any utPLSQL library calls in it. To achieve rerunability, the package state invalidation exceptions (ORA-04068, ORA-04061) are not handled and test execution will be interrupted if such exceptions are encountered. This is because of how Oracle behaves on those exceptions. Test execution can fail for different reasons. The failures on different exceptions are handled as follows: * A test package without body - each --%test is reported as failed with exception, nothing is executed * A test package with invalid body - each --%test is reported as failed with exception, nothing is executed * A test package with invalid spec - package is not considered a valid unit test package and is excluded from execution. When trying to run a test package with invalid spec explicitly, exception is raised. Only valid specifications are parsed for annotations * A test package that is raising an exception in --%beforeall - each --%test is reported as failed with exception, --%test , --%beforeeach , --%beforetest , --%aftertest and --%aftereach are not executed. --%afterall is executed to allow cleanup of whatever was done in --%beforeall * A test package that is raising an exception in --%beforeeach - each --%test is reported as failed with exception, --%test , --%beforetest and --%aftertest is not executed. The --%aftereach and --%afterall blocks are getting executed to allow cleanup of whatever was done in --%before... blocks * A test package that is raising an exception in --%beforetest - the --%test is reported as failed with exception, --%test is not executed. The --%aftertest , --%aftereach and --%afterall blocks are getting executed to allow cleanup of whatever was done in --%before... blocks * A test package that is raising an exception in --%test - the --%test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in --%aftertest - the --%test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in --%aftereach - each --%test is reported as failed with exception. * A test package that is raising an exception in --%afterall - all blocks of the package are executed, as the --%afterall is the last step of package execution. Exception in --%afterall is not affecting test results. A warning with exception stacktrace is displayed in the summary Example of reporting with exception thrown in %beforetest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 39 ORA-06512: at line 6 Finished in ,039346 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %test : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 48 ORA-06512: at line 6 Finished in ,035726 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftertest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 42 ORA-06512: at line 6 Finished in ,045523 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftereach : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content (FAILED - 2) Raises exception when null room name given (FAILED - 3) Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 2) room_with_content error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 3) null_room_name error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 Finished in ,034863 seconds 3 tests, 0 failed, 3 errored, 0 ignored. Example of reporting with exception thrown in %afterall : Remove rooms by name Removes a room without content in it Does not remove room when it has content Raises exception when null room name given Warnings: 1) test_remove_rooms_by_name - Afterall procedure failed: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 35 ORA-06512: at line 6 Finished in ,044902 seconds 3 tests, 0 failed, 0 errored, 0 ignored. 1 warning(s)","title":"Error handling and reporting"},{"location":"userguide/exception-reporting.html#exception-handling-and-reporting","text":"The utPLSQL is responsible for handling exceptions wherever they occur in the test run. utPLSQL is trapping most of the exceptions so that the test execution is not affected by individual tests or test packages throwing an exception. The framework provides a full stacktrace for every exception that was thrown. The stacktrace is clean and does not include any utPLSQL library calls in it. To achieve rerunability, the package state invalidation exceptions (ORA-04068, ORA-04061) are not handled and test execution will be interrupted if such exceptions are encountered. This is because of how Oracle behaves on those exceptions. Test execution can fail for different reasons. The failures on different exceptions are handled as follows: * A test package without body - each --%test is reported as failed with exception, nothing is executed * A test package with invalid body - each --%test is reported as failed with exception, nothing is executed * A test package with invalid spec - package is not considered a valid unit test package and is excluded from execution. When trying to run a test package with invalid spec explicitly, exception is raised. Only valid specifications are parsed for annotations * A test package that is raising an exception in --%beforeall - each --%test is reported as failed with exception, --%test , --%beforeeach , --%beforetest , --%aftertest and --%aftereach are not executed. --%afterall is executed to allow cleanup of whatever was done in --%beforeall * A test package that is raising an exception in --%beforeeach - each --%test is reported as failed with exception, --%test , --%beforetest and --%aftertest is not executed. The --%aftereach and --%afterall blocks are getting executed to allow cleanup of whatever was done in --%before... blocks * A test package that is raising an exception in --%beforetest - the --%test is reported as failed with exception, --%test is not executed. The --%aftertest , --%aftereach and --%afterall blocks are getting executed to allow cleanup of whatever was done in --%before... blocks * A test package that is raising an exception in --%test - the --%test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in --%aftertest - the --%test is reported as failed with exception. The execution of other blocks continues normally * A test package that is raising an exception in --%aftereach - each --%test is reported as failed with exception. * A test package that is raising an exception in --%afterall - all blocks of the package are executed, as the --%afterall is the last step of package execution. Exception in --%afterall is not affecting test results. A warning with exception stacktrace is displayed in the summary Example of reporting with exception thrown in %beforetest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 39 ORA-06512: at line 6 Finished in ,039346 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %test : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 48 ORA-06512: at line 6 Finished in ,035726 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftertest : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content Raises exception when null room name given Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 42 ORA-06512: at line 6 Finished in ,045523 seconds 3 tests, 0 failed, 1 errored, 0 ignored. Example of reporting with exception thrown in %aftereach : Remove rooms by name Removes a room without content in it (FAILED - 1) Does not remove room when it has content (FAILED - 2) Raises exception when null room name given (FAILED - 3) Failures: 1) remove_empty_room error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 2) room_with_content error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 3) null_room_name error: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 31 ORA-06512: at line 6 Finished in ,034863 seconds 3 tests, 0 failed, 3 errored, 0 ignored. Example of reporting with exception thrown in %afterall : Remove rooms by name Removes a room without content in it Does not remove room when it has content Raises exception when null room name given Warnings: 1) test_remove_rooms_by_name - Afterall procedure failed: ORA-20001: Test exception ORA-06512: at \"UT3.TEST_REMOVE_ROOMS_BY_NAME\", line 35 ORA-06512: at line 6 Finished in ,044902 seconds 3 tests, 0 failed, 0 errored, 0 ignored. 1 warning(s)","title":"Exception handling and reporting"},{"location":"userguide/expectations.html","text":"Expectation concepts \u00b6 Validation of the code under test (the tested logic of procedure/function etc.) is performed by comparing the actual data against the expected data. utPLSQL uses a combination of expectation and matcher to perform the check on the data. Example of a unit test procedure body. begin ut . expect ( 'the tested value' , 'optional custom failure message' ). to_ ( equal ( 'the expected value' ) ); end ; Expectation is a set of the expected value(s), actual values(s) and the matcher(s) to run on those values. You can also add a custom failure message for an expectation. Matcher defines the comparison operation to be performed on expected and actual values. Pseudo-code: ut . expect ( a_actual { data - type } [, a_message { varchar2 } ] ). to_ ( { matcher } ); ut . expect ( a_actual { data - type } [, a_message { varchar2 } ] ). not_to ( { matcher } ); All matchers have shortcuts like below, sou you don't need to surround matcher with brackets, unless you want to pass it as parameter to the expectation. ut . expect ( a_actual { data - type } ). to_ { matcher } ; ut . expect ( a_actual { data - type } ). not_to_ { matcher } ; Providing a custom failure message \u00b6 You can provide a custom failure message as second argument for the expectation. -- Pseudocode ut . expect ( a_actual { data - type } , a_message { varchar2 } ). to_ { matcher } ; -- Example ut . expect ( 'supercat' , 'checked superhero-animal was not a dog' ). to_ ( equal ( 'superdog' ) ); If the message is provided, it is being added to the normal failure message returned by the matcher. This is mostly useful when your expectations accept dynamic content, as you can provide additional context to make failing test results more readable. Dynamic tests example \u00b6 You have a bunch of tables and an archive functionality for them and you want to test if the things you put into live-tables are removed from live-tables and present in archive-tables. procedure test_data_existance ( i_tableName varchar2 ) as v_count_real integer ; v_count_archive integer ; begin execute immediate 'select count(*) from ' || i_tablename || '' into v_count_real ; execute immediate 'select count(*) from ' || i_tablename || '_ARCHIVE' into v_count_archive ; ut . expect ( v_count_archive , 'failure checking entry-count of ' || i_tablename || '_archive' ). to_ ( equal ( 1 ) ); ut . expect ( v_count_real , 'failure checking entry-count of ' || i_tablename ). to_ ( equal ( 0 ) ); end ; procedure test_archive_data as begin -- Arrange -- insert several data into real-tables here -- Act package_to_test . archive_data (); -- Assert test_data_existance ( 'TABLE_A' ); test_data_existance ( 'TABLE_B' ); test_data_existance ( 'TABLE_C' ); test_data_existance ( 'TABLE_D' ); end ; A failed output will look like this: Failures: 1) test_archive_data \"failure checking entry-count of table_a_archive\" Actual: 2 (number) was expected to equal: 1 (number) at \"UT_TEST_PACKAGE.TEST_DATA_EXISTANCE\", line 12 ut.expect( v_count_archive, 'failure checking entry-count of ' || i_tablename || '_archive' ).to_( equal(1) ); Expecting exceptions \u00b6 Testing is not limited to checking for happy-path scenarios. When writing tests, you often want to check that in specific scenarios, an exception is thrown. Use the --%throws annotation, to test for expected exceptions Example: create or replace function divide ( x varchar2 , y varchar2 ) return number is begin return x / y ; end ; / create or replace package test_divide as --%suite(Divide function) --%test(Return divided numbers) procedure divides_numbers ; --%test(Throws divisor equal) --%throws(-01476) procedure raises_divisor_exception ; end ; / create or replace package body test_divide is procedure divides_numbers is begin ut3 . ut . expect ( divide ( 6 , 2 )). to_equal ( 3 ); end ; procedure raises_divisor_exception is x integer ; begin x : = divide ( 6 , 0 ); end ; end ; / exec ut3 . ut . run ( 'test_divide' ); For details see documentation of the --%throws annotation. Matchers \u00b6 utPLSQL provides the following matchers to perform checks on the expected and actual values. be_between be_empty be_false be_greater_than be_greater_or_equal be_less_or_equal be_less_than be_like be_not_null be_null be_true equal have_count match be_between \u00b6 Validates that the actual value is between the lower and upper bound. Example: begin ut . expect ( a_actual => 3 ). to_be_between ( a_lower_bound => 1 , a_upper_bound => 3 ); ut . expect ( 3 ). to_be_between ( 1 , 3 ); --or ut . expect ( a_actual => 3 ). to_ ( be_between ( a_lower_bound => 1 , a_upper_bound => 3 ) ); ut . expect ( 3 ). to_ ( be_between ( 1 , 3 ) ); end ; be_empty \u00b6 Unary matcher that validates if the provided dataset is empty. Can be used with BLOB , CLOB , refcursor or nested table / varray passed as ANYDATA Note: BLOB/CLOB that is initialized is not NULL but it is actually equal to empty_blob() / empty_clob() . Usage: procedure test_if_cursor_is_empty is l_cursor sys_refcursor ; begin open l_cursor for select * from dual where 1 = 0 ; ut . expect ( l_cursor ). to_be_empty (); --or ut . expect ( l_cursor ). to_ ( be_empty () ); end ; procedure test_if_cursor_is_empty is l_data ut_varchar2_list ; begin l_data : = ut_varchar2_list (); ut . expect ( anydata . convertCollection ( l_data ) ). to_be_empty (); --or ut . expect ( anydata . convertCollection ( l_data ) ). to_ ( be_empty () ); end ; be_false \u00b6 Unary matcher that validates if the provided value is false. Usage: begin ut . expect ( ( 1 = 0 ) ). to_be_false (); --or ut . expect ( ( 1 = 0 ) ). to_ ( be_false () ); end ; be_greater_or_equal \u00b6 Checks if the actual value is greater or equal than the expected. Usage: begin ut . expect ( sysdate ). to_be_greater_or_equal ( sysdate - 1 ); --or ut . expect ( sysdate ). to_ ( be_greater_or_equal ( sysdate - 1 ) ); end ; be_greater_than \u00b6 Checks if the actual value is greater than the expected. Usage: begin ut . expect ( 2 ). to_be_greater_than ( 1 ); --or ut . expect ( 2 ). to_ ( be_greater_than ( 1 ) ); end ; be_less_or_equal \u00b6 Checks if the actual value is less or equal than the expected. Usage: begin ut . expect ( 3 ). to_be_less_or_equal ( 3 ); --or ut . expect ( 3 ). to_ ( be_less_or_equal ( 3 ) ); end ; be_less_than \u00b6 Checks if the actual value is less than the expected. Usage: begin ut . expect ( 3 ). to_be_less_than ( 2 ); --or ut . expect ( 3 ). to_ ( be_less_than ( 2 ) ); end ; be_like \u00b6 Validates that the actual value is like the expected expression. Usage: begin ut . expect ( 'Lorem_impsum' ). to_be_like ( a_mask => '%rem#_%' , a_escape_char => '#' ); ut . expect ( 'Lorem_impsum' ). to_be_like ( '%rem#_%' , '#' ); --or ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( a_mask => '%rem#_%' , a_escape_char => '#' ) ); ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( '%rem#_%' , '#' ) ); end ; Parameters a_mask and a_escape_char represent valid parameters of the Oracle LIKE condition be_not_null \u00b6 Unary matcher that validates if the actual value is not null. Usage: begin ut . expect ( to_clob ( 'ABC' ) ). to_be_not_null (); --or ut . expect ( to_clob ( 'ABC' ) ). to_ ( be_not_null () ); --or ut . expect ( to_clob ( 'ABC' ) ). not_to ( be_null () ); end ; be_null \u00b6 Unary matcher that validates if the actual value is null. Usage: begin ut . expect ( cast ( null as varchar2 ( 100 )) ). to_be_null (); --or ut . expect ( cast ( null as varchar2 ( 100 )) ). to_ ( be_null () ); end ; be_true \u00b6 Unary matcher that validates if the provided value is true. - boolean Usage: begin ut . expect ( ( 1 = 1 ) ). to_be_true (); --or ut . expect ( ( 1 = 1 ) ). to_ ( be_true () ); end ; have_count \u00b6 Unary matcher that validates if the provided dataset count is equal to expected value. Can be used with refcursor or table type Usage: procedure test_if_cursor_is_empty is l_cursor sys_refcursor ; begin open l_cursor for select * from dual connect by level <= 10 ; ut . expect ( l_cursor ). to_have_count ( 10 ); --or ut . expect ( l_cursor ). to_ ( have_count ( 10 ) ); end ; match \u00b6 Validates that the actual value is matching the expected regular expression. Usage: begin ut . expect ( a_actual => '123-456-ABcd' ). to_match ( a_pattern => '\\d{3}-\\d{3}-[a-z]' , a_modifiers => 'i' ); ut . expect ( 'some value' ). to_match ( '^some.*' ); --or ut . expect ( a_actual => '123-456-ABcd' ). to_ ( match ( a_pattern => '\\d{3}-\\d{3}-[a-z]' , a_modifiers => 'i' ) ); ut . expect ( 'some value' ). to_ ( match ( '^some.*' ) ); end ; Parameters a_pattern and a_modifiers represent a valid regexp pattern accepted by Oracle REGEXP_LIKE condition equal \u00b6 The equal matcher is very restrictive. Test using this matcher succeeds only when the compared data-types are exactly the same. If you are comparing varchar2 to a number will fail even if the text contains the same numeric value as the number. The matcher will also fail when comparing a timestamp to a timestamp with timezone data-type etc. The matcher enables detection data-type changes. If you expect your variable to be a number and it is now some other type, the test will fail and give you early indication of a potential problem. To keep it simple, the equal matcher will only succeed if you compare apples to apples. Example usage function get_animal return varchar2 is begin return 'a dog' ; end ; / create or replace package test_animals_getter is --%suite(Animals getter tests) --%test(get_animal - returns a dog) procedure test_variant_1_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_2_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_3_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_4_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_5_get_animal ; end ; / create or replace package body test_animals_getter is --The below tests perform exactly the same check. --They use different syntax to achieve the goal. procedure test_variant_1_get_animal is l_actual varchar2 ( 100 ) : = 'a dog' ; l_expected varchar2 ( 100 ); begin --Arrange l_actual : = 'a dog' ; --Act l_expected : = get_animal (); --Assert ut . expect ( l_actual ). to_equal ( l_expected ); end ; procedure test_variant_2_get_animal is l_expected varchar2 ( 100 ); begin --Act l_expected : = get_animal (); --Assert ut . expect ( l_expected ). to_equal ( 'a dog' ); end ; procedure test_variant_3_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_equal ( 'a dog' ); end ; procedure test_variant_4_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_equal ( 'a dog' , a_nulls_are_equal => true ); end ; procedure test_variant_5_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_ ( equal ( 'a dog' ) ); end ; procedure test_variant_6_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_ ( equal ( 'a dog' , a_nulls_are_equal => true ) ); end ; end ; Comparing NULLs is by default a success! The a_nulls_are_equal parameter controls the behavior of a null = null comparison. To change the behavior of NULL = NULL comparison pass the a_nulls_are_equal => false to the equal matcher. Comparing cursors, object types, nested tables and varrays \u00b6 utPLSQL is capable of comparing compound data-types including: - ref cursors - object types - nested table/varray types Notes on comparison of compound data \u00b6 Compound data can contain elements of any data-type. This includes blob, clob, object type, nested table, varray or even a nested-cursor within a cursor. Cursors, nested table and varray types are compared as ordered lists of elements . If order of elements differ, expectation will fail. Comparison of compound data is data-type aware. So a column ID NUMBER in a cursor is not the same as ID VARCHAR2(100) , even if they both hold the same numeric values. Comparison of cursor columns containing DATE will only compare date part and ignore time by default. See Comparing cursor data containing DATE fields to check how to enable date-time comparison in cursors. To compare nested table/varray type you need to convert it to anydata by using anydata.convertCollection() To compare object type you need to convert it to anydata by using anydata.convertObject() It is possible to compare PL/SQL records, collections, varrays and associative arrays. To compare this types of data, use cursor comparison feature of utPLSQL and TABLE operator in SQL query On Oracle 11g Release 2 - pipelined table functions are needed (see section Implicit (Shadow) Types in this artcile ) On Oracle 12c and above - use TABLE function on nested tables/varrays/associative arrays of PL/SQL records utPLSQL offers advanced data-comparison options, for comparing compound data-types. The options allow you to: - define columns/attributes to exclude from comparison - define columns/attributes to include in comparison - and more For details on available options and how to use them, read the advanced data comparison guide. Diff functionality for compound data-types \u00b6 When comparing compound data, utPLSQL will determine the difference between the expected and the actual data. The diff includes: - differences in column names, column positions and column data-type for cursor data - only data in columns/rows that differ The diff aims to make it easier to identify what is not expected in the actual data. Consider the following expected cursor data ID (NUMBER) FIRST_NAME (VARCHAR2) LAST_NAME (VARCHAR2) SALARY (NUMBER) 1 JACK SPARROW 10000 2 LUKE SKYWALKER 1000 3 TONY STARK 1000000 And the actual cursor data: GENDER (VARCHAR2) FIRST_NAME (VARCHAR2) LAST_NAME (VARCHAR2) SALARY (VARCHAR2) ID (NUMBER) M JACK SPARROW 25000 1 M TONY STARK 1000000 3 F JESSICA JONES 2345 4 M LUKE SKYWALKER 1000 2 The two datasets above have the following differences: - column ID is misplaced (should be first column but is last) - column SALARY has data-type VARCHAR2 but should be NUMBER - column GENDER exists in actual but not in the expected (it is an Extra column) - data in column SALARY for row number 1 in actual is not matching expected - row number 2 in actual (ID=3) is not matching expected - row number 3 in actual (ID=4) is not matching expected - row number 4 in actual (ID=2) is not expected in results (Extra row in actual) utPLSQL will report all of the above differences in a readable format to help you identify what is not correct in the compared dataset. Below example illustrates, how utPLSQL will report such differences. create or replace package test_cursor_compare as --%suite --%test procedure do_test ; end ; / create or replace package body test_cursor_compare as procedure do_test is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select 1 as ID , 'JACK' as FIRST_NAME , 'SPARROW' AS LAST_NAME , 10000 AS SALARY from dual union all select 2 as ID , 'LUKE' as FIRST_NAME , 'SKYWALKER' AS LAST_NAME , 1000 AS SALARY from dual union all select 3 as ID , 'TONY' as FIRST_NAME , 'STARK' AS LAST_NAME , 100000 AS SALARY from dual ; open l_actual for select 'M' AS GENDER , 'JACK' as FIRST_NAME , 'SPARROW' AS LAST_NAME , 1 as ID , '25000' AS SALARY from dual union all select 'M' AS GENDER , 'TONY' as FIRST_NAME , 'STARK' AS LAST_NAME , 3 as ID , '100000' AS SALARY from dual union all select 'F' AS GENDER , 'JESSICA' as FIRST_NAME , 'JONES' AS LAST_NAME , 4 as ID , '2345' AS SALARY from dual union all select 'M' AS GENDER , 'LUKE' as FIRST_NAME , 'SKYWALKER' AS LAST_NAME , 2 as ID , '1000' AS SALARY from dual ; ut . expect ( l_actual ). to_equal ( l_expected ); end ; end ; / When the test package is executed using: set serverout on exec ut . run ( 'test_cursor_compare' ); We get the following report: test_cursor_compare do_test [.052 sec] (FAILED - 1) Failures: 1) do_test Actual: refcursor [ count = 4 ] was expected to equal: refcursor [ count = 3 ] Diff: Columns: Column <ID> is misplaced. Expected position: 1, actual position: 4. Column <SALARY> data-type is invalid. Expected: NUMBER, actual: VARCHAR2. Column <GENDER> [position: 1, data-type: CHAR] is not expected in results. Rows: [ 4 differences ] Row No. 1 - Actual: <SALARY>25000</SALARY> Row No. 1 - Expected: <SALARY>10000</SALARY> Row No. 2 - Actual: <FIRST_NAME>TONY</FIRST_NAME><LAST_NAME>STARK</LAST_NAME><ID>3</ID><SALARY>100000</SALARY> Row No. 2 - Expected: <ID>2</ID><FIRST_NAME>LUKE</FIRST_NAME><LAST_NAME>SKYWALKER</LAST_NAME><SALARY>1000</SALARY> Row No. 3 - Actual: <FIRST_NAME>JESSICA</FIRST_NAME><LAST_NAME>JONES</LAST_NAME><ID>4</ID><SALARY>2345</SALARY> Row No. 3 - Expected: <ID>3</ID><FIRST_NAME>TONY</FIRST_NAME><LAST_NAME>STARK</LAST_NAME><SALARY>100000</SALARY> Row No. 4 - Extra: <GENDER>M</GENDER><FIRST_NAME>LUKE</FIRST_NAME><LAST_NAME>SKYWALKER</LAST_NAME><ID>2</ID><SALARY>1000</SALARY> at \"UT3.TEST_CURSOR_COMPARE\", line 22 ut.expect(l_actual).to_equal(l_expected); Finished in .053553 seconds 1 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s) utPLSQL identifies and reports on columns: - column misplacement - column data-type mismatch - extra/missing columns When comparing rows utPLSQL: - reports only mismatched columns when rows match - reports columns existing in both data-sets when whole row is not matching - reports whole extra (not expected) row from actual when actual has extra rows - reports whole missing (expected) row from expected when expected has extra rows Object and nested table data-type comparison examples \u00b6 When comparing object type / nested table / varray, utPLSQL will check: - if data-types match - if data in the compared elements is the same. The diff functionality for objects / nested tables / varrays is similar to diff on cursors. When diffing, utPLSQL will not check name and data-type of individual attribute as the type itself defines the underlying structure. Below examples demonstrate how to compare object and nested table data-types. Object type comparison. create type department as object ( name varchar2 ( 30 )) / create or replace function get_dept return department is begin return department ( 'IT' ); end ; / create or replace package demo_dept as --%suite(demo) --%test(demo of object to object comparison) procedure test_department ; end ; / create or replace package body demo_dept as procedure test_department is v_actual department ; begin --Act/ Assert ut . expect ( anydata . convertObject ( get_dept () ) ). to_equal ( anydata . convertObject ( department ( 'HR' ) ) ); end ; end ; / begin ut . run ( 'demo_dept' ); end ; / drop package demo_dept ; drop function get_dept ; drop type department ; Table type comparison. create type department as object ( name varchar2 ( 30 )) / create type departments as table of department / create or replace function get_depts return departments is begin return departments ( department ( 'IT' ), department ( 'HR' ) ); end ; / create or replace package demo_depts as --%suite(demo) --%test(demo of collection comparison) procedure test_departments ; end ; / create or replace package body demo_depts as procedure test_departments is v_expected departments ; v_actual departments ; begin v_expected : = departments ( department ( 'HR' ), department ( 'IT' ) ); ut . expect ( anydata . convertCollection ( get_depts () ) ). to_equal ( anydata . convertCollection ( v_expected ) ); end ; end ; / begin ut . run ( 'demo_depts' ); end ; / drop package demo_dept ; drop type function get_depts ; drop type departments ; drop type department ; Comparing cursor data containing DATE fields \u00b6 Important note utPLSQL uses XMLType internally to represent rows of the cursor data. This is by far the most flexible method and allows comparison of cursors containing LONG, CLOB, BLOB, user defined types and even nested cursors. Due to the way Oracle handles DATE data type when converting from cursor data to XML, utPLSQL has no control over the DATE formatting. The NLS_DATE_FORMAT setting from the moment the cursor was opened determines the formatting of dates used for cursor data comparison. By default, Oracle NLS_DATE_FORMAT is timeless, so data of DATE datatype, will be compared ignoring the time component. You should use procedures ut.set_nls , ut.reset_nls around cursors that you want to compare in your tests. This way, the DATE data in cursors will be properly formatted for comparison using date-time format. The example below makes use of ut.set_nls , ut.reset_nls , so that the date in l_expected and l_actual is compared using date-time formatting. create table events ( description varchar2 ( 4000 ), event_date date ) / create or replace function get_events return sys_refcursor is l_result sys_refcursor ; begin open l_result for select description , event_date from events ; return l_result ; end ; / create or replace package test_get_events is --%suite(get_events) --%beforeall procedure setup_events ; --%test(returns event within date range) procedure get_events_for_date_range ; end ; / create or replace package body test_get_events is gc_description constant varchar2 ( 30 ) : = 'Test event' ; gc_event_date constant date : = to_date ( '2016-09-08 06:51:22' , 'yyyy-mm-dd hh24:mi:ss' ); gc_second constant number : = 1 / 24 / 60 / 60 ; procedure setup_events is begin insert into events ( description , event_date ) values ( gc_description , gc_event_date ); end ; procedure get_events_for_date_range is l_actual sys_refcursor ; l_expected_bad_date sys_refcursor ; begin --Arrange ut . set_nls (); -- Change the NLS settings for date to be ISO date-time 'YYYY-MM-DD HH24:MI:SS' open l_expected_bad_date for select gc_description as description , gc_event_date + gc_second as event_date from dual ; --Act l_actual : = get_events (); ut . reset_nls (); -- Change the NLS settings after cursors were opened --Assert ut . expect ( l_actual ). not_to_equal ( l_expected_bad_date ); end ; procedure bad_test is l_expected_bad_date sys_refcursor ; begin --Arrange open l_expected_bad_date for select gc_description as description , gc_event_date + gc_second as event_date from dual ; --Act / Assert ut . expect ( get_events () ). not_to_equal ( l_expected_bad_date ); end ; end ; / begin ut . run ( 'test_get_events' ); end ; / drop table events ; drop function get_events ; drop package test_get_events ; In the above example: - The test get_events_for_date_range will succeed, as the l_expected_bad_date cursor contains different date-time then the cursor returned by get_events function call. - The test bad_test will fail, as the column event_date will get compared as DATE without TIME. Negating a matcher \u00b6 Expectations provide a very convenient way to perform a check on a negated matcher. Syntax to check for matcher evaluating to true: begin ut . expect ( a_actual { data - type } ). to_ { matcher } ; ut . expect ( a_actual { data - type } ). to_ ( { matcher } ); end ; Syntax to check for matcher evaluating to false: begin ut . expect ( a_actual { data - type } ). not_to_ { matcher } ; ut . expect ( a_actual { data - type } ). not_to ( { matcher } ); end ; If a matcher evaluated to NULL, then both to_ and not_to will cause the expectation to report failure. Example: begin ut . expect ( null ). to_ ( be_true () ); ut . expect ( null ). not_to ( be_true () ); end ; Since NULL is neither true nor false , both expectations will report failure. Supported data types \u00b6 The matrix below illustrates the data types supported by different matchers. Matcher blob boolean clob date number timestamp timestamp with timezone timestamp with local timezone varchar2 interval year to month interval day to second cursor nested table / varray object be_not_null X X X X X X X X X X X X X X be_null X X X X X X X X X X X X X X be_false X be_true X be_greater_than X X X X X X X be_greater_or_equal X X X X X X X be_less_or_equal X X X X X X X be_less_than X X X X X X X be_between X X X X X X X X equal X X X X X X X X X X X X X X match X X be_like X X be_empty X X X X have_count X X","title":"Expectations"},{"location":"userguide/expectations.html#expectation-concepts","text":"Validation of the code under test (the tested logic of procedure/function etc.) is performed by comparing the actual data against the expected data. utPLSQL uses a combination of expectation and matcher to perform the check on the data. Example of a unit test procedure body. begin ut . expect ( 'the tested value' , 'optional custom failure message' ). to_ ( equal ( 'the expected value' ) ); end ; Expectation is a set of the expected value(s), actual values(s) and the matcher(s) to run on those values. You can also add a custom failure message for an expectation. Matcher defines the comparison operation to be performed on expected and actual values. Pseudo-code: ut . expect ( a_actual { data - type } [, a_message { varchar2 } ] ). to_ ( { matcher } ); ut . expect ( a_actual { data - type } [, a_message { varchar2 } ] ). not_to ( { matcher } ); All matchers have shortcuts like below, sou you don't need to surround matcher with brackets, unless you want to pass it as parameter to the expectation. ut . expect ( a_actual { data - type } ). to_ { matcher } ; ut . expect ( a_actual { data - type } ). not_to_ { matcher } ;","title":"Expectation concepts"},{"location":"userguide/expectations.html#providing-a-custom-failure-message","text":"You can provide a custom failure message as second argument for the expectation. -- Pseudocode ut . expect ( a_actual { data - type } , a_message { varchar2 } ). to_ { matcher } ; -- Example ut . expect ( 'supercat' , 'checked superhero-animal was not a dog' ). to_ ( equal ( 'superdog' ) ); If the message is provided, it is being added to the normal failure message returned by the matcher. This is mostly useful when your expectations accept dynamic content, as you can provide additional context to make failing test results more readable.","title":"Providing a custom failure message"},{"location":"userguide/expectations.html#dynamic-tests-example","text":"You have a bunch of tables and an archive functionality for them and you want to test if the things you put into live-tables are removed from live-tables and present in archive-tables. procedure test_data_existance ( i_tableName varchar2 ) as v_count_real integer ; v_count_archive integer ; begin execute immediate 'select count(*) from ' || i_tablename || '' into v_count_real ; execute immediate 'select count(*) from ' || i_tablename || '_ARCHIVE' into v_count_archive ; ut . expect ( v_count_archive , 'failure checking entry-count of ' || i_tablename || '_archive' ). to_ ( equal ( 1 ) ); ut . expect ( v_count_real , 'failure checking entry-count of ' || i_tablename ). to_ ( equal ( 0 ) ); end ; procedure test_archive_data as begin -- Arrange -- insert several data into real-tables here -- Act package_to_test . archive_data (); -- Assert test_data_existance ( 'TABLE_A' ); test_data_existance ( 'TABLE_B' ); test_data_existance ( 'TABLE_C' ); test_data_existance ( 'TABLE_D' ); end ; A failed output will look like this: Failures: 1) test_archive_data \"failure checking entry-count of table_a_archive\" Actual: 2 (number) was expected to equal: 1 (number) at \"UT_TEST_PACKAGE.TEST_DATA_EXISTANCE\", line 12 ut.expect( v_count_archive, 'failure checking entry-count of ' || i_tablename || '_archive' ).to_( equal(1) );","title":"Dynamic tests example"},{"location":"userguide/expectations.html#expecting-exceptions","text":"Testing is not limited to checking for happy-path scenarios. When writing tests, you often want to check that in specific scenarios, an exception is thrown. Use the --%throws annotation, to test for expected exceptions Example: create or replace function divide ( x varchar2 , y varchar2 ) return number is begin return x / y ; end ; / create or replace package test_divide as --%suite(Divide function) --%test(Return divided numbers) procedure divides_numbers ; --%test(Throws divisor equal) --%throws(-01476) procedure raises_divisor_exception ; end ; / create or replace package body test_divide is procedure divides_numbers is begin ut3 . ut . expect ( divide ( 6 , 2 )). to_equal ( 3 ); end ; procedure raises_divisor_exception is x integer ; begin x : = divide ( 6 , 0 ); end ; end ; / exec ut3 . ut . run ( 'test_divide' ); For details see documentation of the --%throws annotation.","title":"Expecting exceptions"},{"location":"userguide/expectations.html#matchers","text":"utPLSQL provides the following matchers to perform checks on the expected and actual values. be_between be_empty be_false be_greater_than be_greater_or_equal be_less_or_equal be_less_than be_like be_not_null be_null be_true equal have_count match","title":"Matchers"},{"location":"userguide/expectations.html#be_between","text":"Validates that the actual value is between the lower and upper bound. Example: begin ut . expect ( a_actual => 3 ). to_be_between ( a_lower_bound => 1 , a_upper_bound => 3 ); ut . expect ( 3 ). to_be_between ( 1 , 3 ); --or ut . expect ( a_actual => 3 ). to_ ( be_between ( a_lower_bound => 1 , a_upper_bound => 3 ) ); ut . expect ( 3 ). to_ ( be_between ( 1 , 3 ) ); end ;","title":"be_between"},{"location":"userguide/expectations.html#be_empty","text":"Unary matcher that validates if the provided dataset is empty. Can be used with BLOB , CLOB , refcursor or nested table / varray passed as ANYDATA Note: BLOB/CLOB that is initialized is not NULL but it is actually equal to empty_blob() / empty_clob() . Usage: procedure test_if_cursor_is_empty is l_cursor sys_refcursor ; begin open l_cursor for select * from dual where 1 = 0 ; ut . expect ( l_cursor ). to_be_empty (); --or ut . expect ( l_cursor ). to_ ( be_empty () ); end ; procedure test_if_cursor_is_empty is l_data ut_varchar2_list ; begin l_data : = ut_varchar2_list (); ut . expect ( anydata . convertCollection ( l_data ) ). to_be_empty (); --or ut . expect ( anydata . convertCollection ( l_data ) ). to_ ( be_empty () ); end ;","title":"be_empty"},{"location":"userguide/expectations.html#be_false","text":"Unary matcher that validates if the provided value is false. Usage: begin ut . expect ( ( 1 = 0 ) ). to_be_false (); --or ut . expect ( ( 1 = 0 ) ). to_ ( be_false () ); end ;","title":"be_false"},{"location":"userguide/expectations.html#be_greater_or_equal","text":"Checks if the actual value is greater or equal than the expected. Usage: begin ut . expect ( sysdate ). to_be_greater_or_equal ( sysdate - 1 ); --or ut . expect ( sysdate ). to_ ( be_greater_or_equal ( sysdate - 1 ) ); end ;","title":"be_greater_or_equal"},{"location":"userguide/expectations.html#be_greater_than","text":"Checks if the actual value is greater than the expected. Usage: begin ut . expect ( 2 ). to_be_greater_than ( 1 ); --or ut . expect ( 2 ). to_ ( be_greater_than ( 1 ) ); end ;","title":"be_greater_than"},{"location":"userguide/expectations.html#be_less_or_equal","text":"Checks if the actual value is less or equal than the expected. Usage: begin ut . expect ( 3 ). to_be_less_or_equal ( 3 ); --or ut . expect ( 3 ). to_ ( be_less_or_equal ( 3 ) ); end ;","title":"be_less_or_equal"},{"location":"userguide/expectations.html#be_less_than","text":"Checks if the actual value is less than the expected. Usage: begin ut . expect ( 3 ). to_be_less_than ( 2 ); --or ut . expect ( 3 ). to_ ( be_less_than ( 2 ) ); end ;","title":"be_less_than"},{"location":"userguide/expectations.html#be_like","text":"Validates that the actual value is like the expected expression. Usage: begin ut . expect ( 'Lorem_impsum' ). to_be_like ( a_mask => '%rem#_%' , a_escape_char => '#' ); ut . expect ( 'Lorem_impsum' ). to_be_like ( '%rem#_%' , '#' ); --or ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( a_mask => '%rem#_%' , a_escape_char => '#' ) ); ut . expect ( 'Lorem_impsum' ). to_ ( be_like ( '%rem#_%' , '#' ) ); end ; Parameters a_mask and a_escape_char represent valid parameters of the Oracle LIKE condition","title":"be_like"},{"location":"userguide/expectations.html#be_not_null","text":"Unary matcher that validates if the actual value is not null. Usage: begin ut . expect ( to_clob ( 'ABC' ) ). to_be_not_null (); --or ut . expect ( to_clob ( 'ABC' ) ). to_ ( be_not_null () ); --or ut . expect ( to_clob ( 'ABC' ) ). not_to ( be_null () ); end ;","title":"be_not_null"},{"location":"userguide/expectations.html#be_null","text":"Unary matcher that validates if the actual value is null. Usage: begin ut . expect ( cast ( null as varchar2 ( 100 )) ). to_be_null (); --or ut . expect ( cast ( null as varchar2 ( 100 )) ). to_ ( be_null () ); end ;","title":"be_null"},{"location":"userguide/expectations.html#be_true","text":"Unary matcher that validates if the provided value is true. - boolean Usage: begin ut . expect ( ( 1 = 1 ) ). to_be_true (); --or ut . expect ( ( 1 = 1 ) ). to_ ( be_true () ); end ;","title":"be_true"},{"location":"userguide/expectations.html#have_count","text":"Unary matcher that validates if the provided dataset count is equal to expected value. Can be used with refcursor or table type Usage: procedure test_if_cursor_is_empty is l_cursor sys_refcursor ; begin open l_cursor for select * from dual connect by level <= 10 ; ut . expect ( l_cursor ). to_have_count ( 10 ); --or ut . expect ( l_cursor ). to_ ( have_count ( 10 ) ); end ;","title":"have_count"},{"location":"userguide/expectations.html#match","text":"Validates that the actual value is matching the expected regular expression. Usage: begin ut . expect ( a_actual => '123-456-ABcd' ). to_match ( a_pattern => '\\d{3}-\\d{3}-[a-z]' , a_modifiers => 'i' ); ut . expect ( 'some value' ). to_match ( '^some.*' ); --or ut . expect ( a_actual => '123-456-ABcd' ). to_ ( match ( a_pattern => '\\d{3}-\\d{3}-[a-z]' , a_modifiers => 'i' ) ); ut . expect ( 'some value' ). to_ ( match ( '^some.*' ) ); end ; Parameters a_pattern and a_modifiers represent a valid regexp pattern accepted by Oracle REGEXP_LIKE condition","title":"match"},{"location":"userguide/expectations.html#equal","text":"The equal matcher is very restrictive. Test using this matcher succeeds only when the compared data-types are exactly the same. If you are comparing varchar2 to a number will fail even if the text contains the same numeric value as the number. The matcher will also fail when comparing a timestamp to a timestamp with timezone data-type etc. The matcher enables detection data-type changes. If you expect your variable to be a number and it is now some other type, the test will fail and give you early indication of a potential problem. To keep it simple, the equal matcher will only succeed if you compare apples to apples. Example usage function get_animal return varchar2 is begin return 'a dog' ; end ; / create or replace package test_animals_getter is --%suite(Animals getter tests) --%test(get_animal - returns a dog) procedure test_variant_1_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_2_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_3_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_4_get_animal ; --%test(get_animal - returns a dog) procedure test_variant_5_get_animal ; end ; / create or replace package body test_animals_getter is --The below tests perform exactly the same check. --They use different syntax to achieve the goal. procedure test_variant_1_get_animal is l_actual varchar2 ( 100 ) : = 'a dog' ; l_expected varchar2 ( 100 ); begin --Arrange l_actual : = 'a dog' ; --Act l_expected : = get_animal (); --Assert ut . expect ( l_actual ). to_equal ( l_expected ); end ; procedure test_variant_2_get_animal is l_expected varchar2 ( 100 ); begin --Act l_expected : = get_animal (); --Assert ut . expect ( l_expected ). to_equal ( 'a dog' ); end ; procedure test_variant_3_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_equal ( 'a dog' ); end ; procedure test_variant_4_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_equal ( 'a dog' , a_nulls_are_equal => true ); end ; procedure test_variant_5_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_ ( equal ( 'a dog' ) ); end ; procedure test_variant_6_get_animal is begin --Act / Assert ut . expect ( get_animal () ). to_ ( equal ( 'a dog' , a_nulls_are_equal => true ) ); end ; end ; Comparing NULLs is by default a success! The a_nulls_are_equal parameter controls the behavior of a null = null comparison. To change the behavior of NULL = NULL comparison pass the a_nulls_are_equal => false to the equal matcher.","title":"equal"},{"location":"userguide/expectations.html#comparing-cursors-object-types-nested-tables-and-varrays","text":"utPLSQL is capable of comparing compound data-types including: - ref cursors - object types - nested table/varray types","title":"Comparing cursors, object types, nested tables and varrays"},{"location":"userguide/expectations.html#notes-on-comparison-of-compound-data","text":"Compound data can contain elements of any data-type. This includes blob, clob, object type, nested table, varray or even a nested-cursor within a cursor. Cursors, nested table and varray types are compared as ordered lists of elements . If order of elements differ, expectation will fail. Comparison of compound data is data-type aware. So a column ID NUMBER in a cursor is not the same as ID VARCHAR2(100) , even if they both hold the same numeric values. Comparison of cursor columns containing DATE will only compare date part and ignore time by default. See Comparing cursor data containing DATE fields to check how to enable date-time comparison in cursors. To compare nested table/varray type you need to convert it to anydata by using anydata.convertCollection() To compare object type you need to convert it to anydata by using anydata.convertObject() It is possible to compare PL/SQL records, collections, varrays and associative arrays. To compare this types of data, use cursor comparison feature of utPLSQL and TABLE operator in SQL query On Oracle 11g Release 2 - pipelined table functions are needed (see section Implicit (Shadow) Types in this artcile ) On Oracle 12c and above - use TABLE function on nested tables/varrays/associative arrays of PL/SQL records utPLSQL offers advanced data-comparison options, for comparing compound data-types. The options allow you to: - define columns/attributes to exclude from comparison - define columns/attributes to include in comparison - and more For details on available options and how to use them, read the advanced data comparison guide.","title":"Notes on comparison of compound data"},{"location":"userguide/expectations.html#diff-functionality-for-compound-data-types","text":"When comparing compound data, utPLSQL will determine the difference between the expected and the actual data. The diff includes: - differences in column names, column positions and column data-type for cursor data - only data in columns/rows that differ The diff aims to make it easier to identify what is not expected in the actual data. Consider the following expected cursor data ID (NUMBER) FIRST_NAME (VARCHAR2) LAST_NAME (VARCHAR2) SALARY (NUMBER) 1 JACK SPARROW 10000 2 LUKE SKYWALKER 1000 3 TONY STARK 1000000 And the actual cursor data: GENDER (VARCHAR2) FIRST_NAME (VARCHAR2) LAST_NAME (VARCHAR2) SALARY (VARCHAR2) ID (NUMBER) M JACK SPARROW 25000 1 M TONY STARK 1000000 3 F JESSICA JONES 2345 4 M LUKE SKYWALKER 1000 2 The two datasets above have the following differences: - column ID is misplaced (should be first column but is last) - column SALARY has data-type VARCHAR2 but should be NUMBER - column GENDER exists in actual but not in the expected (it is an Extra column) - data in column SALARY for row number 1 in actual is not matching expected - row number 2 in actual (ID=3) is not matching expected - row number 3 in actual (ID=4) is not matching expected - row number 4 in actual (ID=2) is not expected in results (Extra row in actual) utPLSQL will report all of the above differences in a readable format to help you identify what is not correct in the compared dataset. Below example illustrates, how utPLSQL will report such differences. create or replace package test_cursor_compare as --%suite --%test procedure do_test ; end ; / create or replace package body test_cursor_compare as procedure do_test is l_actual sys_refcursor ; l_expected sys_refcursor ; begin open l_expected for select 1 as ID , 'JACK' as FIRST_NAME , 'SPARROW' AS LAST_NAME , 10000 AS SALARY from dual union all select 2 as ID , 'LUKE' as FIRST_NAME , 'SKYWALKER' AS LAST_NAME , 1000 AS SALARY from dual union all select 3 as ID , 'TONY' as FIRST_NAME , 'STARK' AS LAST_NAME , 100000 AS SALARY from dual ; open l_actual for select 'M' AS GENDER , 'JACK' as FIRST_NAME , 'SPARROW' AS LAST_NAME , 1 as ID , '25000' AS SALARY from dual union all select 'M' AS GENDER , 'TONY' as FIRST_NAME , 'STARK' AS LAST_NAME , 3 as ID , '100000' AS SALARY from dual union all select 'F' AS GENDER , 'JESSICA' as FIRST_NAME , 'JONES' AS LAST_NAME , 4 as ID , '2345' AS SALARY from dual union all select 'M' AS GENDER , 'LUKE' as FIRST_NAME , 'SKYWALKER' AS LAST_NAME , 2 as ID , '1000' AS SALARY from dual ; ut . expect ( l_actual ). to_equal ( l_expected ); end ; end ; / When the test package is executed using: set serverout on exec ut . run ( 'test_cursor_compare' ); We get the following report: test_cursor_compare do_test [.052 sec] (FAILED - 1) Failures: 1) do_test Actual: refcursor [ count = 4 ] was expected to equal: refcursor [ count = 3 ] Diff: Columns: Column <ID> is misplaced. Expected position: 1, actual position: 4. Column <SALARY> data-type is invalid. Expected: NUMBER, actual: VARCHAR2. Column <GENDER> [position: 1, data-type: CHAR] is not expected in results. Rows: [ 4 differences ] Row No. 1 - Actual: <SALARY>25000</SALARY> Row No. 1 - Expected: <SALARY>10000</SALARY> Row No. 2 - Actual: <FIRST_NAME>TONY</FIRST_NAME><LAST_NAME>STARK</LAST_NAME><ID>3</ID><SALARY>100000</SALARY> Row No. 2 - Expected: <ID>2</ID><FIRST_NAME>LUKE</FIRST_NAME><LAST_NAME>SKYWALKER</LAST_NAME><SALARY>1000</SALARY> Row No. 3 - Actual: <FIRST_NAME>JESSICA</FIRST_NAME><LAST_NAME>JONES</LAST_NAME><ID>4</ID><SALARY>2345</SALARY> Row No. 3 - Expected: <ID>3</ID><FIRST_NAME>TONY</FIRST_NAME><LAST_NAME>STARK</LAST_NAME><SALARY>100000</SALARY> Row No. 4 - Extra: <GENDER>M</GENDER><FIRST_NAME>LUKE</FIRST_NAME><LAST_NAME>SKYWALKER</LAST_NAME><ID>2</ID><SALARY>1000</SALARY> at \"UT3.TEST_CURSOR_COMPARE\", line 22 ut.expect(l_actual).to_equal(l_expected); Finished in .053553 seconds 1 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s) utPLSQL identifies and reports on columns: - column misplacement - column data-type mismatch - extra/missing columns When comparing rows utPLSQL: - reports only mismatched columns when rows match - reports columns existing in both data-sets when whole row is not matching - reports whole extra (not expected) row from actual when actual has extra rows - reports whole missing (expected) row from expected when expected has extra rows","title":"Diff functionality for compound data-types"},{"location":"userguide/expectations.html#object-and-nested-table-data-type-comparison-examples","text":"When comparing object type / nested table / varray, utPLSQL will check: - if data-types match - if data in the compared elements is the same. The diff functionality for objects / nested tables / varrays is similar to diff on cursors. When diffing, utPLSQL will not check name and data-type of individual attribute as the type itself defines the underlying structure. Below examples demonstrate how to compare object and nested table data-types. Object type comparison. create type department as object ( name varchar2 ( 30 )) / create or replace function get_dept return department is begin return department ( 'IT' ); end ; / create or replace package demo_dept as --%suite(demo) --%test(demo of object to object comparison) procedure test_department ; end ; / create or replace package body demo_dept as procedure test_department is v_actual department ; begin --Act/ Assert ut . expect ( anydata . convertObject ( get_dept () ) ). to_equal ( anydata . convertObject ( department ( 'HR' ) ) ); end ; end ; / begin ut . run ( 'demo_dept' ); end ; / drop package demo_dept ; drop function get_dept ; drop type department ; Table type comparison. create type department as object ( name varchar2 ( 30 )) / create type departments as table of department / create or replace function get_depts return departments is begin return departments ( department ( 'IT' ), department ( 'HR' ) ); end ; / create or replace package demo_depts as --%suite(demo) --%test(demo of collection comparison) procedure test_departments ; end ; / create or replace package body demo_depts as procedure test_departments is v_expected departments ; v_actual departments ; begin v_expected : = departments ( department ( 'HR' ), department ( 'IT' ) ); ut . expect ( anydata . convertCollection ( get_depts () ) ). to_equal ( anydata . convertCollection ( v_expected ) ); end ; end ; / begin ut . run ( 'demo_depts' ); end ; / drop package demo_dept ; drop type function get_depts ; drop type departments ; drop type department ;","title":"Object and nested table data-type comparison examples"},{"location":"userguide/expectations.html#comparing-cursor-data-containing-date-fields","text":"Important note utPLSQL uses XMLType internally to represent rows of the cursor data. This is by far the most flexible method and allows comparison of cursors containing LONG, CLOB, BLOB, user defined types and even nested cursors. Due to the way Oracle handles DATE data type when converting from cursor data to XML, utPLSQL has no control over the DATE formatting. The NLS_DATE_FORMAT setting from the moment the cursor was opened determines the formatting of dates used for cursor data comparison. By default, Oracle NLS_DATE_FORMAT is timeless, so data of DATE datatype, will be compared ignoring the time component. You should use procedures ut.set_nls , ut.reset_nls around cursors that you want to compare in your tests. This way, the DATE data in cursors will be properly formatted for comparison using date-time format. The example below makes use of ut.set_nls , ut.reset_nls , so that the date in l_expected and l_actual is compared using date-time formatting. create table events ( description varchar2 ( 4000 ), event_date date ) / create or replace function get_events return sys_refcursor is l_result sys_refcursor ; begin open l_result for select description , event_date from events ; return l_result ; end ; / create or replace package test_get_events is --%suite(get_events) --%beforeall procedure setup_events ; --%test(returns event within date range) procedure get_events_for_date_range ; end ; / create or replace package body test_get_events is gc_description constant varchar2 ( 30 ) : = 'Test event' ; gc_event_date constant date : = to_date ( '2016-09-08 06:51:22' , 'yyyy-mm-dd hh24:mi:ss' ); gc_second constant number : = 1 / 24 / 60 / 60 ; procedure setup_events is begin insert into events ( description , event_date ) values ( gc_description , gc_event_date ); end ; procedure get_events_for_date_range is l_actual sys_refcursor ; l_expected_bad_date sys_refcursor ; begin --Arrange ut . set_nls (); -- Change the NLS settings for date to be ISO date-time 'YYYY-MM-DD HH24:MI:SS' open l_expected_bad_date for select gc_description as description , gc_event_date + gc_second as event_date from dual ; --Act l_actual : = get_events (); ut . reset_nls (); -- Change the NLS settings after cursors were opened --Assert ut . expect ( l_actual ). not_to_equal ( l_expected_bad_date ); end ; procedure bad_test is l_expected_bad_date sys_refcursor ; begin --Arrange open l_expected_bad_date for select gc_description as description , gc_event_date + gc_second as event_date from dual ; --Act / Assert ut . expect ( get_events () ). not_to_equal ( l_expected_bad_date ); end ; end ; / begin ut . run ( 'test_get_events' ); end ; / drop table events ; drop function get_events ; drop package test_get_events ; In the above example: - The test get_events_for_date_range will succeed, as the l_expected_bad_date cursor contains different date-time then the cursor returned by get_events function call. - The test bad_test will fail, as the column event_date will get compared as DATE without TIME.","title":"Comparing cursor data containing DATE fields"},{"location":"userguide/expectations.html#negating-a-matcher","text":"Expectations provide a very convenient way to perform a check on a negated matcher. Syntax to check for matcher evaluating to true: begin ut . expect ( a_actual { data - type } ). to_ { matcher } ; ut . expect ( a_actual { data - type } ). to_ ( { matcher } ); end ; Syntax to check for matcher evaluating to false: begin ut . expect ( a_actual { data - type } ). not_to_ { matcher } ; ut . expect ( a_actual { data - type } ). not_to ( { matcher } ); end ; If a matcher evaluated to NULL, then both to_ and not_to will cause the expectation to report failure. Example: begin ut . expect ( null ). to_ ( be_true () ); ut . expect ( null ). not_to ( be_true () ); end ; Since NULL is neither true nor false , both expectations will report failure.","title":"Negating a matcher"},{"location":"userguide/expectations.html#supported-data-types","text":"The matrix below illustrates the data types supported by different matchers. Matcher blob boolean clob date number timestamp timestamp with timezone timestamp with local timezone varchar2 interval year to month interval day to second cursor nested table / varray object be_not_null X X X X X X X X X X X X X X be_null X X X X X X X X X X X X X X be_false X be_true X be_greater_than X X X X X X X be_greater_or_equal X X X X X X X be_less_or_equal X X X X X X X be_less_than X X X X X X X be_between X X X X X X X X equal X X X X X X X X X X X X X X match X X be_like X X be_empty X X X X have_count X X","title":"Supported data types"},{"location":"userguide/getting-started.html","text":"Getting started with TDD and utPLSQL \u00b6 utPLSQL is designed in a way that allows you to follow Test Driven Development (TDD) software development process. Below is an example of building a simple function with TDD. Gather requirements \u00b6 We have a requirement to build a function that will return a substring of a string that is passed to the function. The function should accept three parameters: input_string start_position end_position Create a test \u00b6 We will start from the bare minimum and move step by step, executing tests every time we make minimal progress. This way, we assure we don't jump ahead too much and produce code that is untested or untestable. Create test package \u00b6 create or replace package test_betwnstr as --%suite(Between string function) end ; / Execute all tests: begin ut.run(); end; Test results: Between string function Finished in .451423 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Define specification for the test \u00b6 create or replace package test_betwnstr as --%suite(Between string function) --%test(Returns substring from start position to end position) procedure basic_usage ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position (FAILED - 1) Failures: 1) basic_usage ORA-04067: not executed, package body \"UT3_USER.TEST_BETWNSTR\" does not exist ORA-06508: PL/SQL: could not find program unit being called: \"UT3_USER.TEST_BETWNSTR\" ORA-06512: at line 6 Finished in .509673 seconds 1 tests, 0 failed, 1 errored, 0 disabled, 0 warning(s) Well our test is failing as the package specification requires a body. Define body of first test \u00b6 create or replace package body test_betwnstr as procedure basic_usage is begin ut . expect ( betwnstr ( '1234567' , 2 , 5 ) ). to_equal ( '2345' ); end ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position (FAILED - 1) Failures: 1) basic_usage ORA-04063: package body \"UT3_USER.TEST_BETWNSTR\" has errors ORA-06508: PL/SQL: could not find program unit being called: \"UT3_USER.TEST_BETWNSTR\" ORA-06512: at line 6 Finished in .415851 seconds 1 tests, 0 failed, 1 errored, 0 disabled, 0 warning(s) Our test is failing as the test suite package body is invalid. Looks like we need to define the function we want to test. Implement code to fulfill the requirement \u00b6 Define tested function \u00b6 create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin return substr ( a_string , a_start_pos , a_end_pos - a_start_pos ); end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position (FAILED - 1) Failures: 1) basic_usage Actual: '234' (varchar2) was expected to equal: '2345' (varchar2) at \"\"UT3_USER.TEST_BETWNSTR\"\", line 5 Finished in .375178 seconds 1 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s) So now we see that our test works but the function does not return the expected results. Let us fix this and continue from here. Fix the tested function \u00b6 The function returned a string one character short, so we need to add 1 to the substr parameter. create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin return substr ( a_string , a_start_pos , a_end_pos - a_start_pos + 1 ); end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position Finished in .006077 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) So our test is now passing, great! Refactor \u00b6 Once our tests are passing, we can safely refactor (restructure) the code as we have a safety harness in place to ensure that after the restructuring and cleanup of the code, everything is still working. One thing worth mentioning is that refactoring of tests is as important as refactoring of code. Maintainability of both is equally important. Further requirements \u00b6 It seems like our work is done. We have a function that returns a substring from start position to end position. As we move through the process of adding tests, it's very important to think about edge cases. Here is a list of edge cases for our function: start position zero input string is null start position is null end position is null start position is negative start position is bigger than end position start position is negative end position is negative We should define expected behavior for each of these edge cases. Once defined we can start implementing tests for those behaviors and adjust the tested function to meet the requirements specified in the tests. Add test for additional requirement \u00b6 A new requirement was added: Start position zero - should be treated as start position one create or replace package test_betwnstr as --%suite(Between string function) --%test(Returns substring from start position to end position) procedure basic_usage ; --%test(Returns substring when start position is zero) procedure zero_start_position ; end ; / create or replace package body test_betwnstr as procedure basic_usage is begin ut . expect ( betwnstr ( '1234567' , 2 , 5 ) ). to_equal ( '2345' ); end ; procedure zero_start_position is begin ut . expect ( betwnstr ( '1234567' , 0 , 5 ) ). to_equal ( '12345' ); end ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position Returns substring when start position is zero (FAILED - 1) Failures: 1) zero_start_position Actual: '123456' (varchar2) was expected to equal: '12345' (varchar2) at \"\"UT3_USER.TEST_BETWNSTR\"\", line 10 Finished in .232584 seconds 2 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s) Looks like our function does not work as expected for zero start position. Implementing the requirement \u00b6 Let's fix our function so that the new requirement is met create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin if a_start_pos = 0 then return substr ( a_string , a_start_pos , a_end_pos - a_start_pos ); else return substr ( a_string , a_start_pos , a_end_pos - a_start_pos + 1 ); end if ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position Returns substring when start position is zero Finished in .012718 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Great! We have made some visible progress. Refactoring \u00b6 When all tests are passing we can proceed with a safe cleanup of our code. The function works well, but we use the return twice, which is not the best coding practice. An alternative implementation could be cleaner. create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin return substr ( a_string , a_start_pos , a_end_pos - greatest ( a_start_pos , 1 ) + 1 ); end ; / As we refactor we should probably run our tests as often as we compile code, so we know not only that the code compiles, but also works as expected. Between string function Returns substring from start position to end position Returns substring when start position is zero Finished in .013739 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Remaining requirements \u00b6 You may continue on with the remaining edge cases from here. identify requirement define requirement with test run test to check if requirement is met implement code to meet requirement run test to check if requirement is met refactor/cleanup code and tests Hope you will enjoy it as much as we do.","title":"Getting Started"},{"location":"userguide/getting-started.html#getting-started-with-tdd-and-utplsql","text":"utPLSQL is designed in a way that allows you to follow Test Driven Development (TDD) software development process. Below is an example of building a simple function with TDD.","title":"Getting started with TDD and utPLSQL"},{"location":"userguide/getting-started.html#gather-requirements","text":"We have a requirement to build a function that will return a substring of a string that is passed to the function. The function should accept three parameters: input_string start_position end_position","title":"Gather requirements"},{"location":"userguide/getting-started.html#create-a-test","text":"We will start from the bare minimum and move step by step, executing tests every time we make minimal progress. This way, we assure we don't jump ahead too much and produce code that is untested or untestable.","title":"Create a test"},{"location":"userguide/getting-started.html#create-test-package","text":"create or replace package test_betwnstr as --%suite(Between string function) end ; / Execute all tests: begin ut.run(); end; Test results: Between string function Finished in .451423 seconds 0 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)","title":"Create test package"},{"location":"userguide/getting-started.html#define-specification-for-the-test","text":"create or replace package test_betwnstr as --%suite(Between string function) --%test(Returns substring from start position to end position) procedure basic_usage ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position (FAILED - 1) Failures: 1) basic_usage ORA-04067: not executed, package body \"UT3_USER.TEST_BETWNSTR\" does not exist ORA-06508: PL/SQL: could not find program unit being called: \"UT3_USER.TEST_BETWNSTR\" ORA-06512: at line 6 Finished in .509673 seconds 1 tests, 0 failed, 1 errored, 0 disabled, 0 warning(s) Well our test is failing as the package specification requires a body.","title":"Define specification for the test"},{"location":"userguide/getting-started.html#define-body-of-first-test","text":"create or replace package body test_betwnstr as procedure basic_usage is begin ut . expect ( betwnstr ( '1234567' , 2 , 5 ) ). to_equal ( '2345' ); end ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position (FAILED - 1) Failures: 1) basic_usage ORA-04063: package body \"UT3_USER.TEST_BETWNSTR\" has errors ORA-06508: PL/SQL: could not find program unit being called: \"UT3_USER.TEST_BETWNSTR\" ORA-06512: at line 6 Finished in .415851 seconds 1 tests, 0 failed, 1 errored, 0 disabled, 0 warning(s) Our test is failing as the test suite package body is invalid. Looks like we need to define the function we want to test.","title":"Define body of first test"},{"location":"userguide/getting-started.html#implement-code-to-fulfill-the-requirement","text":"","title":"Implement code to fulfill the requirement"},{"location":"userguide/getting-started.html#define-tested-function","text":"create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin return substr ( a_string , a_start_pos , a_end_pos - a_start_pos ); end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position (FAILED - 1) Failures: 1) basic_usage Actual: '234' (varchar2) was expected to equal: '2345' (varchar2) at \"\"UT3_USER.TEST_BETWNSTR\"\", line 5 Finished in .375178 seconds 1 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s) So now we see that our test works but the function does not return the expected results. Let us fix this and continue from here.","title":"Define tested function"},{"location":"userguide/getting-started.html#fix-the-tested-function","text":"The function returned a string one character short, so we need to add 1 to the substr parameter. create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin return substr ( a_string , a_start_pos , a_end_pos - a_start_pos + 1 ); end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position Finished in .006077 seconds 1 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) So our test is now passing, great!","title":"Fix the tested function"},{"location":"userguide/getting-started.html#refactor","text":"Once our tests are passing, we can safely refactor (restructure) the code as we have a safety harness in place to ensure that after the restructuring and cleanup of the code, everything is still working. One thing worth mentioning is that refactoring of tests is as important as refactoring of code. Maintainability of both is equally important.","title":"Refactor"},{"location":"userguide/getting-started.html#further-requirements","text":"It seems like our work is done. We have a function that returns a substring from start position to end position. As we move through the process of adding tests, it's very important to think about edge cases. Here is a list of edge cases for our function: start position zero input string is null start position is null end position is null start position is negative start position is bigger than end position start position is negative end position is negative We should define expected behavior for each of these edge cases. Once defined we can start implementing tests for those behaviors and adjust the tested function to meet the requirements specified in the tests.","title":"Further requirements"},{"location":"userguide/getting-started.html#add-test-for-additional-requirement","text":"A new requirement was added: Start position zero - should be treated as start position one create or replace package test_betwnstr as --%suite(Between string function) --%test(Returns substring from start position to end position) procedure basic_usage ; --%test(Returns substring when start position is zero) procedure zero_start_position ; end ; / create or replace package body test_betwnstr as procedure basic_usage is begin ut . expect ( betwnstr ( '1234567' , 2 , 5 ) ). to_equal ( '2345' ); end ; procedure zero_start_position is begin ut . expect ( betwnstr ( '1234567' , 0 , 5 ) ). to_equal ( '12345' ); end ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position Returns substring when start position is zero (FAILED - 1) Failures: 1) zero_start_position Actual: '123456' (varchar2) was expected to equal: '12345' (varchar2) at \"\"UT3_USER.TEST_BETWNSTR\"\", line 10 Finished in .232584 seconds 2 tests, 1 failed, 0 errored, 0 disabled, 0 warning(s) Looks like our function does not work as expected for zero start position.","title":"Add test for additional requirement"},{"location":"userguide/getting-started.html#implementing-the-requirement","text":"Let's fix our function so that the new requirement is met create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin if a_start_pos = 0 then return substr ( a_string , a_start_pos , a_end_pos - a_start_pos ); else return substr ( a_string , a_start_pos , a_end_pos - a_start_pos + 1 ); end if ; end ; / Execute test package: begin ut.run('test_betwnstr'); end; Test results: Between string function Returns substring from start position to end position Returns substring when start position is zero Finished in .012718 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s) Great! We have made some visible progress.","title":"Implementing the requirement"},{"location":"userguide/getting-started.html#refactoring","text":"When all tests are passing we can proceed with a safe cleanup of our code. The function works well, but we use the return twice, which is not the best coding practice. An alternative implementation could be cleaner. create or replace function betwnstr ( a_string varchar2 , a_start_pos integer , a_end_pos integer ) return varchar2 is begin return substr ( a_string , a_start_pos , a_end_pos - greatest ( a_start_pos , 1 ) + 1 ); end ; / As we refactor we should probably run our tests as often as we compile code, so we know not only that the code compiles, but also works as expected. Between string function Returns substring from start position to end position Returns substring when start position is zero Finished in .013739 seconds 2 tests, 0 failed, 0 errored, 0 disabled, 0 warning(s)","title":"Refactoring"},{"location":"userguide/getting-started.html#remaining-requirements","text":"You may continue on with the remaining edge cases from here. identify requirement define requirement with test run test to check if requirement is met implement code to meet requirement run test to check if requirement is met refactor/cleanup code and tests Hope you will enjoy it as much as we do.","title":"Remaining requirements"},{"location":"userguide/install.html","text":"Downloading latest version of utPLSQL \u00b6 To download latest version of utPLSQL from github on both Unix/Linux as well as Windows machines use the below smippets. Unix/Linux \u00b6 #!/bin/bash # Get the url to latest release \"zip\" file UTPLSQL_DOWNLOAD_URL = $( curl --silent https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest | awk '/browser_download_url/ { print $2 }' | grep \".zip\" | sed 's/\"//g' ) # Download the latest release \"zip\" file curl -Lk \" ${ UTPLSQL_DOWNLOAD_URL } \" -o utPLSQL.zip # Extract downloaded \"zip\" file unzip -q utPLSQL.zip You may download with a one-liner if that is more convenient. #!/bin/bash curl -LOk $( curl --silent https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest | awk '/browser_download_url/ { print $2 }' | grep \".zip\" | sed 's/\"//g' ) Windows \u00b6 To run the script on windows you will need PowerShell 3.0 or above. You will also need .NET 4.0 Framework or above. $archiveName = 'utPLSQL.zip' $latestRepo = Invoke-WebRequest https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest $repo = $latestRepo.Content | Convertfrom-Json $urlList = $repo.assets.browser_download_url Add-Type -assembly \"system.io.compression.filesystem\" foreach ($i in $urlList) { $fileName = $i.substring($i.LastIndexOf( \"/\" ) + 1) if ( $fileName.substring($fileName.LastIndexOf(\".\") + 1) -eq 'zip' ) { Invoke-WebRequest $i -OutFile $archiveName $fileLocation = Get-ChildItem | where {$_.Name -eq $archiveName} if ($fileLocation) { [io.compression.zipfile]::ExtractToDirectory($($fileLocation.FullName),$($fileLocation.DirectoryName)) } } } Headless installation \u00b6 To install the utPLSQL into a new database schema and grant it to public, execute the script install_headless.sql as SYSDBA. The script accepts three optional parameters that define: - username to create as owner of utPLSQL (default ut3 ) - password for owner of utPLSQL (default XNtxj8eEgA6X6b6f ) - tablespace to use for storage of profiler data (default users ) Example invocation of the script from command line: cd source sqlplus sys/sys_pass@db as sysdba @install_headless.sql Invoking script with parameters: cd source sqlplus sys/sys_pass@db as sysdba @install_headless.sql utp3 my_verySecret_password utp3_tablespace The script needs to be executed by SYSDBA , in order to grant access to DBMS_LOCK and DBMS_CRYPTO system packages. Recommended Schema \u00b6 It is highly recommended to install utPLSQL in it's own schema. You are free to choose any name for this schema. Installing uPLSQL into shared schema is really not recommended as you loose isolation of framework. If the installation and utPLSQL owner user is one and the same, the user must have the following Oracle system permissions before you can proceed with the installation. CREATE SESSION CREATE PROCEDURE CREATE TYPE CREATE TABLE CREATE SEQUENCE CREATE VIEW CREATE SYNONYM ALTER SESSION In addition the user must be granted the execute privilege on DBMS_LOCK and DBMS_CRYPTO packages. utPLSQL is using DBMS_PROFILER tables for code coverage. The tables required by DBMS_PROFILER will be created in the installation schema unless they already exist. The uninstall process will not drop profiler tables, as they can potentially be shared and reused for profiling PLSQL code. It is up to DBA to maintain the storage of the profiler tables. Manual installation procedure \u00b6 Creating schema for utPLSQL \u00b6 To create the utPLSQL schema and grant all the required privileges execute script create_utplsql_owner.sql from the source directory with parameters: user name - the name of the user that will own of utPLSQL object password - the password to be set for that user tablespace name - the tablespace name to hold data created during test execution Example invocation: cd source sqlplus sys/sys_password@database as sysdba @create_utPLSQL_owner.sql ut3 ut3 users Installing utPLSQL \u00b6 To install the utPLSQL framework into your database run the /source/install.sql script and provide schema_name where utPLSQL is to be installed. Schema must be created prior to calling the install script. You may install utPLSQL from any account that has sufficient privileges to create objects in other users schema. Example invocation: cd source sqlplus admin/admins_password@database @install.sql ut3 Allowing other users to access the utPLSQL framework \u00b6 In order to allow other users to access utPLSQL, synonyms must be created and privileges granted. You have two options: use grants and synonyms to public, to allow all users to access the framework use synonyms and grants for individual users to limit the access to the framework To grant utPLSQL to public execute script source/create_synonyms_and_grants_for_public.sql and provide schema_name where utPLSQL is installed. Example invocation: cd source sqlplus admin/admins_password@database @create_synonyms_and_grants_for_public.sql ut3 To grant utPLSQL to an individual user, execute scripts source/create_user_grants.sql and source/create_user_synonyms.sql , provide schema_name where utPLSQL is installed and user_name to grant access for. Example invocation: cd source sqlplus ut3_user/ut3_password@database @create_user_grants.sql ut3 hr sqlplus user/user_password@database @create_user_synonyms.sql ut3 hr The following tools that support the SQL*Plus commands can be used to run the installation script: SQL*Plus SQLcl Oracle SQL Developer Additional requirements \u00b6 In order to use the Code Coverage functionality of utPLSQL, users executing the tests must have the CREATE privilege on the PLSQL code that the coverage is gathered on. This is a requirement of DBMS_PROFILER package . In practice, user running tests for PLSQL code that he does not own, needs to have CREATE ANY PROCEDURE/CREATE ANY TRIGGER privileges. Running code coverage on objects that the user does not own will not produce any coverage information without those privileges. Uninstalling utPLSQL \u00b6 To uninstall run uninstall.sql and provide schema_name where utPLSQL is installed. Example invocation: cd source sqlplus admin/admins_password@database @uninstall.sql ut3 The uninstall script will remove all the objects installed by the install script. Additionally, all the public and private synonyms pointing to the objects in the utPLSQL schema will be removed. If you have extended any utPLSQL types such as a custom reporter, these will need to be dropped before the uninstall, otherwise the uninstall script might fail. The uninstall script does not drop the schema. In order for the uninstall to be successful, you need to use the uninstall script that was provided with the exact utPLSQL version installed on your database. i.e. the uninstall script provided with version 3.0.1 will probably not work if you want to remove version 3.0.0 from your database. Version upgrade \u00b6 Currently, the only way to upgrade version of utPLSQL v3.0.0 and above is to remove the previous version and install the new version. Working with utPLSQL v2 \u00b6 If you are using utPLSQL v2, you can still install utPLSQL v3. The only requirement is that utPLSQL v3 needs to be installed in a different schema than utPLSQL v2. utPLSQL v3 and utPLSQL v2 do not collide on public synonym names.","title":"Installation"},{"location":"userguide/install.html#downloading-latest-version-of-utplsql","text":"To download latest version of utPLSQL from github on both Unix/Linux as well as Windows machines use the below smippets.","title":"Downloading latest version of utPLSQL"},{"location":"userguide/install.html#unixlinux","text":"#!/bin/bash # Get the url to latest release \"zip\" file UTPLSQL_DOWNLOAD_URL = $( curl --silent https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest | awk '/browser_download_url/ { print $2 }' | grep \".zip\" | sed 's/\"//g' ) # Download the latest release \"zip\" file curl -Lk \" ${ UTPLSQL_DOWNLOAD_URL } \" -o utPLSQL.zip # Extract downloaded \"zip\" file unzip -q utPLSQL.zip You may download with a one-liner if that is more convenient. #!/bin/bash curl -LOk $( curl --silent https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest | awk '/browser_download_url/ { print $2 }' | grep \".zip\" | sed 's/\"//g' )","title":"Unix/Linux"},{"location":"userguide/install.html#windows","text":"To run the script on windows you will need PowerShell 3.0 or above. You will also need .NET 4.0 Framework or above. $archiveName = 'utPLSQL.zip' $latestRepo = Invoke-WebRequest https://api.github.com/repos/utPLSQL/utPLSQL/releases/latest $repo = $latestRepo.Content | Convertfrom-Json $urlList = $repo.assets.browser_download_url Add-Type -assembly \"system.io.compression.filesystem\" foreach ($i in $urlList) { $fileName = $i.substring($i.LastIndexOf( \"/\" ) + 1) if ( $fileName.substring($fileName.LastIndexOf(\".\") + 1) -eq 'zip' ) { Invoke-WebRequest $i -OutFile $archiveName $fileLocation = Get-ChildItem | where {$_.Name -eq $archiveName} if ($fileLocation) { [io.compression.zipfile]::ExtractToDirectory($($fileLocation.FullName),$($fileLocation.DirectoryName)) } } }","title":"Windows"},{"location":"userguide/install.html#headless-installation","text":"To install the utPLSQL into a new database schema and grant it to public, execute the script install_headless.sql as SYSDBA. The script accepts three optional parameters that define: - username to create as owner of utPLSQL (default ut3 ) - password for owner of utPLSQL (default XNtxj8eEgA6X6b6f ) - tablespace to use for storage of profiler data (default users ) Example invocation of the script from command line: cd source sqlplus sys/sys_pass@db as sysdba @install_headless.sql Invoking script with parameters: cd source sqlplus sys/sys_pass@db as sysdba @install_headless.sql utp3 my_verySecret_password utp3_tablespace The script needs to be executed by SYSDBA , in order to grant access to DBMS_LOCK and DBMS_CRYPTO system packages.","title":"Headless installation"},{"location":"userguide/install.html#recommended-schema","text":"It is highly recommended to install utPLSQL in it's own schema. You are free to choose any name for this schema. Installing uPLSQL into shared schema is really not recommended as you loose isolation of framework. If the installation and utPLSQL owner user is one and the same, the user must have the following Oracle system permissions before you can proceed with the installation. CREATE SESSION CREATE PROCEDURE CREATE TYPE CREATE TABLE CREATE SEQUENCE CREATE VIEW CREATE SYNONYM ALTER SESSION In addition the user must be granted the execute privilege on DBMS_LOCK and DBMS_CRYPTO packages. utPLSQL is using DBMS_PROFILER tables for code coverage. The tables required by DBMS_PROFILER will be created in the installation schema unless they already exist. The uninstall process will not drop profiler tables, as they can potentially be shared and reused for profiling PLSQL code. It is up to DBA to maintain the storage of the profiler tables.","title":"Recommended Schema"},{"location":"userguide/install.html#manual-installation-procedure","text":"","title":"Manual installation procedure"},{"location":"userguide/install.html#creating-schema-for-utplsql","text":"To create the utPLSQL schema and grant all the required privileges execute script create_utplsql_owner.sql from the source directory with parameters: user name - the name of the user that will own of utPLSQL object password - the password to be set for that user tablespace name - the tablespace name to hold data created during test execution Example invocation: cd source sqlplus sys/sys_password@database as sysdba @create_utPLSQL_owner.sql ut3 ut3 users","title":"Creating schema for utPLSQL"},{"location":"userguide/install.html#installing-utplsql","text":"To install the utPLSQL framework into your database run the /source/install.sql script and provide schema_name where utPLSQL is to be installed. Schema must be created prior to calling the install script. You may install utPLSQL from any account that has sufficient privileges to create objects in other users schema. Example invocation: cd source sqlplus admin/admins_password@database @install.sql ut3","title":"Installing utPLSQL"},{"location":"userguide/install.html#allowing-other-users-to-access-the-utplsql-framework","text":"In order to allow other users to access utPLSQL, synonyms must be created and privileges granted. You have two options: use grants and synonyms to public, to allow all users to access the framework use synonyms and grants for individual users to limit the access to the framework To grant utPLSQL to public execute script source/create_synonyms_and_grants_for_public.sql and provide schema_name where utPLSQL is installed. Example invocation: cd source sqlplus admin/admins_password@database @create_synonyms_and_grants_for_public.sql ut3 To grant utPLSQL to an individual user, execute scripts source/create_user_grants.sql and source/create_user_synonyms.sql , provide schema_name where utPLSQL is installed and user_name to grant access for. Example invocation: cd source sqlplus ut3_user/ut3_password@database @create_user_grants.sql ut3 hr sqlplus user/user_password@database @create_user_synonyms.sql ut3 hr The following tools that support the SQL*Plus commands can be used to run the installation script: SQL*Plus SQLcl Oracle SQL Developer","title":"Allowing other users to access the utPLSQL framework"},{"location":"userguide/install.html#additional-requirements","text":"In order to use the Code Coverage functionality of utPLSQL, users executing the tests must have the CREATE privilege on the PLSQL code that the coverage is gathered on. This is a requirement of DBMS_PROFILER package . In practice, user running tests for PLSQL code that he does not own, needs to have CREATE ANY PROCEDURE/CREATE ANY TRIGGER privileges. Running code coverage on objects that the user does not own will not produce any coverage information without those privileges.","title":"Additional requirements"},{"location":"userguide/install.html#uninstalling-utplsql","text":"To uninstall run uninstall.sql and provide schema_name where utPLSQL is installed. Example invocation: cd source sqlplus admin/admins_password@database @uninstall.sql ut3 The uninstall script will remove all the objects installed by the install script. Additionally, all the public and private synonyms pointing to the objects in the utPLSQL schema will be removed. If you have extended any utPLSQL types such as a custom reporter, these will need to be dropped before the uninstall, otherwise the uninstall script might fail. The uninstall script does not drop the schema. In order for the uninstall to be successful, you need to use the uninstall script that was provided with the exact utPLSQL version installed on your database. i.e. the uninstall script provided with version 3.0.1 will probably not work if you want to remove version 3.0.0 from your database.","title":"Uninstalling utPLSQL"},{"location":"userguide/install.html#version-upgrade","text":"Currently, the only way to upgrade version of utPLSQL v3.0.0 and above is to remove the previous version and install the new version.","title":"Version upgrade"},{"location":"userguide/install.html#working-with-utplsql-v2","text":"If you are using utPLSQL v2, you can still install utPLSQL v3. The only requirement is that utPLSQL v3 needs to be installed in a different schema than utPLSQL v2. utPLSQL v3 and utPLSQL v2 do not collide on public synonym names.","title":"Working with utPLSQL v2"},{"location":"userguide/reporters.html","text":"utPLSQL provides the following reporting formats. Documentation reporter \u00b6 The ut_documentation_reporter is the default reporting format used by the framework. It provides a human readable test results. To invoke tests with documentation reporter use one of following calls from sql console (SQLPlus) exec ut.run(); exec ut.run(ut_documentation_reporter()); Example outputs from documentation reporter. The documentation report provides the following information. - Test suite name or test package name (nested with suitepath if suitepath is used) - Test description name or test procedure name - Information about test failing (FAILED - n) - Information about disabled test (IGNORED) - List of all errors and failures - Summary with total number of tests, number of tests with status and timing for the execution Color output from documentation reporter \u00b6 When invoking tests with documentation reporter and your command line supports ANSICONSOLE (default on Unix) available for Windows , you can obtain the coloured outputs from the documentation reporter. To invoke tests with documentation reporter in color mode use one of following calls. exec ut.run(a_color_console=>true); exec ut.run(ut_documentation_reporter(), a_color_console=>true); Example outputs from documentation reporter. JUnit reporter \u00b6 Most of continuous integration servers (like Jenkins) are capable of consuming unit test execution results in JUnit format. The ut_junit_reporter in earlier version referred as ut_xunit_reporter is producing outcomes as JUnit-compatible XML unit test report, that can be used by CI servers to display their custom reports and provide metrics (like tests execution trends). Please note that in previous versions it was called ut_xunit_reporter and for backward compatibility that name still exists. Invocation of tests with JUnit reporter. exec ut.run(ut_junit_reporter()); The ut_junit_reporter doesn't accept any arguments. Example of junit report integrated with Jenkins CI Example of failure report details Teamcity reporter \u00b6 Teamcity is a CI server by Jetbrains. It supports XUnit reporting and additionally has it's own format of reporting that allows tracking of progress of a CI step/task as it executes. The TeamCity format developed by Jetbrains is supported by utPLSQL with ut_teamcity_reporter . Invocation of tests with Teamcity reporter. exec ut.run(ut_teamcity_reporter()); The ut_teamcity_reporter doesn't accept any arguments. Example of unit test report from Teamcity CI server. Example of failure report details Sonar test reporter \u00b6 If you are using SonarQube to do static code analysis for you PLSQL projects, your code analysis can benefit from code coverage and test results. utPLSQL provides two reporters to for SonarQube: - ut_sonar_test_reporter - provides an XML output of each test executed per each project test file (package) - ut_coverage_sonar_reporter - provides XML output of code coverage per each project source file ut_sonar_test_reporter needs to be called with a list of paths to test files (packages). The paths to files can be relative to the project root directory (recommended) or be absolute. ut_coverage_sonar_reporter needs to be called with a list of paths to source files for your project. The paths to files can be relative to the project root directory (recommended) or be absolute. Providing invalid paths or paths to non-existing files will result in failure when publishing test results/coverage results to sonar server. For details on how to invoke reporter with paths, see the Coverage reporters section. TFS / VSTS Reporter \u00b6 If you are using TFS or VSTS to do static code analysis for you PLSQL projects and run builds, your code analysis can benefit from code coverage and test results. TFS reporter is designed specifically to work with Microsoft Team Fundation Server report format which is very old version of JUnit . Main diffrence between standard JUnit is that elements cannot be nested and attribute skipped is not present. utPLSQL provides test reporter to for TFS / VSTS server: - ut_tfs_junit_reporter - provides an XML output of each test executed per each project test file (package) Example of test report from TFS CI server. Summary: Details: Coverage reporters \u00b6 utPLSQL comes with a set of build-in coverage reporters. Have a look into the coverage documentation to learn more about them.","title":"Using reporters"},{"location":"userguide/reporters.html#documentation-reporter","text":"The ut_documentation_reporter is the default reporting format used by the framework. It provides a human readable test results. To invoke tests with documentation reporter use one of following calls from sql console (SQLPlus) exec ut.run(); exec ut.run(ut_documentation_reporter()); Example outputs from documentation reporter. The documentation report provides the following information. - Test suite name or test package name (nested with suitepath if suitepath is used) - Test description name or test procedure name - Information about test failing (FAILED - n) - Information about disabled test (IGNORED) - List of all errors and failures - Summary with total number of tests, number of tests with status and timing for the execution","title":"Documentation reporter"},{"location":"userguide/reporters.html#color-output-from-documentation-reporter","text":"When invoking tests with documentation reporter and your command line supports ANSICONSOLE (default on Unix) available for Windows , you can obtain the coloured outputs from the documentation reporter. To invoke tests with documentation reporter in color mode use one of following calls. exec ut.run(a_color_console=>true); exec ut.run(ut_documentation_reporter(), a_color_console=>true); Example outputs from documentation reporter.","title":"Color output from documentation reporter"},{"location":"userguide/reporters.html#junit-reporter","text":"Most of continuous integration servers (like Jenkins) are capable of consuming unit test execution results in JUnit format. The ut_junit_reporter in earlier version referred as ut_xunit_reporter is producing outcomes as JUnit-compatible XML unit test report, that can be used by CI servers to display their custom reports and provide metrics (like tests execution trends). Please note that in previous versions it was called ut_xunit_reporter and for backward compatibility that name still exists. Invocation of tests with JUnit reporter. exec ut.run(ut_junit_reporter()); The ut_junit_reporter doesn't accept any arguments. Example of junit report integrated with Jenkins CI Example of failure report details","title":"JUnit reporter"},{"location":"userguide/reporters.html#teamcity-reporter","text":"Teamcity is a CI server by Jetbrains. It supports XUnit reporting and additionally has it's own format of reporting that allows tracking of progress of a CI step/task as it executes. The TeamCity format developed by Jetbrains is supported by utPLSQL with ut_teamcity_reporter . Invocation of tests with Teamcity reporter. exec ut.run(ut_teamcity_reporter()); The ut_teamcity_reporter doesn't accept any arguments. Example of unit test report from Teamcity CI server. Example of failure report details","title":"Teamcity reporter"},{"location":"userguide/reporters.html#sonar-test-reporter","text":"If you are using SonarQube to do static code analysis for you PLSQL projects, your code analysis can benefit from code coverage and test results. utPLSQL provides two reporters to for SonarQube: - ut_sonar_test_reporter - provides an XML output of each test executed per each project test file (package) - ut_coverage_sonar_reporter - provides XML output of code coverage per each project source file ut_sonar_test_reporter needs to be called with a list of paths to test files (packages). The paths to files can be relative to the project root directory (recommended) or be absolute. ut_coverage_sonar_reporter needs to be called with a list of paths to source files for your project. The paths to files can be relative to the project root directory (recommended) or be absolute. Providing invalid paths or paths to non-existing files will result in failure when publishing test results/coverage results to sonar server. For details on how to invoke reporter with paths, see the Coverage reporters section.","title":"Sonar test reporter"},{"location":"userguide/reporters.html#tfs-vsts-reporter","text":"If you are using TFS or VSTS to do static code analysis for you PLSQL projects and run builds, your code analysis can benefit from code coverage and test results. TFS reporter is designed specifically to work with Microsoft Team Fundation Server report format which is very old version of JUnit . Main diffrence between standard JUnit is that elements cannot be nested and attribute skipped is not present. utPLSQL provides test reporter to for TFS / VSTS server: - ut_tfs_junit_reporter - provides an XML output of each test executed per each project test file (package) Example of test report from TFS CI server. Summary: Details:","title":"TFS / VSTS Reporter"},{"location":"userguide/reporters.html#coverage-reporters","text":"utPLSQL comes with a set of build-in coverage reporters. Have a look into the coverage documentation to learn more about them.","title":"Coverage reporters"},{"location":"userguide/running-unit-tests.html","text":"Running tests \u00b6 The utPLSQL framework provides two main entry points to run unit tests from within the database: ut.run procedures and functions ut_runner.run procedures These two entry points differ in purpose and behavior. Most of the time you will want to use ut.run as ut_runner is designed for API integration and does not output the results to the screen directly. Running from CI servers and command line \u00b6 The best way to run your tests from CI server or command line is to use the utPLSQL-cli command line client. Amongst many benefits it provides ability to: * see the progress of test execution for long-running tests - real-time reporting * use many reporting formats simultaneously and save reports to files (publish) * map your project source files and test files into database objects You may download the latest release of the command line client from here or do it automatically using the command below (Unix). #!/bin/bash # Get the url to latest release \"zip\" file DOWNLOAD_URL = $( curl --silent https://api.github.com/repos/utPLSQL/utPLSQL-cli/releases/latest | awk '/zipball_url/ { print $2 }' | sed -r 's/\"|,//g' ) # Download the latest release \"zip\" file curl -Lk \" ${ DOWNLOAD_URL } \" -o utplsql-cli.zip # Extract downloaded \"zip\" file unzip -q utplsql-cli.zip ut.run \u00b6 The ut package contains overloaded run procedures and functions. The run API is designed to be called directly by a developer when using an IDE/SQL console to execute unit tests. The main benefit of using this API is it's simplicity. A single line call is enough to execute a set of tests from one or more schemes. The procedures execute the specified tests and produce output to DBMS_OUTPUT using the specified reporter. The functions can only be used in SELECT statements. They execute the specified tests and produce outputs as a pipelined data stream to be consumed by a select statement. ut.run procedures \u00b6 The examples below illustrate different ways and options to invoke ut.run procedures. alter session set current_schema = hr ; begin ut . run (); end ; Executes all tests in current schema ( HR ). begin ut . run ( 'HR' ); end ; Executes all tests in specified schema ( HR ). begin ut . run ( 'hr:com.my_org.my_project' ); end ; Executes all tests from all packages that are on the com.my_org.my_project suitepath. Check the annotations documentation to find out about suitepaths and how they can be used to organize test packages for your project. begin ut . run ( 'hr.test_apply_bonus' ); end ; Executes all tests from package hr.test_apply_bonus . begin ut . run ( 'hr.test_apply_bonus.bonus_cannot_be_negative' ); end ; Executes single test procedure hr.test_apply_bonus.bonus_cannot_be_negative . begin ut . run ( ut_varchar2_list ( 'hr.test_apply_bonus' , 'cust' )); end ; Executes all tests from package hr.test_apply_bonus and all tests from schema cust . begin ut . run ( ut_varchar2_list ( 'hr.test_apply_bonus,cust)' ); end ; Executes all tests from package hr.test_apply_bonus and all tests from schema cust . begin ut . run ( 'hr.test_apply_bonus,cust' ); end ; Executes all tests from package hr.test_apply_bonus and all tests from schema cust . Using a list of items to execute allows you to execute a fine-grained set of tests. List can be passed as a comma separated list or a list of ut_varchar2_list objects or as a list within ut_varchar2_list. Note: ut_documentation_reporter is the default reporter for all APIs defined for running unit tests. The ut.run procedures and functions accept a_reporter attribute that defines the reporter to be used in the run. You can execute any set of tests with any of the predefined reporters. begin ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ()); end ; Executes all tests from package HR.TEST_APPLY_BONUS and provide outputs to DBMS_OUTPUT using the XUnit reporter. For details on build-in reporters look at reporters documentation . ut.run functions \u00b6 The ut.run functions provide exactly the same functionality as the ut.run procedures. You may use the same sets of parameters with both functions and procedures. The only difference is the output of the results. Functions provide output as a pipelined stream and therefore need to be executed as select statements. Example. select * from table ( ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ())); ut_runner.run procedures \u00b6 The ut_runner package provides an API for integrating utPLSQL with other products. Maven, Jenkins, SQL Develper, PL/SQL Developer, TOAD and others can leverage this API to call utPLSQL. The main difference compared to the ut.run API is that ut_runner.run does not print output to the screen. ut_runner.run accepts multiple reporters. Each reporter pipes to a separate output (uniquely identified by output_id). Outputs of multiple reporters can be consumed in parallel. This allows for live reporting of test execution progress with threads and several database sessions. The concept is pretty simple. in the main thread (session), define the reporters to be used. Each reporter has it's output_id and so you need to extract and store those output_ids. as a separate thread, start ut_runner.run and pass reporters with previously defined output_ids. for each reporter start a separate thread and read outputs from the ut_output_buffer.get_lines table function by providing the output_id defined in the main thread.","title":"Running unit tests"},{"location":"userguide/running-unit-tests.html#running-tests","text":"The utPLSQL framework provides two main entry points to run unit tests from within the database: ut.run procedures and functions ut_runner.run procedures These two entry points differ in purpose and behavior. Most of the time you will want to use ut.run as ut_runner is designed for API integration and does not output the results to the screen directly.","title":"Running tests"},{"location":"userguide/running-unit-tests.html#running-from-ci-servers-and-command-line","text":"The best way to run your tests from CI server or command line is to use the utPLSQL-cli command line client. Amongst many benefits it provides ability to: * see the progress of test execution for long-running tests - real-time reporting * use many reporting formats simultaneously and save reports to files (publish) * map your project source files and test files into database objects You may download the latest release of the command line client from here or do it automatically using the command below (Unix). #!/bin/bash # Get the url to latest release \"zip\" file DOWNLOAD_URL = $( curl --silent https://api.github.com/repos/utPLSQL/utPLSQL-cli/releases/latest | awk '/zipball_url/ { print $2 }' | sed -r 's/\"|,//g' ) # Download the latest release \"zip\" file curl -Lk \" ${ DOWNLOAD_URL } \" -o utplsql-cli.zip # Extract downloaded \"zip\" file unzip -q utplsql-cli.zip","title":"Running from CI servers and command line"},{"location":"userguide/running-unit-tests.html#utrun","text":"The ut package contains overloaded run procedures and functions. The run API is designed to be called directly by a developer when using an IDE/SQL console to execute unit tests. The main benefit of using this API is it's simplicity. A single line call is enough to execute a set of tests from one or more schemes. The procedures execute the specified tests and produce output to DBMS_OUTPUT using the specified reporter. The functions can only be used in SELECT statements. They execute the specified tests and produce outputs as a pipelined data stream to be consumed by a select statement.","title":"ut.run"},{"location":"userguide/running-unit-tests.html#utrun-procedures","text":"The examples below illustrate different ways and options to invoke ut.run procedures. alter session set current_schema = hr ; begin ut . run (); end ; Executes all tests in current schema ( HR ). begin ut . run ( 'HR' ); end ; Executes all tests in specified schema ( HR ). begin ut . run ( 'hr:com.my_org.my_project' ); end ; Executes all tests from all packages that are on the com.my_org.my_project suitepath. Check the annotations documentation to find out about suitepaths and how they can be used to organize test packages for your project. begin ut . run ( 'hr.test_apply_bonus' ); end ; Executes all tests from package hr.test_apply_bonus . begin ut . run ( 'hr.test_apply_bonus.bonus_cannot_be_negative' ); end ; Executes single test procedure hr.test_apply_bonus.bonus_cannot_be_negative . begin ut . run ( ut_varchar2_list ( 'hr.test_apply_bonus' , 'cust' )); end ; Executes all tests from package hr.test_apply_bonus and all tests from schema cust . begin ut . run ( ut_varchar2_list ( 'hr.test_apply_bonus,cust)' ); end ; Executes all tests from package hr.test_apply_bonus and all tests from schema cust . begin ut . run ( 'hr.test_apply_bonus,cust' ); end ; Executes all tests from package hr.test_apply_bonus and all tests from schema cust . Using a list of items to execute allows you to execute a fine-grained set of tests. List can be passed as a comma separated list or a list of ut_varchar2_list objects or as a list within ut_varchar2_list. Note: ut_documentation_reporter is the default reporter for all APIs defined for running unit tests. The ut.run procedures and functions accept a_reporter attribute that defines the reporter to be used in the run. You can execute any set of tests with any of the predefined reporters. begin ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ()); end ; Executes all tests from package HR.TEST_APPLY_BONUS and provide outputs to DBMS_OUTPUT using the XUnit reporter. For details on build-in reporters look at reporters documentation .","title":"ut.run procedures"},{"location":"userguide/running-unit-tests.html#utrun-functions","text":"The ut.run functions provide exactly the same functionality as the ut.run procedures. You may use the same sets of parameters with both functions and procedures. The only difference is the output of the results. Functions provide output as a pipelined stream and therefore need to be executed as select statements. Example. select * from table ( ut . run ( 'hr.test_apply_bonus' , ut_xunit_reporter ()));","title":"ut.run functions"},{"location":"userguide/running-unit-tests.html#ut_runnerrun-procedures","text":"The ut_runner package provides an API for integrating utPLSQL with other products. Maven, Jenkins, SQL Develper, PL/SQL Developer, TOAD and others can leverage this API to call utPLSQL. The main difference compared to the ut.run API is that ut_runner.run does not print output to the screen. ut_runner.run accepts multiple reporters. Each reporter pipes to a separate output (uniquely identified by output_id). Outputs of multiple reporters can be consumed in parallel. This allows for live reporting of test execution progress with threads and several database sessions. The concept is pretty simple. in the main thread (session), define the reporters to be used. Each reporter has it's output_id and so you need to extract and store those output_ids. as a separate thread, start ut_runner.run and pass reporters with previously defined output_ids. for each reporter start a separate thread and read outputs from the ut_output_buffer.get_lines table function by providing the output_id defined in the main thread.","title":"ut_runner.run procedures"},{"location":"userguide/upgrade.html","text":"Upgrading from version 2 \u00b6 utPLSQL v3 is a total rewrite of the framework. To make utPLSQL v2 packages run on v3 framework you need to install and execute migration utility. See the utPLSQL-v2-v3-migration project for details on how to install and execute the migration.","title":"Upgrade utPLSQL"},{"location":"userguide/upgrade.html#upgrading-from-version-2","text":"utPLSQL v3 is a total rewrite of the framework. To make utPLSQL v2 packages run on v3 framework you need to install and execute migration utility. See the utPLSQL-v2-v3-migration project for details on how to install and execute the migration.","title":"Upgrading from version 2"}]}